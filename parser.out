shift/reduce conflict in state 347 resolved as shift.


Unused terminals:

   TYPEDEF_CHAR
   RANGE
   UNSIGNED_CHAR
   ERRORCODE
   TYPEDEF_INT
   ERRORCODE2
   UNSIGNED_INT

Grammar

Rule 1     primary_expr -> identifier
Rule 2     primary_expr -> CONSTANT
Rule 3     primary_expr -> STRING_LITERAL
Rule 4     primary_expr -> ( expr )
Rule 5     postfix_expr -> primary_expr
Rule 6     postfix_expr -> postfix_expr [ expr ]
Rule 7     postfix_expr -> postfix_expr ( )
Rule 8     postfix_expr -> postfix_expr ( argument_expr_list )
Rule 9     postfix_expr -> postfix_expr . identifier
Rule 10    postfix_expr -> postfix_expr PTR_OP identifier
Rule 11    postfix_expr -> postfix_expr INC_OP
Rule 12    postfix_expr -> postfix_expr DEC_OP
Rule 13    argument_expr_list -> assignment_expr
Rule 14    argument_expr_list -> argument_expr_list , assignment_expr
Rule 15    unary_expr -> postfix_expr
Rule 16    unary_expr -> INC_OP unary_expr
Rule 17    unary_expr -> DEC_OP unary_expr
Rule 18    unary_expr -> unary_operator cast_expr
Rule 19    unary_expr -> SIZEOF unary_expr
Rule 20    unary_expr -> SIZEOF ( type_name )
Rule 21    unary_operator -> &
Rule 22    unary_operator -> *
Rule 23    unary_operator -> +
Rule 24    unary_operator -> -
Rule 25    unary_operator -> ~
Rule 26    unary_operator -> !
Rule 27    cast_expr -> unary_expr
Rule 28    cast_expr -> ( type_name ) cast_expr
Rule 29    multiplicative_expr -> cast_expr
Rule 30    multiplicative_expr -> multiplicative_expr * cast_expr
Rule 31    multiplicative_expr -> multiplicative_expr / cast_expr
Rule 32    multiplicative_expr -> multiplicative_expr % cast_expr
Rule 33    additive_expr -> multiplicative_expr
Rule 34    additive_expr -> additive_expr + multiplicative_expr
Rule 35    additive_expr -> additive_expr - multiplicative_expr
Rule 36    shift_expr -> additive_expr
Rule 37    shift_expr -> shift_expr LEFT_OP additive_expr
Rule 38    shift_expr -> shift_expr RIGHT_OP additive_expr
Rule 39    relational_expr -> shift_expr
Rule 40    relational_expr -> relational_expr < shift_expr
Rule 41    relational_expr -> relational_expr > shift_expr
Rule 42    relational_expr -> relational_expr LE_OP shift_expr
Rule 43    relational_expr -> relational_expr GE_OP shift_expr
Rule 44    equality_expr -> relational_expr
Rule 45    equality_expr -> equality_expr EQ_OP relational_expr
Rule 46    equality_expr -> equality_expr NE_OP relational_expr
Rule 47    and_expr -> equality_expr
Rule 48    and_expr -> and_expr & equality_expr
Rule 49    exclusive_or_expr -> and_expr
Rule 50    exclusive_or_expr -> exclusive_or_expr ^ and_expr
Rule 51    inclusive_or_expr -> exclusive_or_expr
Rule 52    inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr
Rule 53    logical_and_expr -> inclusive_or_expr
Rule 54    logical_and_expr -> logical_and_expr AND_OP inclusive_or_expr
Rule 55    logical_or_expr -> logical_and_expr
Rule 56    logical_or_expr -> logical_or_expr OR_OP logical_and_expr
Rule 57    conditional_expr -> logical_or_expr
Rule 58    conditional_expr -> logical_or_expr ? logical_or_expr : conditional_expr
Rule 59    assignment_expr -> conditional_expr
Rule 60    assignment_expr -> unary_expr assignment_operator assignment_expr
Rule 61    assignment_operator -> =
Rule 62    assignment_operator -> MUL_ASSIGN
Rule 63    assignment_operator -> DIV_ASSIGN
Rule 64    assignment_operator -> MOD_ASSIGN
Rule 65    assignment_operator -> ADD_ASSIGN
Rule 66    assignment_operator -> SUB_ASSIGN
Rule 67    assignment_operator -> LEFT_ASSIGN
Rule 68    assignment_operator -> RIGHT_ASSIGN
Rule 69    assignment_operator -> AND_ASSIGN
Rule 70    assignment_operator -> XOR_ASSIGN
Rule 71    assignment_operator -> OR_ASSIGN
Rule 72    expr -> assignment_expr
Rule 73    expr -> expr , assignment_expr
Rule 74    constant_expr -> conditional_expr
Rule 75    declaration -> declaration_specifiers 
Rule 76    declaration -> declaration_specifiers init_declarator_list 
Rule 77    declaration_specifiers -> storage_class_specifier
Rule 78    declaration_specifiers -> storage_class_specifier declaration_specifiers
Rule 79    declaration_specifiers -> type_specifier
Rule 80    declaration_specifiers -> type_specifier declaration_specifiers
Rule 81    init_declarator_list -> init_declarator
Rule 82    init_declarator_list -> init_declarator_list , init_declarator
Rule 83    init_declarator -> declarator
Rule 84    init_declarator -> declarator = initializer
Rule 85    storage_class_specifier -> TYPEDEF
Rule 86    storage_class_specifier -> EXTERN
Rule 87    storage_class_specifier -> STATIC
Rule 88    storage_class_specifier -> AUTO
Rule 89    storage_class_specifier -> REGISTER
Rule 90    type_specifier -> CHAR
Rule 91    type_specifier -> SHORT
Rule 92    type_specifier -> INT
Rule 93    type_specifier -> LONG
Rule 94    type_specifier -> SIGNED
Rule 95    type_specifier -> UNSIGNED
Rule 96    type_specifier -> FLOAT
Rule 97    type_specifier -> DOUBLE
Rule 98    type_specifier -> CONST
Rule 99    type_specifier -> VOLATILE
Rule 100   type_specifier -> VOID
Rule 101   type_specifier -> struct_or_union_specifier
Rule 102   type_specifier -> enum_specifier
Rule 103   type_specifier -> TYPE_NAME
Rule 104   struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list }
Rule 105   struct_or_union_specifier -> struct_or_union { struct_declaration_list }
Rule 106   struct_or_union_specifier -> struct_or_union identifier
Rule 107   struct_or_union -> STRUCT
Rule 108   struct_or_union -> UNION
Rule 109   struct_declaration_list -> struct_declaration
Rule 110   struct_declaration_list -> struct_declaration_list struct_declaration
Rule 111   struct_declaration -> type_specifier_list struct_declarator_list 
Rule 112   struct_declarator_list -> struct_declarator
Rule 113   struct_declarator_list -> struct_declarator_list , struct_declarator
Rule 114   struct_declarator -> declarator
Rule 115   struct_declarator -> : constant_expr
Rule 116   struct_declarator -> declarator : constant_expr
Rule 117   enum_specifier -> ENUM { enumerator_list }
Rule 118   enum_specifier -> ENUM identifier { enumerator_list }
Rule 119   enum_specifier -> ENUM identifier
Rule 120   enumerator_list -> enumerator
Rule 121   enumerator_list -> enumerator_list , enumerator
Rule 122   enumerator -> identifier
Rule 123   enumerator -> identifier = constant_expr
Rule 124   declarator -> declarator2
Rule 125   declarator -> pointer declarator2
Rule 126   declarator2 -> identifier
Rule 127   declarator2 -> ( declarator )
Rule 128   declarator2 -> declarator2 [ ]
Rule 129   declarator2 -> declarator2 [ constant_expr ]
Rule 130   declarator2 -> declarator2 ( )
Rule 131   declarator2 -> declarator2 ( parameter_type_list )
Rule 132   declarator2 -> declarator2 ( parameter_identifier_list )
Rule 133   pointer -> *
Rule 134   pointer -> * type_specifier_list
Rule 135   pointer -> * pointer
Rule 136   pointer -> * type_specifier_list pointer
Rule 137   type_specifier_list -> type_specifier
Rule 138   type_specifier_list -> type_specifier_list type_specifier
Rule 139   parameter_identifier_list -> identifier_list
Rule 140   parameter_identifier_list -> identifier_list , ELIPSIS
Rule 141   identifier_list -> identifier
Rule 142   identifier_list -> identifier_list , identifier
Rule 143   parameter_type_list -> parameter_list
Rule 144   parameter_type_list -> parameter_list , ELIPSIS
Rule 145   parameter_list -> parameter_declaration
Rule 146   parameter_list -> parameter_list , parameter_declaration
Rule 147   parameter_declaration -> type_specifier_list declarator
Rule 148   parameter_declaration -> type_name
Rule 149   type_name -> type_specifier_list
Rule 150   type_name -> type_specifier_list abstract_declarator
Rule 151   abstract_declarator -> pointer
Rule 152   abstract_declarator -> abstract_declarator2
Rule 153   abstract_declarator -> pointer abstract_declarator2
Rule 154   abstract_declarator2 -> ( abstract_declarator )
Rule 155   abstract_declarator2 -> [ ]
Rule 156   abstract_declarator2 -> [ constant_expr ]
Rule 157   abstract_declarator2 -> abstract_declarator2 [ ]
Rule 158   abstract_declarator2 -> abstract_declarator2 [ constant_expr ]
Rule 159   abstract_declarator2 -> ( )
Rule 160   abstract_declarator2 -> ( parameter_type_list )
Rule 161   abstract_declarator2 -> abstract_declarator2 ( )
Rule 162   abstract_declarator2 -> abstract_declarator2 ( parameter_type_list )
Rule 163   initializer -> assignment_expr
Rule 164   initializer -> { initializer_list }
Rule 165   initializer -> { initializer_list , }
Rule 166   initializer_list -> initializer
Rule 167   initializer_list -> initializer_list , initializer
Rule 168   statement -> labeled_statement
Rule 169   statement -> compound_statement
Rule 170   statement -> expression_statement
Rule 171   statement -> selection_statement
Rule 172   statement -> iteration_statement
Rule 173   statement -> jump_statement
Rule 174   labeled_statement -> identifier : statement
Rule 175   labeled_statement -> CASE constant_expr : statement
Rule 176   labeled_statement -> DEFAULT : statement
Rule 177   left_bracket -> {
Rule 178   right_bracket -> }
Rule 179   compound_statement -> left_bracket right_bracket
Rule 180   compound_statement -> left_bracket statement_list right_bracket
Rule 181   compound_statement -> left_bracket declaration_list right_bracket
Rule 182   compound_statement -> left_bracket declaration_list statement_list right_bracket
Rule 183   declaration_list -> declaration
Rule 184   declaration_list -> declaration_list declaration
Rule 185   statement_list -> statement
Rule 186   statement_list -> statement_list statement
Rule 187   expression_statement -> ;
Rule 188   expression_statement -> expr ;
Rule 189   selection_statement -> IF ( expr ) statement
Rule 190   selection_statement -> IF ( expr ) statement ELSE statement
Rule 191   selection_statement -> SWITCH ( expr ) statement
Rule 192   iteration_statement -> WHILE ( expr ) statement
Rule 193   iteration_statement -> DO statement WHILE ( expr ) ;
Rule 194   iteration_statement -> FOR ( ; ; ) statement
Rule 195   iteration_statement -> FOR ( ; ; expr ) statement
Rule 196   iteration_statement -> FOR ( ; expr ; ) statement
Rule 197   iteration_statement -> FOR ( ; expr ; expr ) statement
Rule 198   iteration_statement -> FOR ( expr ; ; ) statement
Rule 199   iteration_statement -> FOR ( expr ; ; expr ) statement
Rule 200   iteration_statement -> FOR ( expr ; expr ; ) statement
Rule 201   iteration_statement -> FOR ( expr ; expr ; expr ) statement
Rule 202   jump_statement -> GOTO identifier ;
Rule 203   jump_statement -> CONTINUE ;
Rule 204   jump_statement -> BREAK ;
Rule 205   jump_statement -> RETURN ;
Rule 206   jump_statement -> RETURN expr ;
Rule 207   code -> file
Rule 208   file -> external_definition
Rule 209   file -> file external_definition
Rule 210   external_definition -> function_definition
Rule 211   external_definition -> declaration
Rule 212   function_definition -> declarator function_body
Rule 213   function_definition -> declaration_specifiers declarator function_body
Rule 214   function_body -> compound_statement
Rule 215   function_body -> declaration_list compound_statement
Rule 216   identifier -> IDENTIFIER

Terminals, with rules where they appear

                     : 75 76 111
!                    : 26
%                    : 32
&                    : 21 48
(                    : 4 7 8 20 28 127 130 131 132 154 159 160 161 162 189 190 191 192 193 194 195 196 197 198 199 200 201
)                    : 4 7 8 20 28 127 130 131 132 154 159 160 161 162 189 190 191 192 193 194 195 196 197 198 199 200 201
*                    : 22 30 133 134 135 136
+                    : 23 34
,                    : 14 73 82 113 121 140 142 144 146 165 167
-                    : 24 35
.                    : 9
/                    : 31
:                    : 58 115 116 174 175 176
;                    : 187 188 193 194 194 195 195 196 196 197 197 198 198 199 199 200 200 201 201 202 203 204 205 206
<                    : 40
=                    : 61 84 123
>                    : 41
?                    : 58
ADD_ASSIGN           : 65
AND_ASSIGN           : 69
AND_OP               : 54
AUTO                 : 88
BREAK                : 204
CASE                 : 175
CHAR                 : 90
CONST                : 98
CONSTANT             : 2
CONTINUE             : 203
DEC_OP               : 12 17
DEFAULT              : 176
DIV_ASSIGN           : 63
DO                   : 193
DOUBLE               : 97
ELIPSIS              : 140 144
ELSE                 : 190
ENUM                 : 117 118 119
EQ_OP                : 45
ERRORCODE            : 
ERRORCODE2           : 
EXTERN               : 86
FLOAT                : 96
FOR                  : 194 195 196 197 198 199 200 201
GE_OP                : 43
GOTO                 : 202
IDENTIFIER           : 216
IF                   : 189 190
INC_OP               : 11 16
INT                  : 92
LEFT_ASSIGN          : 67
LEFT_OP              : 37
LE_OP                : 42
LONG                 : 93
MOD_ASSIGN           : 64
MUL_ASSIGN           : 62
NE_OP                : 46
OR_ASSIGN            : 71
OR_OP                : 56
PTR_OP               : 10
RANGE                : 
REGISTER             : 89
RETURN               : 205 206
RIGHT_ASSIGN         : 68
RIGHT_OP             : 38
SHORT                : 91
SIGNED               : 94
SIZEOF               : 19 20
STATIC               : 87
STRING_LITERAL       : 3
STRUCT               : 107
SUB_ASSIGN           : 66
SWITCH               : 191
TYPEDEF              : 85
TYPEDEF_CHAR         : 
TYPEDEF_INT          : 
TYPE_NAME            : 103
UNION                : 108
UNSIGNED             : 95
UNSIGNED_CHAR        : 
UNSIGNED_INT         : 
VOID                 : 100
VOLATILE             : 99
WHILE                : 192 193
XOR_ASSIGN           : 70
[                    : 6 128 129 155 156 157 158
]                    : 6 128 129 155 156 157 158
^                    : 50
error                : 
{                    : 104 105 117 118 164 165 177
|                    : 52
}                    : 104 105 117 118 164 165 178
~                    : 25

Nonterminals, with rules where they appear

abstract_declarator  : 150 154
abstract_declarator2 : 152 153 157 158 161 162
additive_expr        : 34 35 36 37 38
and_expr             : 48 49 50
argument_expr_list   : 8 14
assignment_expr      : 13 14 60 72 73 163
assignment_operator  : 60
cast_expr            : 18 28 29 30 31 32
code                 : 0
compound_statement   : 169 214 215
conditional_expr     : 58 59 74
constant_expr        : 115 116 123 129 156 158 175
declaration          : 183 184 211
declaration_list     : 181 182 184 215
declaration_specifiers : 75 76 78 80 213
declarator           : 83 84 114 116 127 147 212 213
declarator2          : 124 125 128 129 130 131 132
enum_specifier       : 102
enumerator           : 120 121
enumerator_list      : 117 118 121
equality_expr        : 45 46 47 48
exclusive_or_expr    : 50 51 52
expr                 : 4 6 73 188 189 190 191 192 193 195 196 197 197 198 199 199 200 200 201 201 201 206
expression_statement : 170
external_definition  : 208 209
file                 : 207 209
function_body        : 212 213
function_definition  : 210
identifier           : 1 9 10 104 106 118 119 122 123 126 141 142 174 202
identifier_list      : 139 140 142
inclusive_or_expr    : 52 53 54
init_declarator      : 81 82
init_declarator_list : 76 82
initializer          : 84 166 167
initializer_list     : 164 165 167
iteration_statement  : 172
jump_statement       : 173
labeled_statement    : 168
left_bracket         : 179 180 181 182
logical_and_expr     : 54 55 56
logical_or_expr      : 56 57 58 58
multiplicative_expr  : 30 31 32 33 34 35
parameter_declaration : 145 146
parameter_identifier_list : 132
parameter_list       : 143 144 146
parameter_type_list  : 131 160 162
pointer              : 125 135 136 151 153
postfix_expr         : 6 7 8 9 10 11 12 15
primary_expr         : 5
relational_expr      : 40 41 42 43 44 45 46
right_bracket        : 179 180 181 182
selection_statement  : 171
shift_expr           : 37 38 39 40 41 42 43
statement            : 174 175 176 185 186 189 190 190 191 192 193 194 195 196 197 198 199 200 201
statement_list       : 180 182 186
storage_class_specifier : 77 78
struct_declaration   : 109 110
struct_declaration_list : 104 105 110
struct_declarator    : 112 113
struct_declarator_list : 111 113
struct_or_union      : 104 105 106
struct_or_union_specifier : 101
type_name            : 20 28 148
type_specifier       : 79 80 137 138
type_specifier_list  : 111 134 136 138 147 149 150
unary_expr           : 16 17 19 27 60
unary_operator       : 18


Parsing method: LALR


state 0

    (0) S' -> . code
    (207) code -> . file
    (208) file -> . external_definition
    (209) file -> . file external_definition
    (210) external_definition -> . function_definition
    (211) external_definition -> . declaration
    (212) function_definition -> . declarator function_body
    (213) function_definition -> . declaration_specifiers declarator function_body
    (75) declaration -> . declaration_specifiers 
    (76) declaration -> . declaration_specifiers init_declarator_list 
    (124) declarator -> . declarator2
    (125) declarator -> . pointer declarator2
    (77) declaration_specifiers -> . storage_class_specifier
    (78) declaration_specifiers -> . storage_class_specifier declaration_specifiers
    (79) declaration_specifiers -> . type_specifier
    (80) declaration_specifiers -> . type_specifier declaration_specifiers
    (126) declarator2 -> . identifier
    (127) declarator2 -> . ( declarator )
    (128) declarator2 -> . declarator2 [ ]
    (129) declarator2 -> . declarator2 [ constant_expr ]
    (130) declarator2 -> . declarator2 ( )
    (131) declarator2 -> . declarator2 ( parameter_type_list )
    (132) declarator2 -> . declarator2 ( parameter_identifier_list )
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (85) storage_class_specifier -> . TYPEDEF
    (86) storage_class_specifier -> . EXTERN
    (87) storage_class_specifier -> . STATIC
    (88) storage_class_specifier -> . AUTO
    (89) storage_class_specifier -> . REGISTER
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (216) identifier -> . IDENTIFIER
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    (               shift and go to state 16
    *               shift and go to state 17
    TYPEDEF         shift and go to state 22
    EXTERN          shift and go to state 12
    STATIC          shift and go to state 10
    AUTO            shift and go to state 23
    REGISTER        shift and go to state 36
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    IDENTIFIER      shift and go to state 21
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    external_definition            shift and go to state 1
    storage_class_specifier        shift and go to state 38
    code                           shift and go to state 2
    struct_or_union_specifier      shift and go to state 4
    declarator2                    shift and go to state 7
    file                           shift and go to state 11
    pointer                        shift and go to state 14
    type_specifier                 shift and go to state 15
    struct_or_union                shift and go to state 6
    declaration_specifiers         shift and go to state 25
    declaration                    shift and go to state 26
    function_definition            shift and go to state 27
    enum_specifier                 shift and go to state 33
    declarator                     shift and go to state 35
    identifier                     shift and go to state 37

state 1

    (208) file -> external_definition .

    (               reduce using rule 208 (file -> external_definition .)
    *               reduce using rule 208 (file -> external_definition .)
    TYPEDEF         reduce using rule 208 (file -> external_definition .)
    EXTERN          reduce using rule 208 (file -> external_definition .)
    STATIC          reduce using rule 208 (file -> external_definition .)
    AUTO            reduce using rule 208 (file -> external_definition .)
    REGISTER        reduce using rule 208 (file -> external_definition .)
    CHAR            reduce using rule 208 (file -> external_definition .)
    SHORT           reduce using rule 208 (file -> external_definition .)
    INT             reduce using rule 208 (file -> external_definition .)
    LONG            reduce using rule 208 (file -> external_definition .)
    SIGNED          reduce using rule 208 (file -> external_definition .)
    UNSIGNED        reduce using rule 208 (file -> external_definition .)
    FLOAT           reduce using rule 208 (file -> external_definition .)
    DOUBLE          reduce using rule 208 (file -> external_definition .)
    CONST           reduce using rule 208 (file -> external_definition .)
    VOLATILE        reduce using rule 208 (file -> external_definition .)
    VOID            reduce using rule 208 (file -> external_definition .)
    TYPE_NAME       reduce using rule 208 (file -> external_definition .)
    IDENTIFIER      reduce using rule 208 (file -> external_definition .)
    ENUM            reduce using rule 208 (file -> external_definition .)
    STRUCT          reduce using rule 208 (file -> external_definition .)
    UNION           reduce using rule 208 (file -> external_definition .)
    $end            reduce using rule 208 (file -> external_definition .)



state 2

    (0) S' -> code .




state 3

    (98) type_specifier -> CONST .

    CHAR            reduce using rule 98 (type_specifier -> CONST .)
    SHORT           reduce using rule 98 (type_specifier -> CONST .)
    INT             reduce using rule 98 (type_specifier -> CONST .)
    LONG            reduce using rule 98 (type_specifier -> CONST .)
    SIGNED          reduce using rule 98 (type_specifier -> CONST .)
    UNSIGNED        reduce using rule 98 (type_specifier -> CONST .)
    FLOAT           reduce using rule 98 (type_specifier -> CONST .)
    DOUBLE          reduce using rule 98 (type_specifier -> CONST .)
    CONST           reduce using rule 98 (type_specifier -> CONST .)
    VOLATILE        reduce using rule 98 (type_specifier -> CONST .)
    VOID            reduce using rule 98 (type_specifier -> CONST .)
    TYPE_NAME       reduce using rule 98 (type_specifier -> CONST .)
    (               reduce using rule 98 (type_specifier -> CONST .)
    *               reduce using rule 98 (type_specifier -> CONST .)
    ENUM            reduce using rule 98 (type_specifier -> CONST .)
    [               reduce using rule 98 (type_specifier -> CONST .)
    IDENTIFIER      reduce using rule 98 (type_specifier -> CONST .)
    STRUCT          reduce using rule 98 (type_specifier -> CONST .)
    UNION           reduce using rule 98 (type_specifier -> CONST .)
    ,               reduce using rule 98 (type_specifier -> CONST .)
    )               reduce using rule 98 (type_specifier -> CONST .)
    :               reduce using rule 98 (type_specifier -> CONST .)
    TYPEDEF         reduce using rule 98 (type_specifier -> CONST .)
    EXTERN          reduce using rule 98 (type_specifier -> CONST .)
    STATIC          reduce using rule 98 (type_specifier -> CONST .)
    AUTO            reduce using rule 98 (type_specifier -> CONST .)
    REGISTER        reduce using rule 98 (type_specifier -> CONST .)
                    reduce using rule 98 (type_specifier -> CONST .)



state 4

    (101) type_specifier -> struct_or_union_specifier .

    CHAR            reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    SHORT           reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    INT             reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    LONG            reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    SIGNED          reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    UNSIGNED        reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    FLOAT           reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    DOUBLE          reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    CONST           reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    VOLATILE        reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    VOID            reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    TYPE_NAME       reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    (               reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    *               reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    ENUM            reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    [               reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    IDENTIFIER      reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    STRUCT          reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    UNION           reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    ,               reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    )               reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    :               reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    TYPEDEF         reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    EXTERN          reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    STATIC          reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    AUTO            reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
    REGISTER        reduce using rule 101 (type_specifier -> struct_or_union_specifier .)
                    reduce using rule 101 (type_specifier -> struct_or_union_specifier .)



state 5

    (100) type_specifier -> VOID .

    CHAR            reduce using rule 100 (type_specifier -> VOID .)
    SHORT           reduce using rule 100 (type_specifier -> VOID .)
    INT             reduce using rule 100 (type_specifier -> VOID .)
    LONG            reduce using rule 100 (type_specifier -> VOID .)
    SIGNED          reduce using rule 100 (type_specifier -> VOID .)
    UNSIGNED        reduce using rule 100 (type_specifier -> VOID .)
    FLOAT           reduce using rule 100 (type_specifier -> VOID .)
    DOUBLE          reduce using rule 100 (type_specifier -> VOID .)
    CONST           reduce using rule 100 (type_specifier -> VOID .)
    VOLATILE        reduce using rule 100 (type_specifier -> VOID .)
    VOID            reduce using rule 100 (type_specifier -> VOID .)
    TYPE_NAME       reduce using rule 100 (type_specifier -> VOID .)
    (               reduce using rule 100 (type_specifier -> VOID .)
    *               reduce using rule 100 (type_specifier -> VOID .)
    ENUM            reduce using rule 100 (type_specifier -> VOID .)
    [               reduce using rule 100 (type_specifier -> VOID .)
    IDENTIFIER      reduce using rule 100 (type_specifier -> VOID .)
    STRUCT          reduce using rule 100 (type_specifier -> VOID .)
    UNION           reduce using rule 100 (type_specifier -> VOID .)
    ,               reduce using rule 100 (type_specifier -> VOID .)
    )               reduce using rule 100 (type_specifier -> VOID .)
    :               reduce using rule 100 (type_specifier -> VOID .)
    TYPEDEF         reduce using rule 100 (type_specifier -> VOID .)
    EXTERN          reduce using rule 100 (type_specifier -> VOID .)
    STATIC          reduce using rule 100 (type_specifier -> VOID .)
    AUTO            reduce using rule 100 (type_specifier -> VOID .)
    REGISTER        reduce using rule 100 (type_specifier -> VOID .)
                    reduce using rule 100 (type_specifier -> VOID .)



state 6

    (104) struct_or_union_specifier -> struct_or_union . identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> struct_or_union . { struct_declaration_list }
    (106) struct_or_union_specifier -> struct_or_union . identifier
    (216) identifier -> . IDENTIFIER

    {               shift and go to state 40
    IDENTIFIER      shift and go to state 21


    identifier                     shift and go to state 39

state 7

    (124) declarator -> declarator2 .
    (128) declarator2 -> declarator2 . [ ]
    (129) declarator2 -> declarator2 . [ constant_expr ]
    (130) declarator2 -> declarator2 . ( )
    (131) declarator2 -> declarator2 . ( parameter_type_list )
    (132) declarator2 -> declarator2 . ( parameter_identifier_list )

    :               reduce using rule 124 (declarator -> declarator2 .)
                    reduce using rule 124 (declarator -> declarator2 .)
    ,               reduce using rule 124 (declarator -> declarator2 .)
    =               reduce using rule 124 (declarator -> declarator2 .)
    {               reduce using rule 124 (declarator -> declarator2 .)
    TYPEDEF         reduce using rule 124 (declarator -> declarator2 .)
    EXTERN          reduce using rule 124 (declarator -> declarator2 .)
    STATIC          reduce using rule 124 (declarator -> declarator2 .)
    AUTO            reduce using rule 124 (declarator -> declarator2 .)
    REGISTER        reduce using rule 124 (declarator -> declarator2 .)
    CHAR            reduce using rule 124 (declarator -> declarator2 .)
    SHORT           reduce using rule 124 (declarator -> declarator2 .)
    INT             reduce using rule 124 (declarator -> declarator2 .)
    LONG            reduce using rule 124 (declarator -> declarator2 .)
    SIGNED          reduce using rule 124 (declarator -> declarator2 .)
    UNSIGNED        reduce using rule 124 (declarator -> declarator2 .)
    FLOAT           reduce using rule 124 (declarator -> declarator2 .)
    DOUBLE          reduce using rule 124 (declarator -> declarator2 .)
    CONST           reduce using rule 124 (declarator -> declarator2 .)
    VOLATILE        reduce using rule 124 (declarator -> declarator2 .)
    VOID            reduce using rule 124 (declarator -> declarator2 .)
    TYPE_NAME       reduce using rule 124 (declarator -> declarator2 .)
    ENUM            reduce using rule 124 (declarator -> declarator2 .)
    STRUCT          reduce using rule 124 (declarator -> declarator2 .)
    UNION           reduce using rule 124 (declarator -> declarator2 .)
    )               reduce using rule 124 (declarator -> declarator2 .)
    [               shift and go to state 42
    (               shift and go to state 41



state 8

    (90) type_specifier -> CHAR .

    CHAR            reduce using rule 90 (type_specifier -> CHAR .)
    SHORT           reduce using rule 90 (type_specifier -> CHAR .)
    INT             reduce using rule 90 (type_specifier -> CHAR .)
    LONG            reduce using rule 90 (type_specifier -> CHAR .)
    SIGNED          reduce using rule 90 (type_specifier -> CHAR .)
    UNSIGNED        reduce using rule 90 (type_specifier -> CHAR .)
    FLOAT           reduce using rule 90 (type_specifier -> CHAR .)
    DOUBLE          reduce using rule 90 (type_specifier -> CHAR .)
    CONST           reduce using rule 90 (type_specifier -> CHAR .)
    VOLATILE        reduce using rule 90 (type_specifier -> CHAR .)
    VOID            reduce using rule 90 (type_specifier -> CHAR .)
    TYPE_NAME       reduce using rule 90 (type_specifier -> CHAR .)
    (               reduce using rule 90 (type_specifier -> CHAR .)
    *               reduce using rule 90 (type_specifier -> CHAR .)
    ENUM            reduce using rule 90 (type_specifier -> CHAR .)
    [               reduce using rule 90 (type_specifier -> CHAR .)
    IDENTIFIER      reduce using rule 90 (type_specifier -> CHAR .)
    STRUCT          reduce using rule 90 (type_specifier -> CHAR .)
    UNION           reduce using rule 90 (type_specifier -> CHAR .)
    ,               reduce using rule 90 (type_specifier -> CHAR .)
    )               reduce using rule 90 (type_specifier -> CHAR .)
    :               reduce using rule 90 (type_specifier -> CHAR .)
    TYPEDEF         reduce using rule 90 (type_specifier -> CHAR .)
    EXTERN          reduce using rule 90 (type_specifier -> CHAR .)
    STATIC          reduce using rule 90 (type_specifier -> CHAR .)
    AUTO            reduce using rule 90 (type_specifier -> CHAR .)
    REGISTER        reduce using rule 90 (type_specifier -> CHAR .)
                    reduce using rule 90 (type_specifier -> CHAR .)



state 9

    (91) type_specifier -> SHORT .

    CHAR            reduce using rule 91 (type_specifier -> SHORT .)
    SHORT           reduce using rule 91 (type_specifier -> SHORT .)
    INT             reduce using rule 91 (type_specifier -> SHORT .)
    LONG            reduce using rule 91 (type_specifier -> SHORT .)
    SIGNED          reduce using rule 91 (type_specifier -> SHORT .)
    UNSIGNED        reduce using rule 91 (type_specifier -> SHORT .)
    FLOAT           reduce using rule 91 (type_specifier -> SHORT .)
    DOUBLE          reduce using rule 91 (type_specifier -> SHORT .)
    CONST           reduce using rule 91 (type_specifier -> SHORT .)
    VOLATILE        reduce using rule 91 (type_specifier -> SHORT .)
    VOID            reduce using rule 91 (type_specifier -> SHORT .)
    TYPE_NAME       reduce using rule 91 (type_specifier -> SHORT .)
    (               reduce using rule 91 (type_specifier -> SHORT .)
    *               reduce using rule 91 (type_specifier -> SHORT .)
    ENUM            reduce using rule 91 (type_specifier -> SHORT .)
    [               reduce using rule 91 (type_specifier -> SHORT .)
    IDENTIFIER      reduce using rule 91 (type_specifier -> SHORT .)
    STRUCT          reduce using rule 91 (type_specifier -> SHORT .)
    UNION           reduce using rule 91 (type_specifier -> SHORT .)
    ,               reduce using rule 91 (type_specifier -> SHORT .)
    )               reduce using rule 91 (type_specifier -> SHORT .)
    :               reduce using rule 91 (type_specifier -> SHORT .)
    TYPEDEF         reduce using rule 91 (type_specifier -> SHORT .)
    EXTERN          reduce using rule 91 (type_specifier -> SHORT .)
    STATIC          reduce using rule 91 (type_specifier -> SHORT .)
    AUTO            reduce using rule 91 (type_specifier -> SHORT .)
    REGISTER        reduce using rule 91 (type_specifier -> SHORT .)
                    reduce using rule 91 (type_specifier -> SHORT .)



state 10

    (87) storage_class_specifier -> STATIC .

    TYPEDEF         reduce using rule 87 (storage_class_specifier -> STATIC .)
    EXTERN          reduce using rule 87 (storage_class_specifier -> STATIC .)
    STATIC          reduce using rule 87 (storage_class_specifier -> STATIC .)
    AUTO            reduce using rule 87 (storage_class_specifier -> STATIC .)
    REGISTER        reduce using rule 87 (storage_class_specifier -> STATIC .)
    CHAR            reduce using rule 87 (storage_class_specifier -> STATIC .)
    SHORT           reduce using rule 87 (storage_class_specifier -> STATIC .)
    INT             reduce using rule 87 (storage_class_specifier -> STATIC .)
    LONG            reduce using rule 87 (storage_class_specifier -> STATIC .)
    SIGNED          reduce using rule 87 (storage_class_specifier -> STATIC .)
    UNSIGNED        reduce using rule 87 (storage_class_specifier -> STATIC .)
    FLOAT           reduce using rule 87 (storage_class_specifier -> STATIC .)
    DOUBLE          reduce using rule 87 (storage_class_specifier -> STATIC .)
    CONST           reduce using rule 87 (storage_class_specifier -> STATIC .)
    VOLATILE        reduce using rule 87 (storage_class_specifier -> STATIC .)
    VOID            reduce using rule 87 (storage_class_specifier -> STATIC .)
    TYPE_NAME       reduce using rule 87 (storage_class_specifier -> STATIC .)
    ENUM            reduce using rule 87 (storage_class_specifier -> STATIC .)
    STRUCT          reduce using rule 87 (storage_class_specifier -> STATIC .)
    UNION           reduce using rule 87 (storage_class_specifier -> STATIC .)
                    reduce using rule 87 (storage_class_specifier -> STATIC .)
    (               reduce using rule 87 (storage_class_specifier -> STATIC .)
    *               reduce using rule 87 (storage_class_specifier -> STATIC .)
    IDENTIFIER      reduce using rule 87 (storage_class_specifier -> STATIC .)



state 11

    (207) code -> file .
    (209) file -> file . external_definition
    (210) external_definition -> . function_definition
    (211) external_definition -> . declaration
    (212) function_definition -> . declarator function_body
    (213) function_definition -> . declaration_specifiers declarator function_body
    (75) declaration -> . declaration_specifiers 
    (76) declaration -> . declaration_specifiers init_declarator_list 
    (124) declarator -> . declarator2
    (125) declarator -> . pointer declarator2
    (77) declaration_specifiers -> . storage_class_specifier
    (78) declaration_specifiers -> . storage_class_specifier declaration_specifiers
    (79) declaration_specifiers -> . type_specifier
    (80) declaration_specifiers -> . type_specifier declaration_specifiers
    (126) declarator2 -> . identifier
    (127) declarator2 -> . ( declarator )
    (128) declarator2 -> . declarator2 [ ]
    (129) declarator2 -> . declarator2 [ constant_expr ]
    (130) declarator2 -> . declarator2 ( )
    (131) declarator2 -> . declarator2 ( parameter_type_list )
    (132) declarator2 -> . declarator2 ( parameter_identifier_list )
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (85) storage_class_specifier -> . TYPEDEF
    (86) storage_class_specifier -> . EXTERN
    (87) storage_class_specifier -> . STATIC
    (88) storage_class_specifier -> . AUTO
    (89) storage_class_specifier -> . REGISTER
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (216) identifier -> . IDENTIFIER
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    $end            reduce using rule 207 (code -> file .)
    (               shift and go to state 16
    *               shift and go to state 17
    TYPEDEF         shift and go to state 22
    EXTERN          shift and go to state 12
    STATIC          shift and go to state 10
    AUTO            shift and go to state 23
    REGISTER        shift and go to state 36
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    IDENTIFIER      shift and go to state 21
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    external_definition            shift and go to state 43
    storage_class_specifier        shift and go to state 38
    struct_or_union_specifier      shift and go to state 4
    declarator2                    shift and go to state 7
    pointer                        shift and go to state 14
    type_specifier                 shift and go to state 15
    struct_or_union                shift and go to state 6
    declaration_specifiers         shift and go to state 25
    declaration                    shift and go to state 26
    function_definition            shift and go to state 27
    enum_specifier                 shift and go to state 33
    declarator                     shift and go to state 35
    identifier                     shift and go to state 37

state 12

    (86) storage_class_specifier -> EXTERN .

    TYPEDEF         reduce using rule 86 (storage_class_specifier -> EXTERN .)
    EXTERN          reduce using rule 86 (storage_class_specifier -> EXTERN .)
    STATIC          reduce using rule 86 (storage_class_specifier -> EXTERN .)
    AUTO            reduce using rule 86 (storage_class_specifier -> EXTERN .)
    REGISTER        reduce using rule 86 (storage_class_specifier -> EXTERN .)
    CHAR            reduce using rule 86 (storage_class_specifier -> EXTERN .)
    SHORT           reduce using rule 86 (storage_class_specifier -> EXTERN .)
    INT             reduce using rule 86 (storage_class_specifier -> EXTERN .)
    LONG            reduce using rule 86 (storage_class_specifier -> EXTERN .)
    SIGNED          reduce using rule 86 (storage_class_specifier -> EXTERN .)
    UNSIGNED        reduce using rule 86 (storage_class_specifier -> EXTERN .)
    FLOAT           reduce using rule 86 (storage_class_specifier -> EXTERN .)
    DOUBLE          reduce using rule 86 (storage_class_specifier -> EXTERN .)
    CONST           reduce using rule 86 (storage_class_specifier -> EXTERN .)
    VOLATILE        reduce using rule 86 (storage_class_specifier -> EXTERN .)
    VOID            reduce using rule 86 (storage_class_specifier -> EXTERN .)
    TYPE_NAME       reduce using rule 86 (storage_class_specifier -> EXTERN .)
    ENUM            reduce using rule 86 (storage_class_specifier -> EXTERN .)
    STRUCT          reduce using rule 86 (storage_class_specifier -> EXTERN .)
    UNION           reduce using rule 86 (storage_class_specifier -> EXTERN .)
                    reduce using rule 86 (storage_class_specifier -> EXTERN .)
    (               reduce using rule 86 (storage_class_specifier -> EXTERN .)
    *               reduce using rule 86 (storage_class_specifier -> EXTERN .)
    IDENTIFIER      reduce using rule 86 (storage_class_specifier -> EXTERN .)



state 13

    (103) type_specifier -> TYPE_NAME .

    CHAR            reduce using rule 103 (type_specifier -> TYPE_NAME .)
    SHORT           reduce using rule 103 (type_specifier -> TYPE_NAME .)
    INT             reduce using rule 103 (type_specifier -> TYPE_NAME .)
    LONG            reduce using rule 103 (type_specifier -> TYPE_NAME .)
    SIGNED          reduce using rule 103 (type_specifier -> TYPE_NAME .)
    UNSIGNED        reduce using rule 103 (type_specifier -> TYPE_NAME .)
    FLOAT           reduce using rule 103 (type_specifier -> TYPE_NAME .)
    DOUBLE          reduce using rule 103 (type_specifier -> TYPE_NAME .)
    CONST           reduce using rule 103 (type_specifier -> TYPE_NAME .)
    VOLATILE        reduce using rule 103 (type_specifier -> TYPE_NAME .)
    VOID            reduce using rule 103 (type_specifier -> TYPE_NAME .)
    TYPE_NAME       reduce using rule 103 (type_specifier -> TYPE_NAME .)
    (               reduce using rule 103 (type_specifier -> TYPE_NAME .)
    *               reduce using rule 103 (type_specifier -> TYPE_NAME .)
    ENUM            reduce using rule 103 (type_specifier -> TYPE_NAME .)
    [               reduce using rule 103 (type_specifier -> TYPE_NAME .)
    IDENTIFIER      reduce using rule 103 (type_specifier -> TYPE_NAME .)
    STRUCT          reduce using rule 103 (type_specifier -> TYPE_NAME .)
    UNION           reduce using rule 103 (type_specifier -> TYPE_NAME .)
    ,               reduce using rule 103 (type_specifier -> TYPE_NAME .)
    )               reduce using rule 103 (type_specifier -> TYPE_NAME .)
    :               reduce using rule 103 (type_specifier -> TYPE_NAME .)
    TYPEDEF         reduce using rule 103 (type_specifier -> TYPE_NAME .)
    EXTERN          reduce using rule 103 (type_specifier -> TYPE_NAME .)
    STATIC          reduce using rule 103 (type_specifier -> TYPE_NAME .)
    AUTO            reduce using rule 103 (type_specifier -> TYPE_NAME .)
    REGISTER        reduce using rule 103 (type_specifier -> TYPE_NAME .)
                    reduce using rule 103 (type_specifier -> TYPE_NAME .)



state 14

    (125) declarator -> pointer . declarator2
    (126) declarator2 -> . identifier
    (127) declarator2 -> . ( declarator )
    (128) declarator2 -> . declarator2 [ ]
    (129) declarator2 -> . declarator2 [ constant_expr ]
    (130) declarator2 -> . declarator2 ( )
    (131) declarator2 -> . declarator2 ( parameter_type_list )
    (132) declarator2 -> . declarator2 ( parameter_identifier_list )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 16
    IDENTIFIER      shift and go to state 21


    declarator2                    shift and go to state 44
    identifier                     shift and go to state 37

state 15

    (79) declaration_specifiers -> type_specifier .
    (80) declaration_specifiers -> type_specifier . declaration_specifiers
    (77) declaration_specifiers -> . storage_class_specifier
    (78) declaration_specifiers -> . storage_class_specifier declaration_specifiers
    (79) declaration_specifiers -> . type_specifier
    (80) declaration_specifiers -> . type_specifier declaration_specifiers
    (85) storage_class_specifier -> . TYPEDEF
    (86) storage_class_specifier -> . EXTERN
    (87) storage_class_specifier -> . STATIC
    (88) storage_class_specifier -> . AUTO
    (89) storage_class_specifier -> . REGISTER
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

                    reduce using rule 79 (declaration_specifiers -> type_specifier .)
    (               reduce using rule 79 (declaration_specifiers -> type_specifier .)
    *               reduce using rule 79 (declaration_specifiers -> type_specifier .)
    IDENTIFIER      reduce using rule 79 (declaration_specifiers -> type_specifier .)
    TYPEDEF         shift and go to state 22
    EXTERN          shift and go to state 12
    STATIC          shift and go to state 10
    AUTO            shift and go to state 23
    REGISTER        shift and go to state 36
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    storage_class_specifier        shift and go to state 38
    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 15
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    declaration_specifiers         shift and go to state 45

state 16

    (127) declarator2 -> ( . declarator )
    (124) declarator -> . declarator2
    (125) declarator -> . pointer declarator2
    (126) declarator2 -> . identifier
    (127) declarator2 -> . ( declarator )
    (128) declarator2 -> . declarator2 [ ]
    (129) declarator2 -> . declarator2 [ constant_expr ]
    (130) declarator2 -> . declarator2 ( )
    (131) declarator2 -> . declarator2 ( parameter_type_list )
    (132) declarator2 -> . declarator2 ( parameter_identifier_list )
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 16
    *               shift and go to state 17
    IDENTIFIER      shift and go to state 21


    declarator2                    shift and go to state 7
    declarator                     shift and go to state 46
    identifier                     shift and go to state 37
    pointer                        shift and go to state 14

state 17

    (133) pointer -> * .
    (134) pointer -> * . type_specifier_list
    (135) pointer -> * . pointer
    (136) pointer -> * . type_specifier_list pointer
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    (               reduce using rule 133 (pointer -> * .)
    IDENTIFIER      reduce using rule 133 (pointer -> * .)
    [               reduce using rule 133 (pointer -> * .)
    ,               reduce using rule 133 (pointer -> * .)
    )               reduce using rule 133 (pointer -> * .)
    *               shift and go to state 17
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 48
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    type_specifier_list            shift and go to state 49
    pointer                        shift and go to state 47

state 18

    (95) type_specifier -> UNSIGNED .

    CHAR            reduce using rule 95 (type_specifier -> UNSIGNED .)
    SHORT           reduce using rule 95 (type_specifier -> UNSIGNED .)
    INT             reduce using rule 95 (type_specifier -> UNSIGNED .)
    LONG            reduce using rule 95 (type_specifier -> UNSIGNED .)
    SIGNED          reduce using rule 95 (type_specifier -> UNSIGNED .)
    UNSIGNED        reduce using rule 95 (type_specifier -> UNSIGNED .)
    FLOAT           reduce using rule 95 (type_specifier -> UNSIGNED .)
    DOUBLE          reduce using rule 95 (type_specifier -> UNSIGNED .)
    CONST           reduce using rule 95 (type_specifier -> UNSIGNED .)
    VOLATILE        reduce using rule 95 (type_specifier -> UNSIGNED .)
    VOID            reduce using rule 95 (type_specifier -> UNSIGNED .)
    TYPE_NAME       reduce using rule 95 (type_specifier -> UNSIGNED .)
    (               reduce using rule 95 (type_specifier -> UNSIGNED .)
    *               reduce using rule 95 (type_specifier -> UNSIGNED .)
    ENUM            reduce using rule 95 (type_specifier -> UNSIGNED .)
    [               reduce using rule 95 (type_specifier -> UNSIGNED .)
    IDENTIFIER      reduce using rule 95 (type_specifier -> UNSIGNED .)
    STRUCT          reduce using rule 95 (type_specifier -> UNSIGNED .)
    UNION           reduce using rule 95 (type_specifier -> UNSIGNED .)
    ,               reduce using rule 95 (type_specifier -> UNSIGNED .)
    )               reduce using rule 95 (type_specifier -> UNSIGNED .)
    :               reduce using rule 95 (type_specifier -> UNSIGNED .)
    TYPEDEF         reduce using rule 95 (type_specifier -> UNSIGNED .)
    EXTERN          reduce using rule 95 (type_specifier -> UNSIGNED .)
    STATIC          reduce using rule 95 (type_specifier -> UNSIGNED .)
    AUTO            reduce using rule 95 (type_specifier -> UNSIGNED .)
    REGISTER        reduce using rule 95 (type_specifier -> UNSIGNED .)
                    reduce using rule 95 (type_specifier -> UNSIGNED .)



state 19

    (93) type_specifier -> LONG .

    CHAR            reduce using rule 93 (type_specifier -> LONG .)
    SHORT           reduce using rule 93 (type_specifier -> LONG .)
    INT             reduce using rule 93 (type_specifier -> LONG .)
    LONG            reduce using rule 93 (type_specifier -> LONG .)
    SIGNED          reduce using rule 93 (type_specifier -> LONG .)
    UNSIGNED        reduce using rule 93 (type_specifier -> LONG .)
    FLOAT           reduce using rule 93 (type_specifier -> LONG .)
    DOUBLE          reduce using rule 93 (type_specifier -> LONG .)
    CONST           reduce using rule 93 (type_specifier -> LONG .)
    VOLATILE        reduce using rule 93 (type_specifier -> LONG .)
    VOID            reduce using rule 93 (type_specifier -> LONG .)
    TYPE_NAME       reduce using rule 93 (type_specifier -> LONG .)
    (               reduce using rule 93 (type_specifier -> LONG .)
    *               reduce using rule 93 (type_specifier -> LONG .)
    ENUM            reduce using rule 93 (type_specifier -> LONG .)
    [               reduce using rule 93 (type_specifier -> LONG .)
    IDENTIFIER      reduce using rule 93 (type_specifier -> LONG .)
    STRUCT          reduce using rule 93 (type_specifier -> LONG .)
    UNION           reduce using rule 93 (type_specifier -> LONG .)
    ,               reduce using rule 93 (type_specifier -> LONG .)
    )               reduce using rule 93 (type_specifier -> LONG .)
    :               reduce using rule 93 (type_specifier -> LONG .)
    TYPEDEF         reduce using rule 93 (type_specifier -> LONG .)
    EXTERN          reduce using rule 93 (type_specifier -> LONG .)
    STATIC          reduce using rule 93 (type_specifier -> LONG .)
    AUTO            reduce using rule 93 (type_specifier -> LONG .)
    REGISTER        reduce using rule 93 (type_specifier -> LONG .)
                    reduce using rule 93 (type_specifier -> LONG .)



state 20

    (108) struct_or_union -> UNION .

    {               reduce using rule 108 (struct_or_union -> UNION .)
    IDENTIFIER      reduce using rule 108 (struct_or_union -> UNION .)



state 21

    (216) identifier -> IDENTIFIER .

    ,               reduce using rule 216 (identifier -> IDENTIFIER .)
    )               reduce using rule 216 (identifier -> IDENTIFIER .)
    :               reduce using rule 216 (identifier -> IDENTIFIER .)
    [               reduce using rule 216 (identifier -> IDENTIFIER .)
    (               reduce using rule 216 (identifier -> IDENTIFIER .)
    .               reduce using rule 216 (identifier -> IDENTIFIER .)
    PTR_OP          reduce using rule 216 (identifier -> IDENTIFIER .)
    INC_OP          reduce using rule 216 (identifier -> IDENTIFIER .)
    DEC_OP          reduce using rule 216 (identifier -> IDENTIFIER .)
    =               reduce using rule 216 (identifier -> IDENTIFIER .)
    MUL_ASSIGN      reduce using rule 216 (identifier -> IDENTIFIER .)
    DIV_ASSIGN      reduce using rule 216 (identifier -> IDENTIFIER .)
    MOD_ASSIGN      reduce using rule 216 (identifier -> IDENTIFIER .)
    ADD_ASSIGN      reduce using rule 216 (identifier -> IDENTIFIER .)
    SUB_ASSIGN      reduce using rule 216 (identifier -> IDENTIFIER .)
    LEFT_ASSIGN     reduce using rule 216 (identifier -> IDENTIFIER .)
    RIGHT_ASSIGN    reduce using rule 216 (identifier -> IDENTIFIER .)
    AND_ASSIGN      reduce using rule 216 (identifier -> IDENTIFIER .)
    XOR_ASSIGN      reduce using rule 216 (identifier -> IDENTIFIER .)
    OR_ASSIGN       reduce using rule 216 (identifier -> IDENTIFIER .)
    *               reduce using rule 216 (identifier -> IDENTIFIER .)
    /               reduce using rule 216 (identifier -> IDENTIFIER .)
    %               reduce using rule 216 (identifier -> IDENTIFIER .)
    +               reduce using rule 216 (identifier -> IDENTIFIER .)
    -               reduce using rule 216 (identifier -> IDENTIFIER .)
    LEFT_OP         reduce using rule 216 (identifier -> IDENTIFIER .)
    RIGHT_OP        reduce using rule 216 (identifier -> IDENTIFIER .)
    <               reduce using rule 216 (identifier -> IDENTIFIER .)
    >               reduce using rule 216 (identifier -> IDENTIFIER .)
    LE_OP           reduce using rule 216 (identifier -> IDENTIFIER .)
    GE_OP           reduce using rule 216 (identifier -> IDENTIFIER .)
    EQ_OP           reduce using rule 216 (identifier -> IDENTIFIER .)
    NE_OP           reduce using rule 216 (identifier -> IDENTIFIER .)
    &               reduce using rule 216 (identifier -> IDENTIFIER .)
    ^               reduce using rule 216 (identifier -> IDENTIFIER .)
    |               reduce using rule 216 (identifier -> IDENTIFIER .)
    AND_OP          reduce using rule 216 (identifier -> IDENTIFIER .)
    ?               reduce using rule 216 (identifier -> IDENTIFIER .)
    OR_OP           reduce using rule 216 (identifier -> IDENTIFIER .)
    ;               reduce using rule 216 (identifier -> IDENTIFIER .)
    ]               reduce using rule 216 (identifier -> IDENTIFIER .)
                    reduce using rule 216 (identifier -> IDENTIFIER .)
    }               reduce using rule 216 (identifier -> IDENTIFIER .)
    {               reduce using rule 216 (identifier -> IDENTIFIER .)
    TYPEDEF         reduce using rule 216 (identifier -> IDENTIFIER .)
    EXTERN          reduce using rule 216 (identifier -> IDENTIFIER .)
    STATIC          reduce using rule 216 (identifier -> IDENTIFIER .)
    AUTO            reduce using rule 216 (identifier -> IDENTIFIER .)
    REGISTER        reduce using rule 216 (identifier -> IDENTIFIER .)
    CHAR            reduce using rule 216 (identifier -> IDENTIFIER .)
    SHORT           reduce using rule 216 (identifier -> IDENTIFIER .)
    INT             reduce using rule 216 (identifier -> IDENTIFIER .)
    LONG            reduce using rule 216 (identifier -> IDENTIFIER .)
    SIGNED          reduce using rule 216 (identifier -> IDENTIFIER .)
    UNSIGNED        reduce using rule 216 (identifier -> IDENTIFIER .)
    FLOAT           reduce using rule 216 (identifier -> IDENTIFIER .)
    DOUBLE          reduce using rule 216 (identifier -> IDENTIFIER .)
    CONST           reduce using rule 216 (identifier -> IDENTIFIER .)
    VOLATILE        reduce using rule 216 (identifier -> IDENTIFIER .)
    VOID            reduce using rule 216 (identifier -> IDENTIFIER .)
    TYPE_NAME       reduce using rule 216 (identifier -> IDENTIFIER .)
    ENUM            reduce using rule 216 (identifier -> IDENTIFIER .)
    STRUCT          reduce using rule 216 (identifier -> IDENTIFIER .)
    UNION           reduce using rule 216 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 216 (identifier -> IDENTIFIER .)



state 22

    (85) storage_class_specifier -> TYPEDEF .

    TYPEDEF         reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    EXTERN          reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    STATIC          reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    AUTO            reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    REGISTER        reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    CHAR            reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    SHORT           reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    INT             reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    LONG            reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    SIGNED          reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    UNSIGNED        reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    FLOAT           reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    DOUBLE          reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    CONST           reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    VOLATILE        reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    VOID            reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    TYPE_NAME       reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    ENUM            reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    STRUCT          reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    UNION           reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
                    reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    (               reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    *               reduce using rule 85 (storage_class_specifier -> TYPEDEF .)
    IDENTIFIER      reduce using rule 85 (storage_class_specifier -> TYPEDEF .)



state 23

    (88) storage_class_specifier -> AUTO .

    TYPEDEF         reduce using rule 88 (storage_class_specifier -> AUTO .)
    EXTERN          reduce using rule 88 (storage_class_specifier -> AUTO .)
    STATIC          reduce using rule 88 (storage_class_specifier -> AUTO .)
    AUTO            reduce using rule 88 (storage_class_specifier -> AUTO .)
    REGISTER        reduce using rule 88 (storage_class_specifier -> AUTO .)
    CHAR            reduce using rule 88 (storage_class_specifier -> AUTO .)
    SHORT           reduce using rule 88 (storage_class_specifier -> AUTO .)
    INT             reduce using rule 88 (storage_class_specifier -> AUTO .)
    LONG            reduce using rule 88 (storage_class_specifier -> AUTO .)
    SIGNED          reduce using rule 88 (storage_class_specifier -> AUTO .)
    UNSIGNED        reduce using rule 88 (storage_class_specifier -> AUTO .)
    FLOAT           reduce using rule 88 (storage_class_specifier -> AUTO .)
    DOUBLE          reduce using rule 88 (storage_class_specifier -> AUTO .)
    CONST           reduce using rule 88 (storage_class_specifier -> AUTO .)
    VOLATILE        reduce using rule 88 (storage_class_specifier -> AUTO .)
    VOID            reduce using rule 88 (storage_class_specifier -> AUTO .)
    TYPE_NAME       reduce using rule 88 (storage_class_specifier -> AUTO .)
    ENUM            reduce using rule 88 (storage_class_specifier -> AUTO .)
    STRUCT          reduce using rule 88 (storage_class_specifier -> AUTO .)
    UNION           reduce using rule 88 (storage_class_specifier -> AUTO .)
                    reduce using rule 88 (storage_class_specifier -> AUTO .)
    (               reduce using rule 88 (storage_class_specifier -> AUTO .)
    *               reduce using rule 88 (storage_class_specifier -> AUTO .)
    IDENTIFIER      reduce using rule 88 (storage_class_specifier -> AUTO .)



state 24

    (117) enum_specifier -> ENUM . { enumerator_list }
    (118) enum_specifier -> ENUM . identifier { enumerator_list }
    (119) enum_specifier -> ENUM . identifier
    (216) identifier -> . IDENTIFIER

    {               shift and go to state 51
    IDENTIFIER      shift and go to state 21


    identifier                     shift and go to state 50

state 25

    (213) function_definition -> declaration_specifiers . declarator function_body
    (75) declaration -> declaration_specifiers . 
    (76) declaration -> declaration_specifiers . init_declarator_list 
    (124) declarator -> . declarator2
    (125) declarator -> . pointer declarator2
    (81) init_declarator_list -> . init_declarator
    (82) init_declarator_list -> . init_declarator_list , init_declarator
    (126) declarator2 -> . identifier
    (127) declarator2 -> . ( declarator )
    (128) declarator2 -> . declarator2 [ ]
    (129) declarator2 -> . declarator2 [ constant_expr ]
    (130) declarator2 -> . declarator2 ( )
    (131) declarator2 -> . declarator2 ( parameter_type_list )
    (132) declarator2 -> . declarator2 ( parameter_identifier_list )
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (83) init_declarator -> . declarator
    (84) init_declarator -> . declarator = initializer
    (216) identifier -> . IDENTIFIER

                    shift and go to state 52
    (               shift and go to state 16
    *               shift and go to state 17
    IDENTIFIER      shift and go to state 21


    init_declarator                shift and go to state 55
    declarator2                    shift and go to state 7
    init_declarator_list           shift and go to state 54
    declarator                     shift and go to state 53
    identifier                     shift and go to state 37
    pointer                        shift and go to state 14

state 26

    (211) external_definition -> declaration .

    (               reduce using rule 211 (external_definition -> declaration .)
    *               reduce using rule 211 (external_definition -> declaration .)
    TYPEDEF         reduce using rule 211 (external_definition -> declaration .)
    EXTERN          reduce using rule 211 (external_definition -> declaration .)
    STATIC          reduce using rule 211 (external_definition -> declaration .)
    AUTO            reduce using rule 211 (external_definition -> declaration .)
    REGISTER        reduce using rule 211 (external_definition -> declaration .)
    CHAR            reduce using rule 211 (external_definition -> declaration .)
    SHORT           reduce using rule 211 (external_definition -> declaration .)
    INT             reduce using rule 211 (external_definition -> declaration .)
    LONG            reduce using rule 211 (external_definition -> declaration .)
    SIGNED          reduce using rule 211 (external_definition -> declaration .)
    UNSIGNED        reduce using rule 211 (external_definition -> declaration .)
    FLOAT           reduce using rule 211 (external_definition -> declaration .)
    DOUBLE          reduce using rule 211 (external_definition -> declaration .)
    CONST           reduce using rule 211 (external_definition -> declaration .)
    VOLATILE        reduce using rule 211 (external_definition -> declaration .)
    VOID            reduce using rule 211 (external_definition -> declaration .)
    TYPE_NAME       reduce using rule 211 (external_definition -> declaration .)
    IDENTIFIER      reduce using rule 211 (external_definition -> declaration .)
    ENUM            reduce using rule 211 (external_definition -> declaration .)
    STRUCT          reduce using rule 211 (external_definition -> declaration .)
    UNION           reduce using rule 211 (external_definition -> declaration .)
    $end            reduce using rule 211 (external_definition -> declaration .)



state 27

    (210) external_definition -> function_definition .

    (               reduce using rule 210 (external_definition -> function_definition .)
    *               reduce using rule 210 (external_definition -> function_definition .)
    TYPEDEF         reduce using rule 210 (external_definition -> function_definition .)
    EXTERN          reduce using rule 210 (external_definition -> function_definition .)
    STATIC          reduce using rule 210 (external_definition -> function_definition .)
    AUTO            reduce using rule 210 (external_definition -> function_definition .)
    REGISTER        reduce using rule 210 (external_definition -> function_definition .)
    CHAR            reduce using rule 210 (external_definition -> function_definition .)
    SHORT           reduce using rule 210 (external_definition -> function_definition .)
    INT             reduce using rule 210 (external_definition -> function_definition .)
    LONG            reduce using rule 210 (external_definition -> function_definition .)
    SIGNED          reduce using rule 210 (external_definition -> function_definition .)
    UNSIGNED        reduce using rule 210 (external_definition -> function_definition .)
    FLOAT           reduce using rule 210 (external_definition -> function_definition .)
    DOUBLE          reduce using rule 210 (external_definition -> function_definition .)
    CONST           reduce using rule 210 (external_definition -> function_definition .)
    VOLATILE        reduce using rule 210 (external_definition -> function_definition .)
    VOID            reduce using rule 210 (external_definition -> function_definition .)
    TYPE_NAME       reduce using rule 210 (external_definition -> function_definition .)
    IDENTIFIER      reduce using rule 210 (external_definition -> function_definition .)
    ENUM            reduce using rule 210 (external_definition -> function_definition .)
    STRUCT          reduce using rule 210 (external_definition -> function_definition .)
    UNION           reduce using rule 210 (external_definition -> function_definition .)
    $end            reduce using rule 210 (external_definition -> function_definition .)



state 28

    (107) struct_or_union -> STRUCT .

    {               reduce using rule 107 (struct_or_union -> STRUCT .)
    IDENTIFIER      reduce using rule 107 (struct_or_union -> STRUCT .)



state 29

    (92) type_specifier -> INT .

    CHAR            reduce using rule 92 (type_specifier -> INT .)
    SHORT           reduce using rule 92 (type_specifier -> INT .)
    INT             reduce using rule 92 (type_specifier -> INT .)
    LONG            reduce using rule 92 (type_specifier -> INT .)
    SIGNED          reduce using rule 92 (type_specifier -> INT .)
    UNSIGNED        reduce using rule 92 (type_specifier -> INT .)
    FLOAT           reduce using rule 92 (type_specifier -> INT .)
    DOUBLE          reduce using rule 92 (type_specifier -> INT .)
    CONST           reduce using rule 92 (type_specifier -> INT .)
    VOLATILE        reduce using rule 92 (type_specifier -> INT .)
    VOID            reduce using rule 92 (type_specifier -> INT .)
    TYPE_NAME       reduce using rule 92 (type_specifier -> INT .)
    (               reduce using rule 92 (type_specifier -> INT .)
    *               reduce using rule 92 (type_specifier -> INT .)
    ENUM            reduce using rule 92 (type_specifier -> INT .)
    [               reduce using rule 92 (type_specifier -> INT .)
    IDENTIFIER      reduce using rule 92 (type_specifier -> INT .)
    STRUCT          reduce using rule 92 (type_specifier -> INT .)
    UNION           reduce using rule 92 (type_specifier -> INT .)
    ,               reduce using rule 92 (type_specifier -> INT .)
    )               reduce using rule 92 (type_specifier -> INT .)
    :               reduce using rule 92 (type_specifier -> INT .)
    TYPEDEF         reduce using rule 92 (type_specifier -> INT .)
    EXTERN          reduce using rule 92 (type_specifier -> INT .)
    STATIC          reduce using rule 92 (type_specifier -> INT .)
    AUTO            reduce using rule 92 (type_specifier -> INT .)
    REGISTER        reduce using rule 92 (type_specifier -> INT .)
                    reduce using rule 92 (type_specifier -> INT .)



state 30

    (97) type_specifier -> DOUBLE .

    CHAR            reduce using rule 97 (type_specifier -> DOUBLE .)
    SHORT           reduce using rule 97 (type_specifier -> DOUBLE .)
    INT             reduce using rule 97 (type_specifier -> DOUBLE .)
    LONG            reduce using rule 97 (type_specifier -> DOUBLE .)
    SIGNED          reduce using rule 97 (type_specifier -> DOUBLE .)
    UNSIGNED        reduce using rule 97 (type_specifier -> DOUBLE .)
    FLOAT           reduce using rule 97 (type_specifier -> DOUBLE .)
    DOUBLE          reduce using rule 97 (type_specifier -> DOUBLE .)
    CONST           reduce using rule 97 (type_specifier -> DOUBLE .)
    VOLATILE        reduce using rule 97 (type_specifier -> DOUBLE .)
    VOID            reduce using rule 97 (type_specifier -> DOUBLE .)
    TYPE_NAME       reduce using rule 97 (type_specifier -> DOUBLE .)
    (               reduce using rule 97 (type_specifier -> DOUBLE .)
    *               reduce using rule 97 (type_specifier -> DOUBLE .)
    ENUM            reduce using rule 97 (type_specifier -> DOUBLE .)
    [               reduce using rule 97 (type_specifier -> DOUBLE .)
    IDENTIFIER      reduce using rule 97 (type_specifier -> DOUBLE .)
    STRUCT          reduce using rule 97 (type_specifier -> DOUBLE .)
    UNION           reduce using rule 97 (type_specifier -> DOUBLE .)
    ,               reduce using rule 97 (type_specifier -> DOUBLE .)
    )               reduce using rule 97 (type_specifier -> DOUBLE .)
    :               reduce using rule 97 (type_specifier -> DOUBLE .)
    TYPEDEF         reduce using rule 97 (type_specifier -> DOUBLE .)
    EXTERN          reduce using rule 97 (type_specifier -> DOUBLE .)
    STATIC          reduce using rule 97 (type_specifier -> DOUBLE .)
    AUTO            reduce using rule 97 (type_specifier -> DOUBLE .)
    REGISTER        reduce using rule 97 (type_specifier -> DOUBLE .)
                    reduce using rule 97 (type_specifier -> DOUBLE .)



state 31

    (96) type_specifier -> FLOAT .

    CHAR            reduce using rule 96 (type_specifier -> FLOAT .)
    SHORT           reduce using rule 96 (type_specifier -> FLOAT .)
    INT             reduce using rule 96 (type_specifier -> FLOAT .)
    LONG            reduce using rule 96 (type_specifier -> FLOAT .)
    SIGNED          reduce using rule 96 (type_specifier -> FLOAT .)
    UNSIGNED        reduce using rule 96 (type_specifier -> FLOAT .)
    FLOAT           reduce using rule 96 (type_specifier -> FLOAT .)
    DOUBLE          reduce using rule 96 (type_specifier -> FLOAT .)
    CONST           reduce using rule 96 (type_specifier -> FLOAT .)
    VOLATILE        reduce using rule 96 (type_specifier -> FLOAT .)
    VOID            reduce using rule 96 (type_specifier -> FLOAT .)
    TYPE_NAME       reduce using rule 96 (type_specifier -> FLOAT .)
    (               reduce using rule 96 (type_specifier -> FLOAT .)
    *               reduce using rule 96 (type_specifier -> FLOAT .)
    ENUM            reduce using rule 96 (type_specifier -> FLOAT .)
    [               reduce using rule 96 (type_specifier -> FLOAT .)
    IDENTIFIER      reduce using rule 96 (type_specifier -> FLOAT .)
    STRUCT          reduce using rule 96 (type_specifier -> FLOAT .)
    UNION           reduce using rule 96 (type_specifier -> FLOAT .)
    ,               reduce using rule 96 (type_specifier -> FLOAT .)
    )               reduce using rule 96 (type_specifier -> FLOAT .)
    :               reduce using rule 96 (type_specifier -> FLOAT .)
    TYPEDEF         reduce using rule 96 (type_specifier -> FLOAT .)
    EXTERN          reduce using rule 96 (type_specifier -> FLOAT .)
    STATIC          reduce using rule 96 (type_specifier -> FLOAT .)
    AUTO            reduce using rule 96 (type_specifier -> FLOAT .)
    REGISTER        reduce using rule 96 (type_specifier -> FLOAT .)
                    reduce using rule 96 (type_specifier -> FLOAT .)



state 32

    (94) type_specifier -> SIGNED .

    CHAR            reduce using rule 94 (type_specifier -> SIGNED .)
    SHORT           reduce using rule 94 (type_specifier -> SIGNED .)
    INT             reduce using rule 94 (type_specifier -> SIGNED .)
    LONG            reduce using rule 94 (type_specifier -> SIGNED .)
    SIGNED          reduce using rule 94 (type_specifier -> SIGNED .)
    UNSIGNED        reduce using rule 94 (type_specifier -> SIGNED .)
    FLOAT           reduce using rule 94 (type_specifier -> SIGNED .)
    DOUBLE          reduce using rule 94 (type_specifier -> SIGNED .)
    CONST           reduce using rule 94 (type_specifier -> SIGNED .)
    VOLATILE        reduce using rule 94 (type_specifier -> SIGNED .)
    VOID            reduce using rule 94 (type_specifier -> SIGNED .)
    TYPE_NAME       reduce using rule 94 (type_specifier -> SIGNED .)
    (               reduce using rule 94 (type_specifier -> SIGNED .)
    *               reduce using rule 94 (type_specifier -> SIGNED .)
    ENUM            reduce using rule 94 (type_specifier -> SIGNED .)
    [               reduce using rule 94 (type_specifier -> SIGNED .)
    IDENTIFIER      reduce using rule 94 (type_specifier -> SIGNED .)
    STRUCT          reduce using rule 94 (type_specifier -> SIGNED .)
    UNION           reduce using rule 94 (type_specifier -> SIGNED .)
    ,               reduce using rule 94 (type_specifier -> SIGNED .)
    )               reduce using rule 94 (type_specifier -> SIGNED .)
    :               reduce using rule 94 (type_specifier -> SIGNED .)
    TYPEDEF         reduce using rule 94 (type_specifier -> SIGNED .)
    EXTERN          reduce using rule 94 (type_specifier -> SIGNED .)
    STATIC          reduce using rule 94 (type_specifier -> SIGNED .)
    AUTO            reduce using rule 94 (type_specifier -> SIGNED .)
    REGISTER        reduce using rule 94 (type_specifier -> SIGNED .)
                    reduce using rule 94 (type_specifier -> SIGNED .)



state 33

    (102) type_specifier -> enum_specifier .

    CHAR            reduce using rule 102 (type_specifier -> enum_specifier .)
    SHORT           reduce using rule 102 (type_specifier -> enum_specifier .)
    INT             reduce using rule 102 (type_specifier -> enum_specifier .)
    LONG            reduce using rule 102 (type_specifier -> enum_specifier .)
    SIGNED          reduce using rule 102 (type_specifier -> enum_specifier .)
    UNSIGNED        reduce using rule 102 (type_specifier -> enum_specifier .)
    FLOAT           reduce using rule 102 (type_specifier -> enum_specifier .)
    DOUBLE          reduce using rule 102 (type_specifier -> enum_specifier .)
    CONST           reduce using rule 102 (type_specifier -> enum_specifier .)
    VOLATILE        reduce using rule 102 (type_specifier -> enum_specifier .)
    VOID            reduce using rule 102 (type_specifier -> enum_specifier .)
    TYPE_NAME       reduce using rule 102 (type_specifier -> enum_specifier .)
    (               reduce using rule 102 (type_specifier -> enum_specifier .)
    *               reduce using rule 102 (type_specifier -> enum_specifier .)
    ENUM            reduce using rule 102 (type_specifier -> enum_specifier .)
    [               reduce using rule 102 (type_specifier -> enum_specifier .)
    IDENTIFIER      reduce using rule 102 (type_specifier -> enum_specifier .)
    STRUCT          reduce using rule 102 (type_specifier -> enum_specifier .)
    UNION           reduce using rule 102 (type_specifier -> enum_specifier .)
    ,               reduce using rule 102 (type_specifier -> enum_specifier .)
    )               reduce using rule 102 (type_specifier -> enum_specifier .)
    :               reduce using rule 102 (type_specifier -> enum_specifier .)
    TYPEDEF         reduce using rule 102 (type_specifier -> enum_specifier .)
    EXTERN          reduce using rule 102 (type_specifier -> enum_specifier .)
    STATIC          reduce using rule 102 (type_specifier -> enum_specifier .)
    AUTO            reduce using rule 102 (type_specifier -> enum_specifier .)
    REGISTER        reduce using rule 102 (type_specifier -> enum_specifier .)
                    reduce using rule 102 (type_specifier -> enum_specifier .)



state 34

    (99) type_specifier -> VOLATILE .

    CHAR            reduce using rule 99 (type_specifier -> VOLATILE .)
    SHORT           reduce using rule 99 (type_specifier -> VOLATILE .)
    INT             reduce using rule 99 (type_specifier -> VOLATILE .)
    LONG            reduce using rule 99 (type_specifier -> VOLATILE .)
    SIGNED          reduce using rule 99 (type_specifier -> VOLATILE .)
    UNSIGNED        reduce using rule 99 (type_specifier -> VOLATILE .)
    FLOAT           reduce using rule 99 (type_specifier -> VOLATILE .)
    DOUBLE          reduce using rule 99 (type_specifier -> VOLATILE .)
    CONST           reduce using rule 99 (type_specifier -> VOLATILE .)
    VOLATILE        reduce using rule 99 (type_specifier -> VOLATILE .)
    VOID            reduce using rule 99 (type_specifier -> VOLATILE .)
    TYPE_NAME       reduce using rule 99 (type_specifier -> VOLATILE .)
    (               reduce using rule 99 (type_specifier -> VOLATILE .)
    *               reduce using rule 99 (type_specifier -> VOLATILE .)
    ENUM            reduce using rule 99 (type_specifier -> VOLATILE .)
    [               reduce using rule 99 (type_specifier -> VOLATILE .)
    IDENTIFIER      reduce using rule 99 (type_specifier -> VOLATILE .)
    STRUCT          reduce using rule 99 (type_specifier -> VOLATILE .)
    UNION           reduce using rule 99 (type_specifier -> VOLATILE .)
    ,               reduce using rule 99 (type_specifier -> VOLATILE .)
    )               reduce using rule 99 (type_specifier -> VOLATILE .)
    :               reduce using rule 99 (type_specifier -> VOLATILE .)
    TYPEDEF         reduce using rule 99 (type_specifier -> VOLATILE .)
    EXTERN          reduce using rule 99 (type_specifier -> VOLATILE .)
    STATIC          reduce using rule 99 (type_specifier -> VOLATILE .)
    AUTO            reduce using rule 99 (type_specifier -> VOLATILE .)
    REGISTER        reduce using rule 99 (type_specifier -> VOLATILE .)
                    reduce using rule 99 (type_specifier -> VOLATILE .)



state 35

    (212) function_definition -> declarator . function_body
    (214) function_body -> . compound_statement
    (215) function_body -> . declaration_list compound_statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (183) declaration_list -> . declaration
    (184) declaration_list -> . declaration_list declaration
    (177) left_bracket -> . {
    (75) declaration -> . declaration_specifiers 
    (76) declaration -> . declaration_specifiers init_declarator_list 
    (77) declaration_specifiers -> . storage_class_specifier
    (78) declaration_specifiers -> . storage_class_specifier declaration_specifiers
    (79) declaration_specifiers -> . type_specifier
    (80) declaration_specifiers -> . type_specifier declaration_specifiers
    (85) storage_class_specifier -> . TYPEDEF
    (86) storage_class_specifier -> . EXTERN
    (87) storage_class_specifier -> . STATIC
    (88) storage_class_specifier -> . AUTO
    (89) storage_class_specifier -> . REGISTER
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    {               shift and go to state 62
    TYPEDEF         shift and go to state 22
    EXTERN          shift and go to state 12
    STATIC          shift and go to state 10
    AUTO            shift and go to state 23
    REGISTER        shift and go to state 36
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    storage_class_specifier        shift and go to state 38
    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 15
    compound_statement             shift and go to state 58
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    declaration                    shift and go to state 60
    declaration_list               shift and go to state 61
    declaration_specifiers         shift and go to state 59
    function_body                  shift and go to state 56
    left_bracket                   shift and go to state 57

state 36

    (89) storage_class_specifier -> REGISTER .

    TYPEDEF         reduce using rule 89 (storage_class_specifier -> REGISTER .)
    EXTERN          reduce using rule 89 (storage_class_specifier -> REGISTER .)
    STATIC          reduce using rule 89 (storage_class_specifier -> REGISTER .)
    AUTO            reduce using rule 89 (storage_class_specifier -> REGISTER .)
    REGISTER        reduce using rule 89 (storage_class_specifier -> REGISTER .)
    CHAR            reduce using rule 89 (storage_class_specifier -> REGISTER .)
    SHORT           reduce using rule 89 (storage_class_specifier -> REGISTER .)
    INT             reduce using rule 89 (storage_class_specifier -> REGISTER .)
    LONG            reduce using rule 89 (storage_class_specifier -> REGISTER .)
    SIGNED          reduce using rule 89 (storage_class_specifier -> REGISTER .)
    UNSIGNED        reduce using rule 89 (storage_class_specifier -> REGISTER .)
    FLOAT           reduce using rule 89 (storage_class_specifier -> REGISTER .)
    DOUBLE          reduce using rule 89 (storage_class_specifier -> REGISTER .)
    CONST           reduce using rule 89 (storage_class_specifier -> REGISTER .)
    VOLATILE        reduce using rule 89 (storage_class_specifier -> REGISTER .)
    VOID            reduce using rule 89 (storage_class_specifier -> REGISTER .)
    TYPE_NAME       reduce using rule 89 (storage_class_specifier -> REGISTER .)
    ENUM            reduce using rule 89 (storage_class_specifier -> REGISTER .)
    STRUCT          reduce using rule 89 (storage_class_specifier -> REGISTER .)
    UNION           reduce using rule 89 (storage_class_specifier -> REGISTER .)
                    reduce using rule 89 (storage_class_specifier -> REGISTER .)
    (               reduce using rule 89 (storage_class_specifier -> REGISTER .)
    *               reduce using rule 89 (storage_class_specifier -> REGISTER .)
    IDENTIFIER      reduce using rule 89 (storage_class_specifier -> REGISTER .)



state 37

    (126) declarator2 -> identifier .

    [               reduce using rule 126 (declarator2 -> identifier .)
    (               reduce using rule 126 (declarator2 -> identifier .)
    {               reduce using rule 126 (declarator2 -> identifier .)
    TYPEDEF         reduce using rule 126 (declarator2 -> identifier .)
    EXTERN          reduce using rule 126 (declarator2 -> identifier .)
    STATIC          reduce using rule 126 (declarator2 -> identifier .)
    AUTO            reduce using rule 126 (declarator2 -> identifier .)
    REGISTER        reduce using rule 126 (declarator2 -> identifier .)
    CHAR            reduce using rule 126 (declarator2 -> identifier .)
    SHORT           reduce using rule 126 (declarator2 -> identifier .)
    INT             reduce using rule 126 (declarator2 -> identifier .)
    LONG            reduce using rule 126 (declarator2 -> identifier .)
    SIGNED          reduce using rule 126 (declarator2 -> identifier .)
    UNSIGNED        reduce using rule 126 (declarator2 -> identifier .)
    FLOAT           reduce using rule 126 (declarator2 -> identifier .)
    DOUBLE          reduce using rule 126 (declarator2 -> identifier .)
    CONST           reduce using rule 126 (declarator2 -> identifier .)
    VOLATILE        reduce using rule 126 (declarator2 -> identifier .)
    VOID            reduce using rule 126 (declarator2 -> identifier .)
    TYPE_NAME       reduce using rule 126 (declarator2 -> identifier .)
    ENUM            reduce using rule 126 (declarator2 -> identifier .)
    STRUCT          reduce using rule 126 (declarator2 -> identifier .)
    UNION           reduce using rule 126 (declarator2 -> identifier .)
    )               reduce using rule 126 (declarator2 -> identifier .)
    =               reduce using rule 126 (declarator2 -> identifier .)
                    reduce using rule 126 (declarator2 -> identifier .)
    ,               reduce using rule 126 (declarator2 -> identifier .)
    :               reduce using rule 126 (declarator2 -> identifier .)



state 38

    (77) declaration_specifiers -> storage_class_specifier .
    (78) declaration_specifiers -> storage_class_specifier . declaration_specifiers
    (77) declaration_specifiers -> . storage_class_specifier
    (78) declaration_specifiers -> . storage_class_specifier declaration_specifiers
    (79) declaration_specifiers -> . type_specifier
    (80) declaration_specifiers -> . type_specifier declaration_specifiers
    (85) storage_class_specifier -> . TYPEDEF
    (86) storage_class_specifier -> . EXTERN
    (87) storage_class_specifier -> . STATIC
    (88) storage_class_specifier -> . AUTO
    (89) storage_class_specifier -> . REGISTER
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

                    reduce using rule 77 (declaration_specifiers -> storage_class_specifier .)
    (               reduce using rule 77 (declaration_specifiers -> storage_class_specifier .)
    *               reduce using rule 77 (declaration_specifiers -> storage_class_specifier .)
    IDENTIFIER      reduce using rule 77 (declaration_specifiers -> storage_class_specifier .)
    TYPEDEF         shift and go to state 22
    EXTERN          shift and go to state 12
    STATIC          shift and go to state 10
    AUTO            shift and go to state 23
    REGISTER        shift and go to state 36
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    storage_class_specifier        shift and go to state 38
    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 15
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    declaration_specifiers         shift and go to state 63

state 39

    (104) struct_or_union_specifier -> struct_or_union identifier . { struct_declaration_list }
    (106) struct_or_union_specifier -> struct_or_union identifier .

    {               shift and go to state 64
    CHAR            reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    SHORT           reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    INT             reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    LONG            reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    SIGNED          reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    UNSIGNED        reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    FLOAT           reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    DOUBLE          reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    CONST           reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    VOLATILE        reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    VOID            reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    TYPE_NAME       reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    (               reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    *               reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    ENUM            reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    [               reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    IDENTIFIER      reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    STRUCT          reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    UNION           reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    ,               reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    )               reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    TYPEDEF         reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    EXTERN          reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    STATIC          reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    AUTO            reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    REGISTER        reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
                    reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)
    :               reduce using rule 106 (struct_or_union_specifier -> struct_or_union identifier .)



state 40

    (105) struct_or_union_specifier -> struct_or_union { . struct_declaration_list }
    (109) struct_declaration_list -> . struct_declaration
    (110) struct_declaration_list -> . struct_declaration_list struct_declaration
    (111) struct_declaration -> . type_specifier_list struct_declarator_list 
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 48
    struct_declaration             shift and go to state 66
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    struct_declaration_list        shift and go to state 65
    type_specifier_list            shift and go to state 67

state 41

    (130) declarator2 -> declarator2 ( . )
    (131) declarator2 -> declarator2 ( . parameter_type_list )
    (132) declarator2 -> declarator2 ( . parameter_identifier_list )
    (143) parameter_type_list -> . parameter_list
    (144) parameter_type_list -> . parameter_list , ELIPSIS
    (139) parameter_identifier_list -> . identifier_list
    (140) parameter_identifier_list -> . identifier_list , ELIPSIS
    (145) parameter_list -> . parameter_declaration
    (146) parameter_list -> . parameter_list , parameter_declaration
    (141) identifier_list -> . identifier
    (142) identifier_list -> . identifier_list , identifier
    (147) parameter_declaration -> . type_specifier_list declarator
    (148) parameter_declaration -> . type_name
    (216) identifier -> . IDENTIFIER
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (149) type_name -> . type_specifier_list
    (150) type_name -> . type_specifier_list abstract_declarator
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    )               shift and go to state 68
    IDENTIFIER      shift and go to state 21
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    identifier                     shift and go to state 76
    parameter_list                 shift and go to state 75
    parameter_type_list            shift and go to state 70
    parameter_declaration          shift and go to state 71
    type_name                      shift and go to state 69
    parameter_identifier_list      shift and go to state 72
    enum_specifier                 shift and go to state 33
    type_specifier_list            shift and go to state 73
    struct_or_union_specifier      shift and go to state 4
    type_specifier                 shift and go to state 48
    identifier_list                shift and go to state 74

state 42

    (128) declarator2 -> declarator2 [ . ]
    (129) declarator2 -> declarator2 [ . constant_expr ]
    (74) constant_expr -> . conditional_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    ]               shift and go to state 96
    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    equality_expr                  shift and go to state 90
    unary_expr                     shift and go to state 79
    constant_expr                  shift and go to state 82
    logical_or_expr                shift and go to state 84
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    conditional_expr               shift and go to state 97
    exclusive_or_expr              shift and go to state 101
    logical_and_expr               shift and go to state 102
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98

state 43

    (209) file -> file external_definition .

    (               reduce using rule 209 (file -> file external_definition .)
    *               reduce using rule 209 (file -> file external_definition .)
    TYPEDEF         reduce using rule 209 (file -> file external_definition .)
    EXTERN          reduce using rule 209 (file -> file external_definition .)
    STATIC          reduce using rule 209 (file -> file external_definition .)
    AUTO            reduce using rule 209 (file -> file external_definition .)
    REGISTER        reduce using rule 209 (file -> file external_definition .)
    CHAR            reduce using rule 209 (file -> file external_definition .)
    SHORT           reduce using rule 209 (file -> file external_definition .)
    INT             reduce using rule 209 (file -> file external_definition .)
    LONG            reduce using rule 209 (file -> file external_definition .)
    SIGNED          reduce using rule 209 (file -> file external_definition .)
    UNSIGNED        reduce using rule 209 (file -> file external_definition .)
    FLOAT           reduce using rule 209 (file -> file external_definition .)
    DOUBLE          reduce using rule 209 (file -> file external_definition .)
    CONST           reduce using rule 209 (file -> file external_definition .)
    VOLATILE        reduce using rule 209 (file -> file external_definition .)
    VOID            reduce using rule 209 (file -> file external_definition .)
    TYPE_NAME       reduce using rule 209 (file -> file external_definition .)
    IDENTIFIER      reduce using rule 209 (file -> file external_definition .)
    ENUM            reduce using rule 209 (file -> file external_definition .)
    STRUCT          reduce using rule 209 (file -> file external_definition .)
    UNION           reduce using rule 209 (file -> file external_definition .)
    $end            reduce using rule 209 (file -> file external_definition .)



state 44

    (125) declarator -> pointer declarator2 .
    (128) declarator2 -> declarator2 . [ ]
    (129) declarator2 -> declarator2 . [ constant_expr ]
    (130) declarator2 -> declarator2 . ( )
    (131) declarator2 -> declarator2 . ( parameter_type_list )
    (132) declarator2 -> declarator2 . ( parameter_identifier_list )

    :               reduce using rule 125 (declarator -> pointer declarator2 .)
                    reduce using rule 125 (declarator -> pointer declarator2 .)
    ,               reduce using rule 125 (declarator -> pointer declarator2 .)
    =               reduce using rule 125 (declarator -> pointer declarator2 .)
    {               reduce using rule 125 (declarator -> pointer declarator2 .)
    TYPEDEF         reduce using rule 125 (declarator -> pointer declarator2 .)
    EXTERN          reduce using rule 125 (declarator -> pointer declarator2 .)
    STATIC          reduce using rule 125 (declarator -> pointer declarator2 .)
    AUTO            reduce using rule 125 (declarator -> pointer declarator2 .)
    REGISTER        reduce using rule 125 (declarator -> pointer declarator2 .)
    CHAR            reduce using rule 125 (declarator -> pointer declarator2 .)
    SHORT           reduce using rule 125 (declarator -> pointer declarator2 .)
    INT             reduce using rule 125 (declarator -> pointer declarator2 .)
    LONG            reduce using rule 125 (declarator -> pointer declarator2 .)
    SIGNED          reduce using rule 125 (declarator -> pointer declarator2 .)
    UNSIGNED        reduce using rule 125 (declarator -> pointer declarator2 .)
    FLOAT           reduce using rule 125 (declarator -> pointer declarator2 .)
    DOUBLE          reduce using rule 125 (declarator -> pointer declarator2 .)
    CONST           reduce using rule 125 (declarator -> pointer declarator2 .)
    VOLATILE        reduce using rule 125 (declarator -> pointer declarator2 .)
    VOID            reduce using rule 125 (declarator -> pointer declarator2 .)
    TYPE_NAME       reduce using rule 125 (declarator -> pointer declarator2 .)
    ENUM            reduce using rule 125 (declarator -> pointer declarator2 .)
    STRUCT          reduce using rule 125 (declarator -> pointer declarator2 .)
    UNION           reduce using rule 125 (declarator -> pointer declarator2 .)
    )               reduce using rule 125 (declarator -> pointer declarator2 .)
    [               shift and go to state 42
    (               shift and go to state 41



state 45

    (80) declaration_specifiers -> type_specifier declaration_specifiers .

                    reduce using rule 80 (declaration_specifiers -> type_specifier declaration_specifiers .)
    (               reduce using rule 80 (declaration_specifiers -> type_specifier declaration_specifiers .)
    *               reduce using rule 80 (declaration_specifiers -> type_specifier declaration_specifiers .)
    IDENTIFIER      reduce using rule 80 (declaration_specifiers -> type_specifier declaration_specifiers .)



state 46

    (127) declarator2 -> ( declarator . )

    )               shift and go to state 108



state 47

    (135) pointer -> * pointer .

    (               reduce using rule 135 (pointer -> * pointer .)
    IDENTIFIER      reduce using rule 135 (pointer -> * pointer .)
    [               reduce using rule 135 (pointer -> * pointer .)
    ,               reduce using rule 135 (pointer -> * pointer .)
    )               reduce using rule 135 (pointer -> * pointer .)



state 48

    (137) type_specifier_list -> type_specifier .

    CHAR            reduce using rule 137 (type_specifier_list -> type_specifier .)
    SHORT           reduce using rule 137 (type_specifier_list -> type_specifier .)
    INT             reduce using rule 137 (type_specifier_list -> type_specifier .)
    LONG            reduce using rule 137 (type_specifier_list -> type_specifier .)
    SIGNED          reduce using rule 137 (type_specifier_list -> type_specifier .)
    UNSIGNED        reduce using rule 137 (type_specifier_list -> type_specifier .)
    FLOAT           reduce using rule 137 (type_specifier_list -> type_specifier .)
    DOUBLE          reduce using rule 137 (type_specifier_list -> type_specifier .)
    CONST           reduce using rule 137 (type_specifier_list -> type_specifier .)
    VOLATILE        reduce using rule 137 (type_specifier_list -> type_specifier .)
    VOID            reduce using rule 137 (type_specifier_list -> type_specifier .)
    TYPE_NAME       reduce using rule 137 (type_specifier_list -> type_specifier .)
    :               reduce using rule 137 (type_specifier_list -> type_specifier .)
    ENUM            reduce using rule 137 (type_specifier_list -> type_specifier .)
    STRUCT          reduce using rule 137 (type_specifier_list -> type_specifier .)
    UNION           reduce using rule 137 (type_specifier_list -> type_specifier .)
    (               reduce using rule 137 (type_specifier_list -> type_specifier .)
    *               reduce using rule 137 (type_specifier_list -> type_specifier .)
    IDENTIFIER      reduce using rule 137 (type_specifier_list -> type_specifier .)
    [               reduce using rule 137 (type_specifier_list -> type_specifier .)
    ,               reduce using rule 137 (type_specifier_list -> type_specifier .)
    )               reduce using rule 137 (type_specifier_list -> type_specifier .)



state 49

    (134) pointer -> * type_specifier_list .
    (136) pointer -> * type_specifier_list . pointer
    (138) type_specifier_list -> type_specifier_list . type_specifier
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    (               reduce using rule 134 (pointer -> * type_specifier_list .)
    IDENTIFIER      reduce using rule 134 (pointer -> * type_specifier_list .)
    [               reduce using rule 134 (pointer -> * type_specifier_list .)
    ,               reduce using rule 134 (pointer -> * type_specifier_list .)
    )               reduce using rule 134 (pointer -> * type_specifier_list .)
    *               shift and go to state 17
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 110
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    pointer                        shift and go to state 109

state 50

    (118) enum_specifier -> ENUM identifier . { enumerator_list }
    (119) enum_specifier -> ENUM identifier .

    {               shift and go to state 111
    CHAR            reduce using rule 119 (enum_specifier -> ENUM identifier .)
    SHORT           reduce using rule 119 (enum_specifier -> ENUM identifier .)
    INT             reduce using rule 119 (enum_specifier -> ENUM identifier .)
    LONG            reduce using rule 119 (enum_specifier -> ENUM identifier .)
    SIGNED          reduce using rule 119 (enum_specifier -> ENUM identifier .)
    UNSIGNED        reduce using rule 119 (enum_specifier -> ENUM identifier .)
    FLOAT           reduce using rule 119 (enum_specifier -> ENUM identifier .)
    DOUBLE          reduce using rule 119 (enum_specifier -> ENUM identifier .)
    CONST           reduce using rule 119 (enum_specifier -> ENUM identifier .)
    VOLATILE        reduce using rule 119 (enum_specifier -> ENUM identifier .)
    VOID            reduce using rule 119 (enum_specifier -> ENUM identifier .)
    TYPE_NAME       reduce using rule 119 (enum_specifier -> ENUM identifier .)
    (               reduce using rule 119 (enum_specifier -> ENUM identifier .)
    *               reduce using rule 119 (enum_specifier -> ENUM identifier .)
    ENUM            reduce using rule 119 (enum_specifier -> ENUM identifier .)
    [               reduce using rule 119 (enum_specifier -> ENUM identifier .)
    IDENTIFIER      reduce using rule 119 (enum_specifier -> ENUM identifier .)
    STRUCT          reduce using rule 119 (enum_specifier -> ENUM identifier .)
    UNION           reduce using rule 119 (enum_specifier -> ENUM identifier .)
    ,               reduce using rule 119 (enum_specifier -> ENUM identifier .)
    )               reduce using rule 119 (enum_specifier -> ENUM identifier .)
    TYPEDEF         reduce using rule 119 (enum_specifier -> ENUM identifier .)
    EXTERN          reduce using rule 119 (enum_specifier -> ENUM identifier .)
    STATIC          reduce using rule 119 (enum_specifier -> ENUM identifier .)
    AUTO            reduce using rule 119 (enum_specifier -> ENUM identifier .)
    REGISTER        reduce using rule 119 (enum_specifier -> ENUM identifier .)
                    reduce using rule 119 (enum_specifier -> ENUM identifier .)
    :               reduce using rule 119 (enum_specifier -> ENUM identifier .)



state 51

    (117) enum_specifier -> ENUM { . enumerator_list }
    (120) enumerator_list -> . enumerator
    (121) enumerator_list -> . enumerator_list , enumerator
    (122) enumerator -> . identifier
    (123) enumerator -> . identifier = constant_expr
    (216) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 21


    enumerator_list                shift and go to state 113
    identifier                     shift and go to state 114
    enumerator                     shift and go to state 112

state 52

    (75) declaration -> declaration_specifiers  .

    {               reduce using rule 75 (declaration -> declaration_specifiers  .)
    TYPEDEF         reduce using rule 75 (declaration -> declaration_specifiers  .)
    EXTERN          reduce using rule 75 (declaration -> declaration_specifiers  .)
    STATIC          reduce using rule 75 (declaration -> declaration_specifiers  .)
    AUTO            reduce using rule 75 (declaration -> declaration_specifiers  .)
    REGISTER        reduce using rule 75 (declaration -> declaration_specifiers  .)
    CHAR            reduce using rule 75 (declaration -> declaration_specifiers  .)
    SHORT           reduce using rule 75 (declaration -> declaration_specifiers  .)
    INT             reduce using rule 75 (declaration -> declaration_specifiers  .)
    LONG            reduce using rule 75 (declaration -> declaration_specifiers  .)
    SIGNED          reduce using rule 75 (declaration -> declaration_specifiers  .)
    UNSIGNED        reduce using rule 75 (declaration -> declaration_specifiers  .)
    FLOAT           reduce using rule 75 (declaration -> declaration_specifiers  .)
    DOUBLE          reduce using rule 75 (declaration -> declaration_specifiers  .)
    CONST           reduce using rule 75 (declaration -> declaration_specifiers  .)
    VOLATILE        reduce using rule 75 (declaration -> declaration_specifiers  .)
    VOID            reduce using rule 75 (declaration -> declaration_specifiers  .)
    TYPE_NAME       reduce using rule 75 (declaration -> declaration_specifiers  .)
    ENUM            reduce using rule 75 (declaration -> declaration_specifiers  .)
    STRUCT          reduce using rule 75 (declaration -> declaration_specifiers  .)
    UNION           reduce using rule 75 (declaration -> declaration_specifiers  .)
    (               reduce using rule 75 (declaration -> declaration_specifiers  .)
    *               reduce using rule 75 (declaration -> declaration_specifiers  .)
    IDENTIFIER      reduce using rule 75 (declaration -> declaration_specifiers  .)
    $end            reduce using rule 75 (declaration -> declaration_specifiers  .)
    }               reduce using rule 75 (declaration -> declaration_specifiers  .)
    CASE            reduce using rule 75 (declaration -> declaration_specifiers  .)
    DEFAULT         reduce using rule 75 (declaration -> declaration_specifiers  .)
    ;               reduce using rule 75 (declaration -> declaration_specifiers  .)
    IF              reduce using rule 75 (declaration -> declaration_specifiers  .)
    SWITCH          reduce using rule 75 (declaration -> declaration_specifiers  .)
    WHILE           reduce using rule 75 (declaration -> declaration_specifiers  .)
    DO              reduce using rule 75 (declaration -> declaration_specifiers  .)
    FOR             reduce using rule 75 (declaration -> declaration_specifiers  .)
    GOTO            reduce using rule 75 (declaration -> declaration_specifiers  .)
    CONTINUE        reduce using rule 75 (declaration -> declaration_specifiers  .)
    BREAK           reduce using rule 75 (declaration -> declaration_specifiers  .)
    RETURN          reduce using rule 75 (declaration -> declaration_specifiers  .)
    INC_OP          reduce using rule 75 (declaration -> declaration_specifiers  .)
    DEC_OP          reduce using rule 75 (declaration -> declaration_specifiers  .)
    SIZEOF          reduce using rule 75 (declaration -> declaration_specifiers  .)
    &               reduce using rule 75 (declaration -> declaration_specifiers  .)
    +               reduce using rule 75 (declaration -> declaration_specifiers  .)
    -               reduce using rule 75 (declaration -> declaration_specifiers  .)
    ~               reduce using rule 75 (declaration -> declaration_specifiers  .)
    !               reduce using rule 75 (declaration -> declaration_specifiers  .)
    CONSTANT        reduce using rule 75 (declaration -> declaration_specifiers  .)
    STRING_LITERAL  reduce using rule 75 (declaration -> declaration_specifiers  .)



state 53

    (213) function_definition -> declaration_specifiers declarator . function_body
    (83) init_declarator -> declarator .
    (84) init_declarator -> declarator . = initializer
    (214) function_body -> . compound_statement
    (215) function_body -> . declaration_list compound_statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (183) declaration_list -> . declaration
    (184) declaration_list -> . declaration_list declaration
    (177) left_bracket -> . {
    (75) declaration -> . declaration_specifiers 
    (76) declaration -> . declaration_specifiers init_declarator_list 
    (77) declaration_specifiers -> . storage_class_specifier
    (78) declaration_specifiers -> . storage_class_specifier declaration_specifiers
    (79) declaration_specifiers -> . type_specifier
    (80) declaration_specifiers -> . type_specifier declaration_specifiers
    (85) storage_class_specifier -> . TYPEDEF
    (86) storage_class_specifier -> . EXTERN
    (87) storage_class_specifier -> . STATIC
    (88) storage_class_specifier -> . AUTO
    (89) storage_class_specifier -> . REGISTER
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

                    reduce using rule 83 (init_declarator -> declarator .)
    ,               reduce using rule 83 (init_declarator -> declarator .)
    =               shift and go to state 116
    {               shift and go to state 62
    TYPEDEF         shift and go to state 22
    EXTERN          shift and go to state 12
    STATIC          shift and go to state 10
    AUTO            shift and go to state 23
    REGISTER        shift and go to state 36
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    storage_class_specifier        shift and go to state 38
    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 15
    compound_statement             shift and go to state 58
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    declaration                    shift and go to state 60
    declaration_list               shift and go to state 61
    declaration_specifiers         shift and go to state 59
    function_body                  shift and go to state 115
    left_bracket                   shift and go to state 57

state 54

    (76) declaration -> declaration_specifiers init_declarator_list . 
    (82) init_declarator_list -> init_declarator_list . , init_declarator

                    shift and go to state 117
    ,               shift and go to state 118



state 55

    (81) init_declarator_list -> init_declarator .

                    reduce using rule 81 (init_declarator_list -> init_declarator .)
    ,               reduce using rule 81 (init_declarator_list -> init_declarator .)



state 56

    (212) function_definition -> declarator function_body .

    (               reduce using rule 212 (function_definition -> declarator function_body .)
    *               reduce using rule 212 (function_definition -> declarator function_body .)
    TYPEDEF         reduce using rule 212 (function_definition -> declarator function_body .)
    EXTERN          reduce using rule 212 (function_definition -> declarator function_body .)
    STATIC          reduce using rule 212 (function_definition -> declarator function_body .)
    AUTO            reduce using rule 212 (function_definition -> declarator function_body .)
    REGISTER        reduce using rule 212 (function_definition -> declarator function_body .)
    CHAR            reduce using rule 212 (function_definition -> declarator function_body .)
    SHORT           reduce using rule 212 (function_definition -> declarator function_body .)
    INT             reduce using rule 212 (function_definition -> declarator function_body .)
    LONG            reduce using rule 212 (function_definition -> declarator function_body .)
    SIGNED          reduce using rule 212 (function_definition -> declarator function_body .)
    UNSIGNED        reduce using rule 212 (function_definition -> declarator function_body .)
    FLOAT           reduce using rule 212 (function_definition -> declarator function_body .)
    DOUBLE          reduce using rule 212 (function_definition -> declarator function_body .)
    CONST           reduce using rule 212 (function_definition -> declarator function_body .)
    VOLATILE        reduce using rule 212 (function_definition -> declarator function_body .)
    VOID            reduce using rule 212 (function_definition -> declarator function_body .)
    TYPE_NAME       reduce using rule 212 (function_definition -> declarator function_body .)
    IDENTIFIER      reduce using rule 212 (function_definition -> declarator function_body .)
    ENUM            reduce using rule 212 (function_definition -> declarator function_body .)
    STRUCT          reduce using rule 212 (function_definition -> declarator function_body .)
    UNION           reduce using rule 212 (function_definition -> declarator function_body .)
    $end            reduce using rule 212 (function_definition -> declarator function_body .)



state 57

    (179) compound_statement -> left_bracket . right_bracket
    (180) compound_statement -> left_bracket . statement_list right_bracket
    (181) compound_statement -> left_bracket . declaration_list right_bracket
    (182) compound_statement -> left_bracket . declaration_list statement_list right_bracket
    (178) right_bracket -> . }
    (185) statement_list -> . statement
    (186) statement_list -> . statement_list statement
    (183) declaration_list -> . declaration
    (184) declaration_list -> . declaration_list declaration
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (75) declaration -> . declaration_specifiers 
    (76) declaration -> . declaration_specifiers init_declarator_list 
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (77) declaration_specifiers -> . storage_class_specifier
    (78) declaration_specifiers -> . storage_class_specifier declaration_specifiers
    (79) declaration_specifiers -> . type_specifier
    (80) declaration_specifiers -> . type_specifier declaration_specifiers
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (85) storage_class_specifier -> . TYPEDEF
    (86) storage_class_specifier -> . EXTERN
    (87) storage_class_specifier -> . STATIC
    (88) storage_class_specifier -> . AUTO
    (89) storage_class_specifier -> . REGISTER
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    }               shift and go to state 147
    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    TYPEDEF         shift and go to state 22
    EXTERN          shift and go to state 12
    STATIC          shift and go to state 10
    AUTO            shift and go to state 23
    REGISTER        shift and go to state 36
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    storage_class_specifier        shift and go to state 38
    unary_expr                     shift and go to state 133
    struct_or_union_specifier      shift and go to state 4
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    type_specifier                 shift and go to state 15
    cast_expr                      shift and go to state 95
    compound_statement             shift and go to state 127
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 138
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    struct_or_union                shift and go to state 6
    relational_expr                shift and go to state 94
    right_bracket                  shift and go to state 130
    statement_list                 shift and go to state 132
    declaration_specifiers         shift and go to state 59
    declaration                    shift and go to state 60
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    enum_specifier                 shift and go to state 33
    expr                           shift and go to state 141
    postfix_expr                   shift and go to state 99
    labeled_statement              shift and go to state 123
    declaration_list               shift and go to state 124
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 58

    (214) function_body -> compound_statement .

    (               reduce using rule 214 (function_body -> compound_statement .)
    *               reduce using rule 214 (function_body -> compound_statement .)
    TYPEDEF         reduce using rule 214 (function_body -> compound_statement .)
    EXTERN          reduce using rule 214 (function_body -> compound_statement .)
    STATIC          reduce using rule 214 (function_body -> compound_statement .)
    AUTO            reduce using rule 214 (function_body -> compound_statement .)
    REGISTER        reduce using rule 214 (function_body -> compound_statement .)
    CHAR            reduce using rule 214 (function_body -> compound_statement .)
    SHORT           reduce using rule 214 (function_body -> compound_statement .)
    INT             reduce using rule 214 (function_body -> compound_statement .)
    LONG            reduce using rule 214 (function_body -> compound_statement .)
    SIGNED          reduce using rule 214 (function_body -> compound_statement .)
    UNSIGNED        reduce using rule 214 (function_body -> compound_statement .)
    FLOAT           reduce using rule 214 (function_body -> compound_statement .)
    DOUBLE          reduce using rule 214 (function_body -> compound_statement .)
    CONST           reduce using rule 214 (function_body -> compound_statement .)
    VOLATILE        reduce using rule 214 (function_body -> compound_statement .)
    VOID            reduce using rule 214 (function_body -> compound_statement .)
    TYPE_NAME       reduce using rule 214 (function_body -> compound_statement .)
    IDENTIFIER      reduce using rule 214 (function_body -> compound_statement .)
    ENUM            reduce using rule 214 (function_body -> compound_statement .)
    STRUCT          reduce using rule 214 (function_body -> compound_statement .)
    UNION           reduce using rule 214 (function_body -> compound_statement .)
    $end            reduce using rule 214 (function_body -> compound_statement .)



state 59

    (75) declaration -> declaration_specifiers . 
    (76) declaration -> declaration_specifiers . init_declarator_list 
    (81) init_declarator_list -> . init_declarator
    (82) init_declarator_list -> . init_declarator_list , init_declarator
    (83) init_declarator -> . declarator
    (84) init_declarator -> . declarator = initializer
    (124) declarator -> . declarator2
    (125) declarator -> . pointer declarator2
    (126) declarator2 -> . identifier
    (127) declarator2 -> . ( declarator )
    (128) declarator2 -> . declarator2 [ ]
    (129) declarator2 -> . declarator2 [ constant_expr ]
    (130) declarator2 -> . declarator2 ( )
    (131) declarator2 -> . declarator2 ( parameter_type_list )
    (132) declarator2 -> . declarator2 ( parameter_identifier_list )
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (216) identifier -> . IDENTIFIER

                    shift and go to state 52
    (               shift and go to state 16
    *               shift and go to state 17
    IDENTIFIER      shift and go to state 21


    identifier                     shift and go to state 37
    init_declarator                shift and go to state 55
    declarator2                    shift and go to state 7
    declarator                     shift and go to state 148
    init_declarator_list           shift and go to state 54
    pointer                        shift and go to state 14

state 60

    (183) declaration_list -> declaration .

    {               reduce using rule 183 (declaration_list -> declaration .)
    TYPEDEF         reduce using rule 183 (declaration_list -> declaration .)
    EXTERN          reduce using rule 183 (declaration_list -> declaration .)
    STATIC          reduce using rule 183 (declaration_list -> declaration .)
    AUTO            reduce using rule 183 (declaration_list -> declaration .)
    REGISTER        reduce using rule 183 (declaration_list -> declaration .)
    CHAR            reduce using rule 183 (declaration_list -> declaration .)
    SHORT           reduce using rule 183 (declaration_list -> declaration .)
    INT             reduce using rule 183 (declaration_list -> declaration .)
    LONG            reduce using rule 183 (declaration_list -> declaration .)
    SIGNED          reduce using rule 183 (declaration_list -> declaration .)
    UNSIGNED        reduce using rule 183 (declaration_list -> declaration .)
    FLOAT           reduce using rule 183 (declaration_list -> declaration .)
    DOUBLE          reduce using rule 183 (declaration_list -> declaration .)
    CONST           reduce using rule 183 (declaration_list -> declaration .)
    VOLATILE        reduce using rule 183 (declaration_list -> declaration .)
    VOID            reduce using rule 183 (declaration_list -> declaration .)
    TYPE_NAME       reduce using rule 183 (declaration_list -> declaration .)
    ENUM            reduce using rule 183 (declaration_list -> declaration .)
    STRUCT          reduce using rule 183 (declaration_list -> declaration .)
    UNION           reduce using rule 183 (declaration_list -> declaration .)
    }               reduce using rule 183 (declaration_list -> declaration .)
    CASE            reduce using rule 183 (declaration_list -> declaration .)
    DEFAULT         reduce using rule 183 (declaration_list -> declaration .)
    ;               reduce using rule 183 (declaration_list -> declaration .)
    IF              reduce using rule 183 (declaration_list -> declaration .)
    SWITCH          reduce using rule 183 (declaration_list -> declaration .)
    WHILE           reduce using rule 183 (declaration_list -> declaration .)
    DO              reduce using rule 183 (declaration_list -> declaration .)
    FOR             reduce using rule 183 (declaration_list -> declaration .)
    GOTO            reduce using rule 183 (declaration_list -> declaration .)
    CONTINUE        reduce using rule 183 (declaration_list -> declaration .)
    BREAK           reduce using rule 183 (declaration_list -> declaration .)
    RETURN          reduce using rule 183 (declaration_list -> declaration .)
    IDENTIFIER      reduce using rule 183 (declaration_list -> declaration .)
    INC_OP          reduce using rule 183 (declaration_list -> declaration .)
    DEC_OP          reduce using rule 183 (declaration_list -> declaration .)
    SIZEOF          reduce using rule 183 (declaration_list -> declaration .)
    &               reduce using rule 183 (declaration_list -> declaration .)
    *               reduce using rule 183 (declaration_list -> declaration .)
    +               reduce using rule 183 (declaration_list -> declaration .)
    -               reduce using rule 183 (declaration_list -> declaration .)
    ~               reduce using rule 183 (declaration_list -> declaration .)
    !               reduce using rule 183 (declaration_list -> declaration .)
    CONSTANT        reduce using rule 183 (declaration_list -> declaration .)
    STRING_LITERAL  reduce using rule 183 (declaration_list -> declaration .)
    (               reduce using rule 183 (declaration_list -> declaration .)



state 61

    (215) function_body -> declaration_list . compound_statement
    (184) declaration_list -> declaration_list . declaration
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (75) declaration -> . declaration_specifiers 
    (76) declaration -> . declaration_specifiers init_declarator_list 
    (177) left_bracket -> . {
    (77) declaration_specifiers -> . storage_class_specifier
    (78) declaration_specifiers -> . storage_class_specifier declaration_specifiers
    (79) declaration_specifiers -> . type_specifier
    (80) declaration_specifiers -> . type_specifier declaration_specifiers
    (85) storage_class_specifier -> . TYPEDEF
    (86) storage_class_specifier -> . EXTERN
    (87) storage_class_specifier -> . STATIC
    (88) storage_class_specifier -> . AUTO
    (89) storage_class_specifier -> . REGISTER
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    {               shift and go to state 62
    TYPEDEF         shift and go to state 22
    EXTERN          shift and go to state 12
    STATIC          shift and go to state 10
    AUTO            shift and go to state 23
    REGISTER        shift and go to state 36
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    storage_class_specifier        shift and go to state 38
    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 15
    compound_statement             shift and go to state 149
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    declaration_specifiers         shift and go to state 59
    declaration                    shift and go to state 150
    left_bracket                   shift and go to state 57

state 62

    (177) left_bracket -> { .

    }               reduce using rule 177 (left_bracket -> { .)
    CASE            reduce using rule 177 (left_bracket -> { .)
    DEFAULT         reduce using rule 177 (left_bracket -> { .)
    ;               reduce using rule 177 (left_bracket -> { .)
    IF              reduce using rule 177 (left_bracket -> { .)
    SWITCH          reduce using rule 177 (left_bracket -> { .)
    WHILE           reduce using rule 177 (left_bracket -> { .)
    DO              reduce using rule 177 (left_bracket -> { .)
    FOR             reduce using rule 177 (left_bracket -> { .)
    GOTO            reduce using rule 177 (left_bracket -> { .)
    CONTINUE        reduce using rule 177 (left_bracket -> { .)
    BREAK           reduce using rule 177 (left_bracket -> { .)
    RETURN          reduce using rule 177 (left_bracket -> { .)
    IDENTIFIER      reduce using rule 177 (left_bracket -> { .)
    {               reduce using rule 177 (left_bracket -> { .)
    TYPEDEF         reduce using rule 177 (left_bracket -> { .)
    EXTERN          reduce using rule 177 (left_bracket -> { .)
    STATIC          reduce using rule 177 (left_bracket -> { .)
    AUTO            reduce using rule 177 (left_bracket -> { .)
    REGISTER        reduce using rule 177 (left_bracket -> { .)
    CHAR            reduce using rule 177 (left_bracket -> { .)
    SHORT           reduce using rule 177 (left_bracket -> { .)
    INT             reduce using rule 177 (left_bracket -> { .)
    LONG            reduce using rule 177 (left_bracket -> { .)
    SIGNED          reduce using rule 177 (left_bracket -> { .)
    UNSIGNED        reduce using rule 177 (left_bracket -> { .)
    FLOAT           reduce using rule 177 (left_bracket -> { .)
    DOUBLE          reduce using rule 177 (left_bracket -> { .)
    CONST           reduce using rule 177 (left_bracket -> { .)
    VOLATILE        reduce using rule 177 (left_bracket -> { .)
    VOID            reduce using rule 177 (left_bracket -> { .)
    TYPE_NAME       reduce using rule 177 (left_bracket -> { .)
    ENUM            reduce using rule 177 (left_bracket -> { .)
    INC_OP          reduce using rule 177 (left_bracket -> { .)
    DEC_OP          reduce using rule 177 (left_bracket -> { .)
    SIZEOF          reduce using rule 177 (left_bracket -> { .)
    STRUCT          reduce using rule 177 (left_bracket -> { .)
    UNION           reduce using rule 177 (left_bracket -> { .)
    &               reduce using rule 177 (left_bracket -> { .)
    *               reduce using rule 177 (left_bracket -> { .)
    +               reduce using rule 177 (left_bracket -> { .)
    -               reduce using rule 177 (left_bracket -> { .)
    ~               reduce using rule 177 (left_bracket -> { .)
    !               reduce using rule 177 (left_bracket -> { .)
    CONSTANT        reduce using rule 177 (left_bracket -> { .)
    STRING_LITERAL  reduce using rule 177 (left_bracket -> { .)
    (               reduce using rule 177 (left_bracket -> { .)



state 63

    (78) declaration_specifiers -> storage_class_specifier declaration_specifiers .

                    reduce using rule 78 (declaration_specifiers -> storage_class_specifier declaration_specifiers .)
    (               reduce using rule 78 (declaration_specifiers -> storage_class_specifier declaration_specifiers .)
    *               reduce using rule 78 (declaration_specifiers -> storage_class_specifier declaration_specifiers .)
    IDENTIFIER      reduce using rule 78 (declaration_specifiers -> storage_class_specifier declaration_specifiers .)



state 64

    (104) struct_or_union_specifier -> struct_or_union identifier { . struct_declaration_list }
    (109) struct_declaration_list -> . struct_declaration
    (110) struct_declaration_list -> . struct_declaration_list struct_declaration
    (111) struct_declaration -> . type_specifier_list struct_declarator_list 
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 48
    struct_declaration             shift and go to state 66
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    struct_declaration_list        shift and go to state 151
    type_specifier_list            shift and go to state 67

state 65

    (105) struct_or_union_specifier -> struct_or_union { struct_declaration_list . }
    (110) struct_declaration_list -> struct_declaration_list . struct_declaration
    (111) struct_declaration -> . type_specifier_list struct_declarator_list 
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    }               shift and go to state 153
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 48
    struct_declaration             shift and go to state 152
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    type_specifier_list            shift and go to state 67

state 66

    (109) struct_declaration_list -> struct_declaration .

    }               reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    CHAR            reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    SHORT           reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    INT             reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    LONG            reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    SIGNED          reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    UNSIGNED        reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    FLOAT           reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    DOUBLE          reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    CONST           reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    VOLATILE        reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    VOID            reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    TYPE_NAME       reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    ENUM            reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    STRUCT          reduce using rule 109 (struct_declaration_list -> struct_declaration .)
    UNION           reduce using rule 109 (struct_declaration_list -> struct_declaration .)



state 67

    (111) struct_declaration -> type_specifier_list . struct_declarator_list 
    (138) type_specifier_list -> type_specifier_list . type_specifier
    (112) struct_declarator_list -> . struct_declarator
    (113) struct_declarator_list -> . struct_declarator_list , struct_declarator
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (114) struct_declarator -> . declarator
    (115) struct_declarator -> . : constant_expr
    (116) struct_declarator -> . declarator : constant_expr
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (124) declarator -> . declarator2
    (125) declarator -> . pointer declarator2
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION
    (126) declarator2 -> . identifier
    (127) declarator2 -> . ( declarator )
    (128) declarator2 -> . declarator2 [ ]
    (129) declarator2 -> . declarator2 [ constant_expr ]
    (130) declarator2 -> . declarator2 ( )
    (131) declarator2 -> . declarator2 ( parameter_type_list )
    (132) declarator2 -> . declarator2 ( parameter_identifier_list )
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (216) identifier -> . IDENTIFIER

    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    :               shift and go to state 154
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20
    (               shift and go to state 16
    *               shift and go to state 17
    IDENTIFIER      shift and go to state 21


    struct_declarator              shift and go to state 156
    type_specifier                 shift and go to state 110
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    struct_or_union                shift and go to state 6
    declarator2                    shift and go to state 7
    declarator                     shift and go to state 157
    identifier                     shift and go to state 37
    struct_declarator_list         shift and go to state 155
    pointer                        shift and go to state 14

state 68

    (130) declarator2 -> declarator2 ( ) .

    [               reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    (               reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    {               reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    TYPEDEF         reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    EXTERN          reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    STATIC          reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    AUTO            reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    REGISTER        reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    CHAR            reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    SHORT           reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    INT             reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    LONG            reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    SIGNED          reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    UNSIGNED        reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    FLOAT           reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    DOUBLE          reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    CONST           reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    VOLATILE        reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    VOID            reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    TYPE_NAME       reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    ENUM            reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    STRUCT          reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    UNION           reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    )               reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    =               reduce using rule 130 (declarator2 -> declarator2 ( ) .)
                    reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    ,               reduce using rule 130 (declarator2 -> declarator2 ( ) .)
    :               reduce using rule 130 (declarator2 -> declarator2 ( ) .)



state 69

    (148) parameter_declaration -> type_name .

    ,               reduce using rule 148 (parameter_declaration -> type_name .)
    )               reduce using rule 148 (parameter_declaration -> type_name .)



state 70

    (131) declarator2 -> declarator2 ( parameter_type_list . )

    )               shift and go to state 158



state 71

    (145) parameter_list -> parameter_declaration .

    ,               reduce using rule 145 (parameter_list -> parameter_declaration .)
    )               reduce using rule 145 (parameter_list -> parameter_declaration .)



state 72

    (132) declarator2 -> declarator2 ( parameter_identifier_list . )

    )               shift and go to state 159



state 73

    (147) parameter_declaration -> type_specifier_list . declarator
    (138) type_specifier_list -> type_specifier_list . type_specifier
    (149) type_name -> type_specifier_list .
    (150) type_name -> type_specifier_list . abstract_declarator
    (124) declarator -> . declarator2
    (125) declarator -> . pointer declarator2
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (151) abstract_declarator -> . pointer
    (152) abstract_declarator -> . abstract_declarator2
    (153) abstract_declarator -> . pointer abstract_declarator2
    (126) declarator2 -> . identifier
    (127) declarator2 -> . ( declarator )
    (128) declarator2 -> . declarator2 [ ]
    (129) declarator2 -> . declarator2 [ constant_expr ]
    (130) declarator2 -> . declarator2 ( )
    (131) declarator2 -> . declarator2 ( parameter_type_list )
    (132) declarator2 -> . declarator2 ( parameter_identifier_list )
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (154) abstract_declarator2 -> . ( abstract_declarator )
    (155) abstract_declarator2 -> . [ ]
    (156) abstract_declarator2 -> . [ constant_expr ]
    (157) abstract_declarator2 -> . abstract_declarator2 [ ]
    (158) abstract_declarator2 -> . abstract_declarator2 [ constant_expr ]
    (159) abstract_declarator2 -> . ( )
    (160) abstract_declarator2 -> . ( parameter_type_list )
    (161) abstract_declarator2 -> . abstract_declarator2 ( )
    (162) abstract_declarator2 -> . abstract_declarator2 ( parameter_type_list )
    (216) identifier -> . IDENTIFIER
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    ,               reduce using rule 149 (type_name -> type_specifier_list .)
    )               reduce using rule 149 (type_name -> type_specifier_list .)
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    (               shift and go to state 161
    *               shift and go to state 17
    ENUM            shift and go to state 24
    [               shift and go to state 163
    IDENTIFIER      shift and go to state 21
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 110
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    declarator2                    shift and go to state 7
    abstract_declarator            shift and go to state 164
    abstract_declarator2           shift and go to state 162
    declarator                     shift and go to state 165
    identifier                     shift and go to state 37
    pointer                        shift and go to state 160

state 74

    (139) parameter_identifier_list -> identifier_list .
    (140) parameter_identifier_list -> identifier_list . , ELIPSIS
    (142) identifier_list -> identifier_list . , identifier

    )               reduce using rule 139 (parameter_identifier_list -> identifier_list .)
    ,               shift and go to state 166



state 75

    (143) parameter_type_list -> parameter_list .
    (144) parameter_type_list -> parameter_list . , ELIPSIS
    (146) parameter_list -> parameter_list . , parameter_declaration

    )               reduce using rule 143 (parameter_type_list -> parameter_list .)
    ,               shift and go to state 167



state 76

    (141) identifier_list -> identifier .

    ,               reduce using rule 141 (identifier_list -> identifier .)
    )               reduce using rule 141 (identifier_list -> identifier .)



state 77

    (36) shift_expr -> additive_expr .
    (34) additive_expr -> additive_expr . + multiplicative_expr
    (35) additive_expr -> additive_expr . - multiplicative_expr

    LEFT_OP         reduce using rule 36 (shift_expr -> additive_expr .)
    RIGHT_OP        reduce using rule 36 (shift_expr -> additive_expr .)
    <               reduce using rule 36 (shift_expr -> additive_expr .)
    >               reduce using rule 36 (shift_expr -> additive_expr .)
    LE_OP           reduce using rule 36 (shift_expr -> additive_expr .)
    GE_OP           reduce using rule 36 (shift_expr -> additive_expr .)
    EQ_OP           reduce using rule 36 (shift_expr -> additive_expr .)
    NE_OP           reduce using rule 36 (shift_expr -> additive_expr .)
    &               reduce using rule 36 (shift_expr -> additive_expr .)
    ^               reduce using rule 36 (shift_expr -> additive_expr .)
    |               reduce using rule 36 (shift_expr -> additive_expr .)
    AND_OP          reduce using rule 36 (shift_expr -> additive_expr .)
    ?               reduce using rule 36 (shift_expr -> additive_expr .)
    OR_OP           reduce using rule 36 (shift_expr -> additive_expr .)
    ]               reduce using rule 36 (shift_expr -> additive_expr .)
    ;               reduce using rule 36 (shift_expr -> additive_expr .)
    ,               reduce using rule 36 (shift_expr -> additive_expr .)
    )               reduce using rule 36 (shift_expr -> additive_expr .)
                    reduce using rule 36 (shift_expr -> additive_expr .)
    :               reduce using rule 36 (shift_expr -> additive_expr .)
    }               reduce using rule 36 (shift_expr -> additive_expr .)
    +               shift and go to state 168
    -               shift and go to state 169



state 78

    (2) primary_expr -> CONSTANT .

    [               reduce using rule 2 (primary_expr -> CONSTANT .)
    (               reduce using rule 2 (primary_expr -> CONSTANT .)
    .               reduce using rule 2 (primary_expr -> CONSTANT .)
    PTR_OP          reduce using rule 2 (primary_expr -> CONSTANT .)
    INC_OP          reduce using rule 2 (primary_expr -> CONSTANT .)
    DEC_OP          reduce using rule 2 (primary_expr -> CONSTANT .)
    *               reduce using rule 2 (primary_expr -> CONSTANT .)
    /               reduce using rule 2 (primary_expr -> CONSTANT .)
    %               reduce using rule 2 (primary_expr -> CONSTANT .)
    +               reduce using rule 2 (primary_expr -> CONSTANT .)
    -               reduce using rule 2 (primary_expr -> CONSTANT .)
    LEFT_OP         reduce using rule 2 (primary_expr -> CONSTANT .)
    RIGHT_OP        reduce using rule 2 (primary_expr -> CONSTANT .)
    <               reduce using rule 2 (primary_expr -> CONSTANT .)
    >               reduce using rule 2 (primary_expr -> CONSTANT .)
    LE_OP           reduce using rule 2 (primary_expr -> CONSTANT .)
    GE_OP           reduce using rule 2 (primary_expr -> CONSTANT .)
    EQ_OP           reduce using rule 2 (primary_expr -> CONSTANT .)
    NE_OP           reduce using rule 2 (primary_expr -> CONSTANT .)
    &               reduce using rule 2 (primary_expr -> CONSTANT .)
    ^               reduce using rule 2 (primary_expr -> CONSTANT .)
    |               reduce using rule 2 (primary_expr -> CONSTANT .)
    AND_OP          reduce using rule 2 (primary_expr -> CONSTANT .)
    ?               reduce using rule 2 (primary_expr -> CONSTANT .)
    OR_OP           reduce using rule 2 (primary_expr -> CONSTANT .)
    ]               reduce using rule 2 (primary_expr -> CONSTANT .)
    ;               reduce using rule 2 (primary_expr -> CONSTANT .)
    ,               reduce using rule 2 (primary_expr -> CONSTANT .)
    )               reduce using rule 2 (primary_expr -> CONSTANT .)
                    reduce using rule 2 (primary_expr -> CONSTANT .)
    :               reduce using rule 2 (primary_expr -> CONSTANT .)
    }               reduce using rule 2 (primary_expr -> CONSTANT .)
    =               reduce using rule 2 (primary_expr -> CONSTANT .)
    MUL_ASSIGN      reduce using rule 2 (primary_expr -> CONSTANT .)
    DIV_ASSIGN      reduce using rule 2 (primary_expr -> CONSTANT .)
    MOD_ASSIGN      reduce using rule 2 (primary_expr -> CONSTANT .)
    ADD_ASSIGN      reduce using rule 2 (primary_expr -> CONSTANT .)
    SUB_ASSIGN      reduce using rule 2 (primary_expr -> CONSTANT .)
    LEFT_ASSIGN     reduce using rule 2 (primary_expr -> CONSTANT .)
    RIGHT_ASSIGN    reduce using rule 2 (primary_expr -> CONSTANT .)
    AND_ASSIGN      reduce using rule 2 (primary_expr -> CONSTANT .)
    XOR_ASSIGN      reduce using rule 2 (primary_expr -> CONSTANT .)
    OR_ASSIGN       reduce using rule 2 (primary_expr -> CONSTANT .)



state 79

    (27) cast_expr -> unary_expr .

    *               reduce using rule 27 (cast_expr -> unary_expr .)
    /               reduce using rule 27 (cast_expr -> unary_expr .)
    %               reduce using rule 27 (cast_expr -> unary_expr .)
    +               reduce using rule 27 (cast_expr -> unary_expr .)
    -               reduce using rule 27 (cast_expr -> unary_expr .)
    LEFT_OP         reduce using rule 27 (cast_expr -> unary_expr .)
    RIGHT_OP        reduce using rule 27 (cast_expr -> unary_expr .)
    <               reduce using rule 27 (cast_expr -> unary_expr .)
    >               reduce using rule 27 (cast_expr -> unary_expr .)
    LE_OP           reduce using rule 27 (cast_expr -> unary_expr .)
    GE_OP           reduce using rule 27 (cast_expr -> unary_expr .)
    EQ_OP           reduce using rule 27 (cast_expr -> unary_expr .)
    NE_OP           reduce using rule 27 (cast_expr -> unary_expr .)
    &               reduce using rule 27 (cast_expr -> unary_expr .)
    ^               reduce using rule 27 (cast_expr -> unary_expr .)
    |               reduce using rule 27 (cast_expr -> unary_expr .)
    AND_OP          reduce using rule 27 (cast_expr -> unary_expr .)
    ?               reduce using rule 27 (cast_expr -> unary_expr .)
    OR_OP           reduce using rule 27 (cast_expr -> unary_expr .)
    ]               reduce using rule 27 (cast_expr -> unary_expr .)
    ;               reduce using rule 27 (cast_expr -> unary_expr .)
    ,               reduce using rule 27 (cast_expr -> unary_expr .)
    )               reduce using rule 27 (cast_expr -> unary_expr .)
                    reduce using rule 27 (cast_expr -> unary_expr .)
    :               reduce using rule 27 (cast_expr -> unary_expr .)
    }               reduce using rule 27 (cast_expr -> unary_expr .)
    =               reduce using rule 27 (cast_expr -> unary_expr .)
    MUL_ASSIGN      reduce using rule 27 (cast_expr -> unary_expr .)
    DIV_ASSIGN      reduce using rule 27 (cast_expr -> unary_expr .)
    MOD_ASSIGN      reduce using rule 27 (cast_expr -> unary_expr .)
    ADD_ASSIGN      reduce using rule 27 (cast_expr -> unary_expr .)
    SUB_ASSIGN      reduce using rule 27 (cast_expr -> unary_expr .)
    LEFT_ASSIGN     reduce using rule 27 (cast_expr -> unary_expr .)
    RIGHT_ASSIGN    reduce using rule 27 (cast_expr -> unary_expr .)
    AND_ASSIGN      reduce using rule 27 (cast_expr -> unary_expr .)
    XOR_ASSIGN      reduce using rule 27 (cast_expr -> unary_expr .)
    OR_ASSIGN       reduce using rule 27 (cast_expr -> unary_expr .)



state 80

    (17) unary_expr -> DEC_OP . unary_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 171
    IDENTIFIER      shift and go to state 21


    postfix_expr                   shift and go to state 99
    unary_expr                     shift and go to state 170
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 81

    (24) unary_operator -> - .

    (               reduce using rule 24 (unary_operator -> - .)
    INC_OP          reduce using rule 24 (unary_operator -> - .)
    DEC_OP          reduce using rule 24 (unary_operator -> - .)
    SIZEOF          reduce using rule 24 (unary_operator -> - .)
    &               reduce using rule 24 (unary_operator -> - .)
    *               reduce using rule 24 (unary_operator -> - .)
    +               reduce using rule 24 (unary_operator -> - .)
    -               reduce using rule 24 (unary_operator -> - .)
    ~               reduce using rule 24 (unary_operator -> - .)
    !               reduce using rule 24 (unary_operator -> - .)
    CONSTANT        reduce using rule 24 (unary_operator -> - .)
    STRING_LITERAL  reduce using rule 24 (unary_operator -> - .)
    IDENTIFIER      reduce using rule 24 (unary_operator -> - .)



state 82

    (129) declarator2 -> declarator2 [ constant_expr . ]

    ]               shift and go to state 172



state 83

    (22) unary_operator -> * .

    (               reduce using rule 22 (unary_operator -> * .)
    INC_OP          reduce using rule 22 (unary_operator -> * .)
    DEC_OP          reduce using rule 22 (unary_operator -> * .)
    SIZEOF          reduce using rule 22 (unary_operator -> * .)
    &               reduce using rule 22 (unary_operator -> * .)
    *               reduce using rule 22 (unary_operator -> * .)
    +               reduce using rule 22 (unary_operator -> * .)
    -               reduce using rule 22 (unary_operator -> * .)
    ~               reduce using rule 22 (unary_operator -> * .)
    !               reduce using rule 22 (unary_operator -> * .)
    CONSTANT        reduce using rule 22 (unary_operator -> * .)
    STRING_LITERAL  reduce using rule 22 (unary_operator -> * .)
    IDENTIFIER      reduce using rule 22 (unary_operator -> * .)



state 84

    (57) conditional_expr -> logical_or_expr .
    (58) conditional_expr -> logical_or_expr . ? logical_or_expr : conditional_expr
    (56) logical_or_expr -> logical_or_expr . OR_OP logical_and_expr

                    reduce using rule 57 (conditional_expr -> logical_or_expr .)
    ,               reduce using rule 57 (conditional_expr -> logical_or_expr .)
    ]               reduce using rule 57 (conditional_expr -> logical_or_expr .)
    )               reduce using rule 57 (conditional_expr -> logical_or_expr .)
    ;               reduce using rule 57 (conditional_expr -> logical_or_expr .)
    }               reduce using rule 57 (conditional_expr -> logical_or_expr .)
    :               reduce using rule 57 (conditional_expr -> logical_or_expr .)
    ?               shift and go to state 174
    OR_OP           shift and go to state 173



state 85

    (19) unary_expr -> SIZEOF . unary_expr
    (20) unary_expr -> SIZEOF . ( type_name )
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 176
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    postfix_expr                   shift and go to state 99
    unary_expr                     shift and go to state 175
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 86

    (26) unary_operator -> ! .

    (               reduce using rule 26 (unary_operator -> ! .)
    INC_OP          reduce using rule 26 (unary_operator -> ! .)
    DEC_OP          reduce using rule 26 (unary_operator -> ! .)
    SIZEOF          reduce using rule 26 (unary_operator -> ! .)
    &               reduce using rule 26 (unary_operator -> ! .)
    *               reduce using rule 26 (unary_operator -> ! .)
    +               reduce using rule 26 (unary_operator -> ! .)
    -               reduce using rule 26 (unary_operator -> ! .)
    ~               reduce using rule 26 (unary_operator -> ! .)
    !               reduce using rule 26 (unary_operator -> ! .)
    CONSTANT        reduce using rule 26 (unary_operator -> ! .)
    STRING_LITERAL  reduce using rule 26 (unary_operator -> ! .)
    IDENTIFIER      reduce using rule 26 (unary_operator -> ! .)



state 87

    (21) unary_operator -> & .

    (               reduce using rule 21 (unary_operator -> & .)
    INC_OP          reduce using rule 21 (unary_operator -> & .)
    DEC_OP          reduce using rule 21 (unary_operator -> & .)
    SIZEOF          reduce using rule 21 (unary_operator -> & .)
    &               reduce using rule 21 (unary_operator -> & .)
    *               reduce using rule 21 (unary_operator -> & .)
    +               reduce using rule 21 (unary_operator -> & .)
    -               reduce using rule 21 (unary_operator -> & .)
    ~               reduce using rule 21 (unary_operator -> & .)
    !               reduce using rule 21 (unary_operator -> & .)
    CONSTANT        reduce using rule 21 (unary_operator -> & .)
    STRING_LITERAL  reduce using rule 21 (unary_operator -> & .)
    IDENTIFIER      reduce using rule 21 (unary_operator -> & .)



state 88

    (28) cast_expr -> ( . type_name ) cast_expr
    (4) primary_expr -> ( . expr )
    (149) type_name -> . type_specifier_list
    (150) type_name -> . type_specifier_list abstract_declarator
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    ENUM            shift and go to state 24
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    equality_expr                  shift and go to state 90
    unary_expr                     shift and go to state 133
    struct_or_union_specifier      shift and go to state 4
    logical_or_expr                shift and go to state 84
    additive_expr                  shift and go to state 77
    type_specifier                 shift and go to state 48
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    type_name                      shift and go to state 177
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    struct_or_union                shift and go to state 6
    relational_expr                shift and go to state 94
    type_specifier_list            shift and go to state 178
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    enum_specifier                 shift and go to state 33
    expr                           shift and go to state 179
    logical_and_expr               shift and go to state 102
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 89

    (23) unary_operator -> + .

    (               reduce using rule 23 (unary_operator -> + .)
    INC_OP          reduce using rule 23 (unary_operator -> + .)
    DEC_OP          reduce using rule 23 (unary_operator -> + .)
    SIZEOF          reduce using rule 23 (unary_operator -> + .)
    &               reduce using rule 23 (unary_operator -> + .)
    *               reduce using rule 23 (unary_operator -> + .)
    +               reduce using rule 23 (unary_operator -> + .)
    -               reduce using rule 23 (unary_operator -> + .)
    ~               reduce using rule 23 (unary_operator -> + .)
    !               reduce using rule 23 (unary_operator -> + .)
    CONSTANT        reduce using rule 23 (unary_operator -> + .)
    STRING_LITERAL  reduce using rule 23 (unary_operator -> + .)
    IDENTIFIER      reduce using rule 23 (unary_operator -> + .)



state 90

    (47) and_expr -> equality_expr .
    (45) equality_expr -> equality_expr . EQ_OP relational_expr
    (46) equality_expr -> equality_expr . NE_OP relational_expr

    &               reduce using rule 47 (and_expr -> equality_expr .)
    ^               reduce using rule 47 (and_expr -> equality_expr .)
    |               reduce using rule 47 (and_expr -> equality_expr .)
    AND_OP          reduce using rule 47 (and_expr -> equality_expr .)
    ?               reduce using rule 47 (and_expr -> equality_expr .)
    OR_OP           reduce using rule 47 (and_expr -> equality_expr .)
    ;               reduce using rule 47 (and_expr -> equality_expr .)
    ,               reduce using rule 47 (and_expr -> equality_expr .)
    ]               reduce using rule 47 (and_expr -> equality_expr .)
    )               reduce using rule 47 (and_expr -> equality_expr .)
                    reduce using rule 47 (and_expr -> equality_expr .)
    :               reduce using rule 47 (and_expr -> equality_expr .)
    }               reduce using rule 47 (and_expr -> equality_expr .)
    EQ_OP           shift and go to state 180
    NE_OP           shift and go to state 181



state 91

    (39) relational_expr -> shift_expr .
    (37) shift_expr -> shift_expr . LEFT_OP additive_expr
    (38) shift_expr -> shift_expr . RIGHT_OP additive_expr

    <               reduce using rule 39 (relational_expr -> shift_expr .)
    >               reduce using rule 39 (relational_expr -> shift_expr .)
    LE_OP           reduce using rule 39 (relational_expr -> shift_expr .)
    GE_OP           reduce using rule 39 (relational_expr -> shift_expr .)
    EQ_OP           reduce using rule 39 (relational_expr -> shift_expr .)
    NE_OP           reduce using rule 39 (relational_expr -> shift_expr .)
    &               reduce using rule 39 (relational_expr -> shift_expr .)
    ^               reduce using rule 39 (relational_expr -> shift_expr .)
    |               reduce using rule 39 (relational_expr -> shift_expr .)
    AND_OP          reduce using rule 39 (relational_expr -> shift_expr .)
    ?               reduce using rule 39 (relational_expr -> shift_expr .)
    OR_OP           reduce using rule 39 (relational_expr -> shift_expr .)
    ;               reduce using rule 39 (relational_expr -> shift_expr .)
    ,               reduce using rule 39 (relational_expr -> shift_expr .)
    )               reduce using rule 39 (relational_expr -> shift_expr .)
    ]               reduce using rule 39 (relational_expr -> shift_expr .)
                    reduce using rule 39 (relational_expr -> shift_expr .)
    :               reduce using rule 39 (relational_expr -> shift_expr .)
    }               reduce using rule 39 (relational_expr -> shift_expr .)
    LEFT_OP         shift and go to state 182
    RIGHT_OP        shift and go to state 183



state 92

    (33) additive_expr -> multiplicative_expr .
    (30) multiplicative_expr -> multiplicative_expr . * cast_expr
    (31) multiplicative_expr -> multiplicative_expr . / cast_expr
    (32) multiplicative_expr -> multiplicative_expr . % cast_expr

    +               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    -               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    LEFT_OP         reduce using rule 33 (additive_expr -> multiplicative_expr .)
    RIGHT_OP        reduce using rule 33 (additive_expr -> multiplicative_expr .)
    <               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    >               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    LE_OP           reduce using rule 33 (additive_expr -> multiplicative_expr .)
    GE_OP           reduce using rule 33 (additive_expr -> multiplicative_expr .)
    EQ_OP           reduce using rule 33 (additive_expr -> multiplicative_expr .)
    NE_OP           reduce using rule 33 (additive_expr -> multiplicative_expr .)
    &               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    ^               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    |               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    AND_OP          reduce using rule 33 (additive_expr -> multiplicative_expr .)
    ?               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    OR_OP           reduce using rule 33 (additive_expr -> multiplicative_expr .)
    ;               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    ,               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    }               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    ]               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    )               reduce using rule 33 (additive_expr -> multiplicative_expr .)
                    reduce using rule 33 (additive_expr -> multiplicative_expr .)
    :               reduce using rule 33 (additive_expr -> multiplicative_expr .)
    *               shift and go to state 185
    /               shift and go to state 186
    %               shift and go to state 184



state 93

    (49) exclusive_or_expr -> and_expr .
    (48) and_expr -> and_expr . & equality_expr

    ^               reduce using rule 49 (exclusive_or_expr -> and_expr .)
    |               reduce using rule 49 (exclusive_or_expr -> and_expr .)
    AND_OP          reduce using rule 49 (exclusive_or_expr -> and_expr .)
    ?               reduce using rule 49 (exclusive_or_expr -> and_expr .)
    OR_OP           reduce using rule 49 (exclusive_or_expr -> and_expr .)
    )               reduce using rule 49 (exclusive_or_expr -> and_expr .)
    ,               reduce using rule 49 (exclusive_or_expr -> and_expr .)
    ;               reduce using rule 49 (exclusive_or_expr -> and_expr .)
    }               reduce using rule 49 (exclusive_or_expr -> and_expr .)
    ]               reduce using rule 49 (exclusive_or_expr -> and_expr .)
                    reduce using rule 49 (exclusive_or_expr -> and_expr .)
    :               reduce using rule 49 (exclusive_or_expr -> and_expr .)
    &               shift and go to state 187



state 94

    (44) equality_expr -> relational_expr .
    (40) relational_expr -> relational_expr . < shift_expr
    (41) relational_expr -> relational_expr . > shift_expr
    (42) relational_expr -> relational_expr . LE_OP shift_expr
    (43) relational_expr -> relational_expr . GE_OP shift_expr

    EQ_OP           reduce using rule 44 (equality_expr -> relational_expr .)
    NE_OP           reduce using rule 44 (equality_expr -> relational_expr .)
    &               reduce using rule 44 (equality_expr -> relational_expr .)
    ^               reduce using rule 44 (equality_expr -> relational_expr .)
    |               reduce using rule 44 (equality_expr -> relational_expr .)
    AND_OP          reduce using rule 44 (equality_expr -> relational_expr .)
    ?               reduce using rule 44 (equality_expr -> relational_expr .)
    OR_OP           reduce using rule 44 (equality_expr -> relational_expr .)
    ;               reduce using rule 44 (equality_expr -> relational_expr .)
    ,               reduce using rule 44 (equality_expr -> relational_expr .)
                    reduce using rule 44 (equality_expr -> relational_expr .)
    ]               reduce using rule 44 (equality_expr -> relational_expr .)
    )               reduce using rule 44 (equality_expr -> relational_expr .)
    :               reduce using rule 44 (equality_expr -> relational_expr .)
    }               reduce using rule 44 (equality_expr -> relational_expr .)
    <               shift and go to state 190
    >               shift and go to state 191
    LE_OP           shift and go to state 188
    GE_OP           shift and go to state 189



state 95

    (29) multiplicative_expr -> cast_expr .

    *               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    /               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    %               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    +               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    -               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    LEFT_OP         reduce using rule 29 (multiplicative_expr -> cast_expr .)
    RIGHT_OP        reduce using rule 29 (multiplicative_expr -> cast_expr .)
    <               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    >               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    LE_OP           reduce using rule 29 (multiplicative_expr -> cast_expr .)
    GE_OP           reduce using rule 29 (multiplicative_expr -> cast_expr .)
    EQ_OP           reduce using rule 29 (multiplicative_expr -> cast_expr .)
    NE_OP           reduce using rule 29 (multiplicative_expr -> cast_expr .)
    &               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    ^               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    |               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    AND_OP          reduce using rule 29 (multiplicative_expr -> cast_expr .)
    ?               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    OR_OP           reduce using rule 29 (multiplicative_expr -> cast_expr .)
    }               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    ,               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    ]               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    ;               reduce using rule 29 (multiplicative_expr -> cast_expr .)
    )               reduce using rule 29 (multiplicative_expr -> cast_expr .)
                    reduce using rule 29 (multiplicative_expr -> cast_expr .)
    :               reduce using rule 29 (multiplicative_expr -> cast_expr .)



state 96

    (128) declarator2 -> declarator2 [ ] .

    [               reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    (               reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    {               reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    TYPEDEF         reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    EXTERN          reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    STATIC          reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    AUTO            reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    REGISTER        reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    CHAR            reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    SHORT           reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    INT             reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    LONG            reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    SIGNED          reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    UNSIGNED        reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    FLOAT           reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    DOUBLE          reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    CONST           reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    VOLATILE        reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    VOID            reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    TYPE_NAME       reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    ENUM            reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    STRUCT          reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    UNION           reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    )               reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    =               reduce using rule 128 (declarator2 -> declarator2 [ ] .)
                    reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    ,               reduce using rule 128 (declarator2 -> declarator2 [ ] .)
    :               reduce using rule 128 (declarator2 -> declarator2 [ ] .)



state 97

    (74) constant_expr -> conditional_expr .

    ]               reduce using rule 74 (constant_expr -> conditional_expr .)
    }               reduce using rule 74 (constant_expr -> conditional_expr .)
    ,               reduce using rule 74 (constant_expr -> conditional_expr .)
                    reduce using rule 74 (constant_expr -> conditional_expr .)
    :               reduce using rule 74 (constant_expr -> conditional_expr .)



state 98

    (1) primary_expr -> identifier .

    [               reduce using rule 1 (primary_expr -> identifier .)
    (               reduce using rule 1 (primary_expr -> identifier .)
    .               reduce using rule 1 (primary_expr -> identifier .)
    PTR_OP          reduce using rule 1 (primary_expr -> identifier .)
    INC_OP          reduce using rule 1 (primary_expr -> identifier .)
    DEC_OP          reduce using rule 1 (primary_expr -> identifier .)
    *               reduce using rule 1 (primary_expr -> identifier .)
    /               reduce using rule 1 (primary_expr -> identifier .)
    %               reduce using rule 1 (primary_expr -> identifier .)
    +               reduce using rule 1 (primary_expr -> identifier .)
    -               reduce using rule 1 (primary_expr -> identifier .)
    LEFT_OP         reduce using rule 1 (primary_expr -> identifier .)
    RIGHT_OP        reduce using rule 1 (primary_expr -> identifier .)
    <               reduce using rule 1 (primary_expr -> identifier .)
    >               reduce using rule 1 (primary_expr -> identifier .)
    LE_OP           reduce using rule 1 (primary_expr -> identifier .)
    GE_OP           reduce using rule 1 (primary_expr -> identifier .)
    EQ_OP           reduce using rule 1 (primary_expr -> identifier .)
    NE_OP           reduce using rule 1 (primary_expr -> identifier .)
    &               reduce using rule 1 (primary_expr -> identifier .)
    ^               reduce using rule 1 (primary_expr -> identifier .)
    |               reduce using rule 1 (primary_expr -> identifier .)
    AND_OP          reduce using rule 1 (primary_expr -> identifier .)
    ?               reduce using rule 1 (primary_expr -> identifier .)
    OR_OP           reduce using rule 1 (primary_expr -> identifier .)
    ]               reduce using rule 1 (primary_expr -> identifier .)
    ;               reduce using rule 1 (primary_expr -> identifier .)
    ,               reduce using rule 1 (primary_expr -> identifier .)
    )               reduce using rule 1 (primary_expr -> identifier .)
                    reduce using rule 1 (primary_expr -> identifier .)
    :               reduce using rule 1 (primary_expr -> identifier .)
    }               reduce using rule 1 (primary_expr -> identifier .)
    =               reduce using rule 1 (primary_expr -> identifier .)
    MUL_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    DIV_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    MOD_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    ADD_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    SUB_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    LEFT_ASSIGN     reduce using rule 1 (primary_expr -> identifier .)
    RIGHT_ASSIGN    reduce using rule 1 (primary_expr -> identifier .)
    AND_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    XOR_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    OR_ASSIGN       reduce using rule 1 (primary_expr -> identifier .)



state 99

    (15) unary_expr -> postfix_expr .
    (6) postfix_expr -> postfix_expr . [ expr ]
    (7) postfix_expr -> postfix_expr . ( )
    (8) postfix_expr -> postfix_expr . ( argument_expr_list )
    (9) postfix_expr -> postfix_expr . . identifier
    (10) postfix_expr -> postfix_expr . PTR_OP identifier
    (11) postfix_expr -> postfix_expr . INC_OP
    (12) postfix_expr -> postfix_expr . DEC_OP

    =               reduce using rule 15 (unary_expr -> postfix_expr .)
    MUL_ASSIGN      reduce using rule 15 (unary_expr -> postfix_expr .)
    DIV_ASSIGN      reduce using rule 15 (unary_expr -> postfix_expr .)
    MOD_ASSIGN      reduce using rule 15 (unary_expr -> postfix_expr .)
    ADD_ASSIGN      reduce using rule 15 (unary_expr -> postfix_expr .)
    SUB_ASSIGN      reduce using rule 15 (unary_expr -> postfix_expr .)
    LEFT_ASSIGN     reduce using rule 15 (unary_expr -> postfix_expr .)
    RIGHT_ASSIGN    reduce using rule 15 (unary_expr -> postfix_expr .)
    AND_ASSIGN      reduce using rule 15 (unary_expr -> postfix_expr .)
    XOR_ASSIGN      reduce using rule 15 (unary_expr -> postfix_expr .)
    OR_ASSIGN       reduce using rule 15 (unary_expr -> postfix_expr .)
    *               reduce using rule 15 (unary_expr -> postfix_expr .)
    /               reduce using rule 15 (unary_expr -> postfix_expr .)
    %               reduce using rule 15 (unary_expr -> postfix_expr .)
    +               reduce using rule 15 (unary_expr -> postfix_expr .)
    -               reduce using rule 15 (unary_expr -> postfix_expr .)
    LEFT_OP         reduce using rule 15 (unary_expr -> postfix_expr .)
    RIGHT_OP        reduce using rule 15 (unary_expr -> postfix_expr .)
    <               reduce using rule 15 (unary_expr -> postfix_expr .)
    >               reduce using rule 15 (unary_expr -> postfix_expr .)
    LE_OP           reduce using rule 15 (unary_expr -> postfix_expr .)
    GE_OP           reduce using rule 15 (unary_expr -> postfix_expr .)
    EQ_OP           reduce using rule 15 (unary_expr -> postfix_expr .)
    NE_OP           reduce using rule 15 (unary_expr -> postfix_expr .)
    &               reduce using rule 15 (unary_expr -> postfix_expr .)
    ^               reduce using rule 15 (unary_expr -> postfix_expr .)
    |               reduce using rule 15 (unary_expr -> postfix_expr .)
    AND_OP          reduce using rule 15 (unary_expr -> postfix_expr .)
    ?               reduce using rule 15 (unary_expr -> postfix_expr .)
    OR_OP           reduce using rule 15 (unary_expr -> postfix_expr .)
    ;               reduce using rule 15 (unary_expr -> postfix_expr .)
    ,               reduce using rule 15 (unary_expr -> postfix_expr .)
    )               reduce using rule 15 (unary_expr -> postfix_expr .)
                    reduce using rule 15 (unary_expr -> postfix_expr .)
    :               reduce using rule 15 (unary_expr -> postfix_expr .)
    ]               reduce using rule 15 (unary_expr -> postfix_expr .)
    }               reduce using rule 15 (unary_expr -> postfix_expr .)
    [               shift and go to state 197
    (               shift and go to state 196
    .               shift and go to state 193
    PTR_OP          shift and go to state 195
    INC_OP          shift and go to state 194
    DEC_OP          shift and go to state 192



state 100

    (3) primary_expr -> STRING_LITERAL .

    [               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    (               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    .               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    PTR_OP          reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    INC_OP          reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    DEC_OP          reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    *               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    /               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    %               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    +               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    -               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    LEFT_OP         reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    RIGHT_OP        reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    <               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    >               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    LE_OP           reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    GE_OP           reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    EQ_OP           reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    NE_OP           reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    &               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    ^               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    |               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    AND_OP          reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    ?               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    OR_OP           reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    ]               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    ;               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    ,               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    )               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
                    reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    :               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    }               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    =               reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    MUL_ASSIGN      reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    DIV_ASSIGN      reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    MOD_ASSIGN      reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    ADD_ASSIGN      reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    SUB_ASSIGN      reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    LEFT_ASSIGN     reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    RIGHT_ASSIGN    reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    AND_ASSIGN      reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    XOR_ASSIGN      reduce using rule 3 (primary_expr -> STRING_LITERAL .)
    OR_ASSIGN       reduce using rule 3 (primary_expr -> STRING_LITERAL .)



state 101

    (51) inclusive_or_expr -> exclusive_or_expr .
    (50) exclusive_or_expr -> exclusive_or_expr . ^ and_expr

    |               reduce using rule 51 (inclusive_or_expr -> exclusive_or_expr .)
    AND_OP          reduce using rule 51 (inclusive_or_expr -> exclusive_or_expr .)
    ?               reduce using rule 51 (inclusive_or_expr -> exclusive_or_expr .)
    OR_OP           reduce using rule 51 (inclusive_or_expr -> exclusive_or_expr .)
    ;               reduce using rule 51 (inclusive_or_expr -> exclusive_or_expr .)
    ,               reduce using rule 51 (inclusive_or_expr -> exclusive_or_expr .)
    }               reduce using rule 51 (inclusive_or_expr -> exclusive_or_expr .)
    )               reduce using rule 51 (inclusive_or_expr -> exclusive_or_expr .)
    ]               reduce using rule 51 (inclusive_or_expr -> exclusive_or_expr .)
                    reduce using rule 51 (inclusive_or_expr -> exclusive_or_expr .)
    :               reduce using rule 51 (inclusive_or_expr -> exclusive_or_expr .)
    ^               shift and go to state 198



state 102

    (55) logical_or_expr -> logical_and_expr .
    (54) logical_and_expr -> logical_and_expr . AND_OP inclusive_or_expr

    ?               reduce using rule 55 (logical_or_expr -> logical_and_expr .)
    OR_OP           reduce using rule 55 (logical_or_expr -> logical_and_expr .)
    ;               reduce using rule 55 (logical_or_expr -> logical_and_expr .)
    ,               reduce using rule 55 (logical_or_expr -> logical_and_expr .)
    )               reduce using rule 55 (logical_or_expr -> logical_and_expr .)
                    reduce using rule 55 (logical_or_expr -> logical_and_expr .)
    ]               reduce using rule 55 (logical_or_expr -> logical_and_expr .)
    }               reduce using rule 55 (logical_or_expr -> logical_and_expr .)
    :               reduce using rule 55 (logical_or_expr -> logical_and_expr .)
    AND_OP          shift and go to state 199



state 103

    (53) logical_and_expr -> inclusive_or_expr .
    (52) inclusive_or_expr -> inclusive_or_expr . | exclusive_or_expr

    AND_OP          reduce using rule 53 (logical_and_expr -> inclusive_or_expr .)
    ?               reduce using rule 53 (logical_and_expr -> inclusive_or_expr .)
    OR_OP           reduce using rule 53 (logical_and_expr -> inclusive_or_expr .)
    )               reduce using rule 53 (logical_and_expr -> inclusive_or_expr .)
    ,               reduce using rule 53 (logical_and_expr -> inclusive_or_expr .)
    ;               reduce using rule 53 (logical_and_expr -> inclusive_or_expr .)
                    reduce using rule 53 (logical_and_expr -> inclusive_or_expr .)
    :               reduce using rule 53 (logical_and_expr -> inclusive_or_expr .)
    ]               reduce using rule 53 (logical_and_expr -> inclusive_or_expr .)
    }               reduce using rule 53 (logical_and_expr -> inclusive_or_expr .)
    |               shift and go to state 200



state 104

    (5) postfix_expr -> primary_expr .

    [               reduce using rule 5 (postfix_expr -> primary_expr .)
    (               reduce using rule 5 (postfix_expr -> primary_expr .)
    .               reduce using rule 5 (postfix_expr -> primary_expr .)
    PTR_OP          reduce using rule 5 (postfix_expr -> primary_expr .)
    INC_OP          reduce using rule 5 (postfix_expr -> primary_expr .)
    DEC_OP          reduce using rule 5 (postfix_expr -> primary_expr .)
    =               reduce using rule 5 (postfix_expr -> primary_expr .)
    MUL_ASSIGN      reduce using rule 5 (postfix_expr -> primary_expr .)
    DIV_ASSIGN      reduce using rule 5 (postfix_expr -> primary_expr .)
    MOD_ASSIGN      reduce using rule 5 (postfix_expr -> primary_expr .)
    ADD_ASSIGN      reduce using rule 5 (postfix_expr -> primary_expr .)
    SUB_ASSIGN      reduce using rule 5 (postfix_expr -> primary_expr .)
    LEFT_ASSIGN     reduce using rule 5 (postfix_expr -> primary_expr .)
    RIGHT_ASSIGN    reduce using rule 5 (postfix_expr -> primary_expr .)
    AND_ASSIGN      reduce using rule 5 (postfix_expr -> primary_expr .)
    XOR_ASSIGN      reduce using rule 5 (postfix_expr -> primary_expr .)
    OR_ASSIGN       reduce using rule 5 (postfix_expr -> primary_expr .)
    *               reduce using rule 5 (postfix_expr -> primary_expr .)
    /               reduce using rule 5 (postfix_expr -> primary_expr .)
    %               reduce using rule 5 (postfix_expr -> primary_expr .)
    +               reduce using rule 5 (postfix_expr -> primary_expr .)
    -               reduce using rule 5 (postfix_expr -> primary_expr .)
    LEFT_OP         reduce using rule 5 (postfix_expr -> primary_expr .)
    RIGHT_OP        reduce using rule 5 (postfix_expr -> primary_expr .)
    <               reduce using rule 5 (postfix_expr -> primary_expr .)
    >               reduce using rule 5 (postfix_expr -> primary_expr .)
    LE_OP           reduce using rule 5 (postfix_expr -> primary_expr .)
    GE_OP           reduce using rule 5 (postfix_expr -> primary_expr .)
    EQ_OP           reduce using rule 5 (postfix_expr -> primary_expr .)
    NE_OP           reduce using rule 5 (postfix_expr -> primary_expr .)
    &               reduce using rule 5 (postfix_expr -> primary_expr .)
    ^               reduce using rule 5 (postfix_expr -> primary_expr .)
    |               reduce using rule 5 (postfix_expr -> primary_expr .)
    AND_OP          reduce using rule 5 (postfix_expr -> primary_expr .)
    ?               reduce using rule 5 (postfix_expr -> primary_expr .)
    OR_OP           reduce using rule 5 (postfix_expr -> primary_expr .)
    ;               reduce using rule 5 (postfix_expr -> primary_expr .)
    ,               reduce using rule 5 (postfix_expr -> primary_expr .)
    ]               reduce using rule 5 (postfix_expr -> primary_expr .)
    )               reduce using rule 5 (postfix_expr -> primary_expr .)
                    reduce using rule 5 (postfix_expr -> primary_expr .)
    :               reduce using rule 5 (postfix_expr -> primary_expr .)
    }               reduce using rule 5 (postfix_expr -> primary_expr .)



state 105

    (18) unary_expr -> unary_operator . cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 201
    postfix_expr                   shift and go to state 99
    unary_expr                     shift and go to state 79
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 106

    (16) unary_expr -> INC_OP . unary_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 171
    IDENTIFIER      shift and go to state 21


    postfix_expr                   shift and go to state 99
    unary_expr                     shift and go to state 202
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 107

    (25) unary_operator -> ~ .

    (               reduce using rule 25 (unary_operator -> ~ .)
    INC_OP          reduce using rule 25 (unary_operator -> ~ .)
    DEC_OP          reduce using rule 25 (unary_operator -> ~ .)
    SIZEOF          reduce using rule 25 (unary_operator -> ~ .)
    &               reduce using rule 25 (unary_operator -> ~ .)
    *               reduce using rule 25 (unary_operator -> ~ .)
    +               reduce using rule 25 (unary_operator -> ~ .)
    -               reduce using rule 25 (unary_operator -> ~ .)
    ~               reduce using rule 25 (unary_operator -> ~ .)
    !               reduce using rule 25 (unary_operator -> ~ .)
    CONSTANT        reduce using rule 25 (unary_operator -> ~ .)
    STRING_LITERAL  reduce using rule 25 (unary_operator -> ~ .)
    IDENTIFIER      reduce using rule 25 (unary_operator -> ~ .)



state 108

    (127) declarator2 -> ( declarator ) .

    [               reduce using rule 127 (declarator2 -> ( declarator ) .)
    (               reduce using rule 127 (declarator2 -> ( declarator ) .)
    {               reduce using rule 127 (declarator2 -> ( declarator ) .)
    TYPEDEF         reduce using rule 127 (declarator2 -> ( declarator ) .)
    EXTERN          reduce using rule 127 (declarator2 -> ( declarator ) .)
    STATIC          reduce using rule 127 (declarator2 -> ( declarator ) .)
    AUTO            reduce using rule 127 (declarator2 -> ( declarator ) .)
    REGISTER        reduce using rule 127 (declarator2 -> ( declarator ) .)
    CHAR            reduce using rule 127 (declarator2 -> ( declarator ) .)
    SHORT           reduce using rule 127 (declarator2 -> ( declarator ) .)
    INT             reduce using rule 127 (declarator2 -> ( declarator ) .)
    LONG            reduce using rule 127 (declarator2 -> ( declarator ) .)
    SIGNED          reduce using rule 127 (declarator2 -> ( declarator ) .)
    UNSIGNED        reduce using rule 127 (declarator2 -> ( declarator ) .)
    FLOAT           reduce using rule 127 (declarator2 -> ( declarator ) .)
    DOUBLE          reduce using rule 127 (declarator2 -> ( declarator ) .)
    CONST           reduce using rule 127 (declarator2 -> ( declarator ) .)
    VOLATILE        reduce using rule 127 (declarator2 -> ( declarator ) .)
    VOID            reduce using rule 127 (declarator2 -> ( declarator ) .)
    TYPE_NAME       reduce using rule 127 (declarator2 -> ( declarator ) .)
    ENUM            reduce using rule 127 (declarator2 -> ( declarator ) .)
    STRUCT          reduce using rule 127 (declarator2 -> ( declarator ) .)
    UNION           reduce using rule 127 (declarator2 -> ( declarator ) .)
    )               reduce using rule 127 (declarator2 -> ( declarator ) .)
    =               reduce using rule 127 (declarator2 -> ( declarator ) .)
                    reduce using rule 127 (declarator2 -> ( declarator ) .)
    ,               reduce using rule 127 (declarator2 -> ( declarator ) .)
    :               reduce using rule 127 (declarator2 -> ( declarator ) .)



state 109

    (136) pointer -> * type_specifier_list pointer .

    (               reduce using rule 136 (pointer -> * type_specifier_list pointer .)
    IDENTIFIER      reduce using rule 136 (pointer -> * type_specifier_list pointer .)
    [               reduce using rule 136 (pointer -> * type_specifier_list pointer .)
    ,               reduce using rule 136 (pointer -> * type_specifier_list pointer .)
    )               reduce using rule 136 (pointer -> * type_specifier_list pointer .)



state 110

    (138) type_specifier_list -> type_specifier_list type_specifier .

    CHAR            reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    SHORT           reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    INT             reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    LONG            reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    SIGNED          reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    UNSIGNED        reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    FLOAT           reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    DOUBLE          reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    CONST           reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    VOLATILE        reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    VOID            reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    TYPE_NAME       reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    :               reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    ENUM            reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    STRUCT          reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    UNION           reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    (               reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    *               reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    IDENTIFIER      reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    [               reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    ,               reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)
    )               reduce using rule 138 (type_specifier_list -> type_specifier_list type_specifier .)



state 111

    (118) enum_specifier -> ENUM identifier { . enumerator_list }
    (120) enumerator_list -> . enumerator
    (121) enumerator_list -> . enumerator_list , enumerator
    (122) enumerator -> . identifier
    (123) enumerator -> . identifier = constant_expr
    (216) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 21


    enumerator_list                shift and go to state 203
    identifier                     shift and go to state 114
    enumerator                     shift and go to state 112

state 112

    (120) enumerator_list -> enumerator .

    }               reduce using rule 120 (enumerator_list -> enumerator .)
    ,               reduce using rule 120 (enumerator_list -> enumerator .)



state 113

    (117) enum_specifier -> ENUM { enumerator_list . }
    (121) enumerator_list -> enumerator_list . , enumerator

    }               shift and go to state 205
    ,               shift and go to state 204



state 114

    (122) enumerator -> identifier .
    (123) enumerator -> identifier . = constant_expr

    }               reduce using rule 122 (enumerator -> identifier .)
    ,               reduce using rule 122 (enumerator -> identifier .)
    =               shift and go to state 206



state 115

    (213) function_definition -> declaration_specifiers declarator function_body .

    (               reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    *               reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    TYPEDEF         reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    EXTERN          reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    STATIC          reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    AUTO            reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    REGISTER        reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    CHAR            reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    SHORT           reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    INT             reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    LONG            reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    SIGNED          reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    UNSIGNED        reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    FLOAT           reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    DOUBLE          reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    CONST           reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    VOLATILE        reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    VOID            reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    TYPE_NAME       reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    IDENTIFIER      reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    ENUM            reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    STRUCT          reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    UNION           reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)
    $end            reduce using rule 213 (function_definition -> declaration_specifiers declarator function_body .)



state 116

    (84) init_declarator -> declarator = . initializer
    (163) initializer -> . assignment_expr
    (164) initializer -> . { initializer_list }
    (165) initializer -> . { initializer_list , }
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    {               shift and go to state 209
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    equality_expr                  shift and go to state 90
    unary_expr                     shift and go to state 133
    initializer                    shift and go to state 207
    logical_or_expr                shift and go to state 84
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    logical_and_expr               shift and go to state 102
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 208
    identifier                     shift and go to state 98

state 117

    (76) declaration -> declaration_specifiers init_declarator_list  .

    {               reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    TYPEDEF         reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    EXTERN          reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    STATIC          reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    AUTO            reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    REGISTER        reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    CHAR            reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    SHORT           reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    INT             reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    LONG            reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    SIGNED          reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    UNSIGNED        reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    FLOAT           reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    DOUBLE          reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    CONST           reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    VOLATILE        reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    VOID            reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    TYPE_NAME       reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    ENUM            reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    STRUCT          reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    UNION           reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    (               reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    *               reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    IDENTIFIER      reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    $end            reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    }               reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    CASE            reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    DEFAULT         reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    ;               reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    IF              reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    SWITCH          reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    WHILE           reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    DO              reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    FOR             reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    GOTO            reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    CONTINUE        reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    BREAK           reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    RETURN          reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    INC_OP          reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    DEC_OP          reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    SIZEOF          reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    &               reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    +               reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    -               reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    ~               reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    !               reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    CONSTANT        reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)
    STRING_LITERAL  reduce using rule 76 (declaration -> declaration_specifiers init_declarator_list  .)



state 118

    (82) init_declarator_list -> init_declarator_list , . init_declarator
    (83) init_declarator -> . declarator
    (84) init_declarator -> . declarator = initializer
    (124) declarator -> . declarator2
    (125) declarator -> . pointer declarator2
    (126) declarator2 -> . identifier
    (127) declarator2 -> . ( declarator )
    (128) declarator2 -> . declarator2 [ ]
    (129) declarator2 -> . declarator2 [ constant_expr ]
    (130) declarator2 -> . declarator2 ( )
    (131) declarator2 -> . declarator2 ( parameter_type_list )
    (132) declarator2 -> . declarator2 ( parameter_identifier_list )
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 16
    *               shift and go to state 17
    IDENTIFIER      shift and go to state 21


    identifier                     shift and go to state 37
    init_declarator                shift and go to state 210
    declarator2                    shift and go to state 7
    declarator                     shift and go to state 148
    pointer                        shift and go to state 14

state 119

    (170) statement -> expression_statement .

    }               reduce using rule 170 (statement -> expression_statement .)
    CASE            reduce using rule 170 (statement -> expression_statement .)
    DEFAULT         reduce using rule 170 (statement -> expression_statement .)
    ;               reduce using rule 170 (statement -> expression_statement .)
    IF              reduce using rule 170 (statement -> expression_statement .)
    SWITCH          reduce using rule 170 (statement -> expression_statement .)
    WHILE           reduce using rule 170 (statement -> expression_statement .)
    DO              reduce using rule 170 (statement -> expression_statement .)
    FOR             reduce using rule 170 (statement -> expression_statement .)
    GOTO            reduce using rule 170 (statement -> expression_statement .)
    CONTINUE        reduce using rule 170 (statement -> expression_statement .)
    BREAK           reduce using rule 170 (statement -> expression_statement .)
    RETURN          reduce using rule 170 (statement -> expression_statement .)
    IDENTIFIER      reduce using rule 170 (statement -> expression_statement .)
    {               reduce using rule 170 (statement -> expression_statement .)
    INC_OP          reduce using rule 170 (statement -> expression_statement .)
    DEC_OP          reduce using rule 170 (statement -> expression_statement .)
    SIZEOF          reduce using rule 170 (statement -> expression_statement .)
    &               reduce using rule 170 (statement -> expression_statement .)
    *               reduce using rule 170 (statement -> expression_statement .)
    +               reduce using rule 170 (statement -> expression_statement .)
    -               reduce using rule 170 (statement -> expression_statement .)
    ~               reduce using rule 170 (statement -> expression_statement .)
    !               reduce using rule 170 (statement -> expression_statement .)
    CONSTANT        reduce using rule 170 (statement -> expression_statement .)
    STRING_LITERAL  reduce using rule 170 (statement -> expression_statement .)
    (               reduce using rule 170 (statement -> expression_statement .)
    ELSE            reduce using rule 170 (statement -> expression_statement .)



state 120

    (172) statement -> iteration_statement .

    }               reduce using rule 172 (statement -> iteration_statement .)
    CASE            reduce using rule 172 (statement -> iteration_statement .)
    DEFAULT         reduce using rule 172 (statement -> iteration_statement .)
    ;               reduce using rule 172 (statement -> iteration_statement .)
    IF              reduce using rule 172 (statement -> iteration_statement .)
    SWITCH          reduce using rule 172 (statement -> iteration_statement .)
    WHILE           reduce using rule 172 (statement -> iteration_statement .)
    DO              reduce using rule 172 (statement -> iteration_statement .)
    FOR             reduce using rule 172 (statement -> iteration_statement .)
    GOTO            reduce using rule 172 (statement -> iteration_statement .)
    CONTINUE        reduce using rule 172 (statement -> iteration_statement .)
    BREAK           reduce using rule 172 (statement -> iteration_statement .)
    RETURN          reduce using rule 172 (statement -> iteration_statement .)
    IDENTIFIER      reduce using rule 172 (statement -> iteration_statement .)
    {               reduce using rule 172 (statement -> iteration_statement .)
    INC_OP          reduce using rule 172 (statement -> iteration_statement .)
    DEC_OP          reduce using rule 172 (statement -> iteration_statement .)
    SIZEOF          reduce using rule 172 (statement -> iteration_statement .)
    &               reduce using rule 172 (statement -> iteration_statement .)
    *               reduce using rule 172 (statement -> iteration_statement .)
    +               reduce using rule 172 (statement -> iteration_statement .)
    -               reduce using rule 172 (statement -> iteration_statement .)
    ~               reduce using rule 172 (statement -> iteration_statement .)
    !               reduce using rule 172 (statement -> iteration_statement .)
    CONSTANT        reduce using rule 172 (statement -> iteration_statement .)
    STRING_LITERAL  reduce using rule 172 (statement -> iteration_statement .)
    (               reduce using rule 172 (statement -> iteration_statement .)
    ELSE            reduce using rule 172 (statement -> iteration_statement .)



state 121

    (4) primary_expr -> ( . expr )
    (28) cast_expr -> ( . type_name ) cast_expr
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (149) type_name -> . type_specifier_list
    (150) type_name -> . type_specifier_list abstract_declarator
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    ENUM            shift and go to state 24
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20
    IDENTIFIER      shift and go to state 21


    equality_expr                  shift and go to state 90
    unary_expr                     shift and go to state 133
    struct_or_union_specifier      shift and go to state 4
    logical_or_expr                shift and go to state 84
    additive_expr                  shift and go to state 77
    type_specifier                 shift and go to state 48
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    type_name                      shift and go to state 177
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    struct_or_union                shift and go to state 6
    relational_expr                shift and go to state 94
    type_specifier_list            shift and go to state 178
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    enum_specifier                 shift and go to state 33
    expr                           shift and go to state 179
    logical_and_expr               shift and go to state 102
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 122

    (202) jump_statement -> GOTO . identifier ;
    (216) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 21


    identifier                     shift and go to state 211

state 123

    (168) statement -> labeled_statement .

    }               reduce using rule 168 (statement -> labeled_statement .)
    CASE            reduce using rule 168 (statement -> labeled_statement .)
    DEFAULT         reduce using rule 168 (statement -> labeled_statement .)
    ;               reduce using rule 168 (statement -> labeled_statement .)
    IF              reduce using rule 168 (statement -> labeled_statement .)
    SWITCH          reduce using rule 168 (statement -> labeled_statement .)
    WHILE           reduce using rule 168 (statement -> labeled_statement .)
    DO              reduce using rule 168 (statement -> labeled_statement .)
    FOR             reduce using rule 168 (statement -> labeled_statement .)
    GOTO            reduce using rule 168 (statement -> labeled_statement .)
    CONTINUE        reduce using rule 168 (statement -> labeled_statement .)
    BREAK           reduce using rule 168 (statement -> labeled_statement .)
    RETURN          reduce using rule 168 (statement -> labeled_statement .)
    IDENTIFIER      reduce using rule 168 (statement -> labeled_statement .)
    {               reduce using rule 168 (statement -> labeled_statement .)
    INC_OP          reduce using rule 168 (statement -> labeled_statement .)
    DEC_OP          reduce using rule 168 (statement -> labeled_statement .)
    SIZEOF          reduce using rule 168 (statement -> labeled_statement .)
    &               reduce using rule 168 (statement -> labeled_statement .)
    *               reduce using rule 168 (statement -> labeled_statement .)
    +               reduce using rule 168 (statement -> labeled_statement .)
    -               reduce using rule 168 (statement -> labeled_statement .)
    ~               reduce using rule 168 (statement -> labeled_statement .)
    !               reduce using rule 168 (statement -> labeled_statement .)
    CONSTANT        reduce using rule 168 (statement -> labeled_statement .)
    STRING_LITERAL  reduce using rule 168 (statement -> labeled_statement .)
    (               reduce using rule 168 (statement -> labeled_statement .)
    ELSE            reduce using rule 168 (statement -> labeled_statement .)



state 124

    (181) compound_statement -> left_bracket declaration_list . right_bracket
    (182) compound_statement -> left_bracket declaration_list . statement_list right_bracket
    (184) declaration_list -> declaration_list . declaration
    (178) right_bracket -> . }
    (185) statement_list -> . statement
    (186) statement_list -> . statement_list statement
    (75) declaration -> . declaration_specifiers 
    (76) declaration -> . declaration_specifiers init_declarator_list 
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (77) declaration_specifiers -> . storage_class_specifier
    (78) declaration_specifiers -> . storage_class_specifier declaration_specifiers
    (79) declaration_specifiers -> . type_specifier
    (80) declaration_specifiers -> . type_specifier declaration_specifiers
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (85) storage_class_specifier -> . TYPEDEF
    (86) storage_class_specifier -> . EXTERN
    (87) storage_class_specifier -> . STATIC
    (88) storage_class_specifier -> . AUTO
    (89) storage_class_specifier -> . REGISTER
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    }               shift and go to state 147
    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    TYPEDEF         shift and go to state 22
    EXTERN          shift and go to state 12
    STATIC          shift and go to state 10
    AUTO            shift and go to state 23
    REGISTER        shift and go to state 36
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    storage_class_specifier        shift and go to state 38
    unary_expr                     shift and go to state 133
    struct_or_union_specifier      shift and go to state 4
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    type_specifier                 shift and go to state 15
    cast_expr                      shift and go to state 95
    compound_statement             shift and go to state 127
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 138
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    struct_or_union                shift and go to state 6
    relational_expr                shift and go to state 94
    right_bracket                  shift and go to state 212
    statement_list                 shift and go to state 213
    declaration_specifiers         shift and go to state 59
    declaration                    shift and go to state 150
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    enum_specifier                 shift and go to state 33
    expr                           shift and go to state 141
    postfix_expr                   shift and go to state 99
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 125

    (174) labeled_statement -> identifier . : statement
    (1) primary_expr -> identifier .

    :               shift and go to state 214
    [               reduce using rule 1 (primary_expr -> identifier .)
    (               reduce using rule 1 (primary_expr -> identifier .)
    .               reduce using rule 1 (primary_expr -> identifier .)
    PTR_OP          reduce using rule 1 (primary_expr -> identifier .)
    INC_OP          reduce using rule 1 (primary_expr -> identifier .)
    DEC_OP          reduce using rule 1 (primary_expr -> identifier .)
    =               reduce using rule 1 (primary_expr -> identifier .)
    MUL_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    DIV_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    MOD_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    ADD_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    SUB_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    LEFT_ASSIGN     reduce using rule 1 (primary_expr -> identifier .)
    RIGHT_ASSIGN    reduce using rule 1 (primary_expr -> identifier .)
    AND_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    XOR_ASSIGN      reduce using rule 1 (primary_expr -> identifier .)
    OR_ASSIGN       reduce using rule 1 (primary_expr -> identifier .)
    *               reduce using rule 1 (primary_expr -> identifier .)
    /               reduce using rule 1 (primary_expr -> identifier .)
    %               reduce using rule 1 (primary_expr -> identifier .)
    +               reduce using rule 1 (primary_expr -> identifier .)
    -               reduce using rule 1 (primary_expr -> identifier .)
    LEFT_OP         reduce using rule 1 (primary_expr -> identifier .)
    RIGHT_OP        reduce using rule 1 (primary_expr -> identifier .)
    <               reduce using rule 1 (primary_expr -> identifier .)
    >               reduce using rule 1 (primary_expr -> identifier .)
    LE_OP           reduce using rule 1 (primary_expr -> identifier .)
    GE_OP           reduce using rule 1 (primary_expr -> identifier .)
    EQ_OP           reduce using rule 1 (primary_expr -> identifier .)
    NE_OP           reduce using rule 1 (primary_expr -> identifier .)
    &               reduce using rule 1 (primary_expr -> identifier .)
    ^               reduce using rule 1 (primary_expr -> identifier .)
    |               reduce using rule 1 (primary_expr -> identifier .)
    AND_OP          reduce using rule 1 (primary_expr -> identifier .)
    ?               reduce using rule 1 (primary_expr -> identifier .)
    OR_OP           reduce using rule 1 (primary_expr -> identifier .)
    ;               reduce using rule 1 (primary_expr -> identifier .)
    ,               reduce using rule 1 (primary_expr -> identifier .)



state 126

    (205) jump_statement -> RETURN . ;
    (206) jump_statement -> RETURN . expr ;
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    ;               shift and go to state 215
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 216
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 127

    (169) statement -> compound_statement .

    }               reduce using rule 169 (statement -> compound_statement .)
    CASE            reduce using rule 169 (statement -> compound_statement .)
    DEFAULT         reduce using rule 169 (statement -> compound_statement .)
    ;               reduce using rule 169 (statement -> compound_statement .)
    IF              reduce using rule 169 (statement -> compound_statement .)
    SWITCH          reduce using rule 169 (statement -> compound_statement .)
    WHILE           reduce using rule 169 (statement -> compound_statement .)
    DO              reduce using rule 169 (statement -> compound_statement .)
    FOR             reduce using rule 169 (statement -> compound_statement .)
    GOTO            reduce using rule 169 (statement -> compound_statement .)
    CONTINUE        reduce using rule 169 (statement -> compound_statement .)
    BREAK           reduce using rule 169 (statement -> compound_statement .)
    RETURN          reduce using rule 169 (statement -> compound_statement .)
    IDENTIFIER      reduce using rule 169 (statement -> compound_statement .)
    {               reduce using rule 169 (statement -> compound_statement .)
    INC_OP          reduce using rule 169 (statement -> compound_statement .)
    DEC_OP          reduce using rule 169 (statement -> compound_statement .)
    SIZEOF          reduce using rule 169 (statement -> compound_statement .)
    &               reduce using rule 169 (statement -> compound_statement .)
    *               reduce using rule 169 (statement -> compound_statement .)
    +               reduce using rule 169 (statement -> compound_statement .)
    -               reduce using rule 169 (statement -> compound_statement .)
    ~               reduce using rule 169 (statement -> compound_statement .)
    !               reduce using rule 169 (statement -> compound_statement .)
    CONSTANT        reduce using rule 169 (statement -> compound_statement .)
    STRING_LITERAL  reduce using rule 169 (statement -> compound_statement .)
    (               reduce using rule 169 (statement -> compound_statement .)
    ELSE            reduce using rule 169 (statement -> compound_statement .)



state 128

    (187) expression_statement -> ; .

    }               reduce using rule 187 (expression_statement -> ; .)
    CASE            reduce using rule 187 (expression_statement -> ; .)
    DEFAULT         reduce using rule 187 (expression_statement -> ; .)
    ;               reduce using rule 187 (expression_statement -> ; .)
    IF              reduce using rule 187 (expression_statement -> ; .)
    SWITCH          reduce using rule 187 (expression_statement -> ; .)
    WHILE           reduce using rule 187 (expression_statement -> ; .)
    DO              reduce using rule 187 (expression_statement -> ; .)
    FOR             reduce using rule 187 (expression_statement -> ; .)
    GOTO            reduce using rule 187 (expression_statement -> ; .)
    CONTINUE        reduce using rule 187 (expression_statement -> ; .)
    BREAK           reduce using rule 187 (expression_statement -> ; .)
    RETURN          reduce using rule 187 (expression_statement -> ; .)
    IDENTIFIER      reduce using rule 187 (expression_statement -> ; .)
    {               reduce using rule 187 (expression_statement -> ; .)
    INC_OP          reduce using rule 187 (expression_statement -> ; .)
    DEC_OP          reduce using rule 187 (expression_statement -> ; .)
    SIZEOF          reduce using rule 187 (expression_statement -> ; .)
    &               reduce using rule 187 (expression_statement -> ; .)
    *               reduce using rule 187 (expression_statement -> ; .)
    +               reduce using rule 187 (expression_statement -> ; .)
    -               reduce using rule 187 (expression_statement -> ; .)
    ~               reduce using rule 187 (expression_statement -> ; .)
    !               reduce using rule 187 (expression_statement -> ; .)
    CONSTANT        reduce using rule 187 (expression_statement -> ; .)
    STRING_LITERAL  reduce using rule 187 (expression_statement -> ; .)
    (               reduce using rule 187 (expression_statement -> ; .)
    ELSE            reduce using rule 187 (expression_statement -> ; .)



state 129

    (194) iteration_statement -> FOR . ( ; ; ) statement
    (195) iteration_statement -> FOR . ( ; ; expr ) statement
    (196) iteration_statement -> FOR . ( ; expr ; ) statement
    (197) iteration_statement -> FOR . ( ; expr ; expr ) statement
    (198) iteration_statement -> FOR . ( expr ; ; ) statement
    (199) iteration_statement -> FOR . ( expr ; ; expr ) statement
    (200) iteration_statement -> FOR . ( expr ; expr ; ) statement
    (201) iteration_statement -> FOR . ( expr ; expr ; expr ) statement

    (               shift and go to state 217



state 130

    (179) compound_statement -> left_bracket right_bracket .

    }               reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    CASE            reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    DEFAULT         reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    ;               reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    IF              reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    SWITCH          reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    WHILE           reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    DO              reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    FOR             reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    GOTO            reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    CONTINUE        reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    BREAK           reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    RETURN          reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    IDENTIFIER      reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    {               reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    INC_OP          reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    DEC_OP          reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    SIZEOF          reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    &               reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    *               reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    +               reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    -               reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    ~               reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    !               reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    CONSTANT        reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    STRING_LITERAL  reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    (               reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    ELSE            reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    TYPEDEF         reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    EXTERN          reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    STATIC          reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    AUTO            reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    REGISTER        reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    CHAR            reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    SHORT           reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    INT             reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    LONG            reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    SIGNED          reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    UNSIGNED        reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    FLOAT           reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    DOUBLE          reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    CONST           reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    VOLATILE        reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    VOID            reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    TYPE_NAME       reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    ENUM            reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    STRUCT          reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    UNION           reduce using rule 179 (compound_statement -> left_bracket right_bracket .)
    $end            reduce using rule 179 (compound_statement -> left_bracket right_bracket .)



state 131

    (203) jump_statement -> CONTINUE . ;

    ;               shift and go to state 218



state 132

    (180) compound_statement -> left_bracket statement_list . right_bracket
    (186) statement_list -> statement_list . statement
    (178) right_bracket -> . }
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    }               shift and go to state 147
    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 219
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    right_bracket                  shift and go to state 220
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 133

    (60) assignment_expr -> unary_expr . assignment_operator assignment_expr
    (27) cast_expr -> unary_expr .
    (61) assignment_operator -> . =
    (62) assignment_operator -> . MUL_ASSIGN
    (63) assignment_operator -> . DIV_ASSIGN
    (64) assignment_operator -> . MOD_ASSIGN
    (65) assignment_operator -> . ADD_ASSIGN
    (66) assignment_operator -> . SUB_ASSIGN
    (67) assignment_operator -> . LEFT_ASSIGN
    (68) assignment_operator -> . RIGHT_ASSIGN
    (69) assignment_operator -> . AND_ASSIGN
    (70) assignment_operator -> . XOR_ASSIGN
    (71) assignment_operator -> . OR_ASSIGN

    *               reduce using rule 27 (cast_expr -> unary_expr .)
    /               reduce using rule 27 (cast_expr -> unary_expr .)
    %               reduce using rule 27 (cast_expr -> unary_expr .)
    +               reduce using rule 27 (cast_expr -> unary_expr .)
    -               reduce using rule 27 (cast_expr -> unary_expr .)
    LEFT_OP         reduce using rule 27 (cast_expr -> unary_expr .)
    RIGHT_OP        reduce using rule 27 (cast_expr -> unary_expr .)
    <               reduce using rule 27 (cast_expr -> unary_expr .)
    >               reduce using rule 27 (cast_expr -> unary_expr .)
    LE_OP           reduce using rule 27 (cast_expr -> unary_expr .)
    GE_OP           reduce using rule 27 (cast_expr -> unary_expr .)
    EQ_OP           reduce using rule 27 (cast_expr -> unary_expr .)
    NE_OP           reduce using rule 27 (cast_expr -> unary_expr .)
    &               reduce using rule 27 (cast_expr -> unary_expr .)
    ^               reduce using rule 27 (cast_expr -> unary_expr .)
    |               reduce using rule 27 (cast_expr -> unary_expr .)
    AND_OP          reduce using rule 27 (cast_expr -> unary_expr .)
    ?               reduce using rule 27 (cast_expr -> unary_expr .)
    OR_OP           reduce using rule 27 (cast_expr -> unary_expr .)
    ;               reduce using rule 27 (cast_expr -> unary_expr .)
    ,               reduce using rule 27 (cast_expr -> unary_expr .)
    )               reduce using rule 27 (cast_expr -> unary_expr .)
    }               reduce using rule 27 (cast_expr -> unary_expr .)
    ]               reduce using rule 27 (cast_expr -> unary_expr .)
                    reduce using rule 27 (cast_expr -> unary_expr .)
    =               shift and go to state 230
    MUL_ASSIGN      shift and go to state 227
    DIV_ASSIGN      shift and go to state 232
    MOD_ASSIGN      shift and go to state 222
    ADD_ASSIGN      shift and go to state 231
    SUB_ASSIGN      shift and go to state 221
    LEFT_ASSIGN     shift and go to state 229
    RIGHT_ASSIGN    shift and go to state 223
    AND_ASSIGN      shift and go to state 226
    XOR_ASSIGN      shift and go to state 224
    OR_ASSIGN       shift and go to state 225


    assignment_operator            shift and go to state 228

state 134

    (176) labeled_statement -> DEFAULT . : statement

    :               shift and go to state 233



state 135

    (192) iteration_statement -> WHILE . ( expr ) statement

    (               shift and go to state 234



state 136

    (175) labeled_statement -> CASE . constant_expr : statement
    (74) constant_expr -> . conditional_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    equality_expr                  shift and go to state 90
    unary_expr                     shift and go to state 79
    constant_expr                  shift and go to state 235
    logical_or_expr                shift and go to state 84
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    conditional_expr               shift and go to state 97
    exclusive_or_expr              shift and go to state 101
    logical_and_expr               shift and go to state 102
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98

state 137

    (191) selection_statement -> SWITCH . ( expr ) statement

    (               shift and go to state 236



state 138

    (185) statement_list -> statement .

    }               reduce using rule 185 (statement_list -> statement .)
    CASE            reduce using rule 185 (statement_list -> statement .)
    DEFAULT         reduce using rule 185 (statement_list -> statement .)
    ;               reduce using rule 185 (statement_list -> statement .)
    IF              reduce using rule 185 (statement_list -> statement .)
    SWITCH          reduce using rule 185 (statement_list -> statement .)
    WHILE           reduce using rule 185 (statement_list -> statement .)
    DO              reduce using rule 185 (statement_list -> statement .)
    FOR             reduce using rule 185 (statement_list -> statement .)
    GOTO            reduce using rule 185 (statement_list -> statement .)
    CONTINUE        reduce using rule 185 (statement_list -> statement .)
    BREAK           reduce using rule 185 (statement_list -> statement .)
    RETURN          reduce using rule 185 (statement_list -> statement .)
    IDENTIFIER      reduce using rule 185 (statement_list -> statement .)
    {               reduce using rule 185 (statement_list -> statement .)
    INC_OP          reduce using rule 185 (statement_list -> statement .)
    DEC_OP          reduce using rule 185 (statement_list -> statement .)
    SIZEOF          reduce using rule 185 (statement_list -> statement .)
    &               reduce using rule 185 (statement_list -> statement .)
    *               reduce using rule 185 (statement_list -> statement .)
    +               reduce using rule 185 (statement_list -> statement .)
    -               reduce using rule 185 (statement_list -> statement .)
    ~               reduce using rule 185 (statement_list -> statement .)
    !               reduce using rule 185 (statement_list -> statement .)
    CONSTANT        reduce using rule 185 (statement_list -> statement .)
    STRING_LITERAL  reduce using rule 185 (statement_list -> statement .)
    (               reduce using rule 185 (statement_list -> statement .)



state 139

    (173) statement -> jump_statement .

    }               reduce using rule 173 (statement -> jump_statement .)
    CASE            reduce using rule 173 (statement -> jump_statement .)
    DEFAULT         reduce using rule 173 (statement -> jump_statement .)
    ;               reduce using rule 173 (statement -> jump_statement .)
    IF              reduce using rule 173 (statement -> jump_statement .)
    SWITCH          reduce using rule 173 (statement -> jump_statement .)
    WHILE           reduce using rule 173 (statement -> jump_statement .)
    DO              reduce using rule 173 (statement -> jump_statement .)
    FOR             reduce using rule 173 (statement -> jump_statement .)
    GOTO            reduce using rule 173 (statement -> jump_statement .)
    CONTINUE        reduce using rule 173 (statement -> jump_statement .)
    BREAK           reduce using rule 173 (statement -> jump_statement .)
    RETURN          reduce using rule 173 (statement -> jump_statement .)
    IDENTIFIER      reduce using rule 173 (statement -> jump_statement .)
    {               reduce using rule 173 (statement -> jump_statement .)
    INC_OP          reduce using rule 173 (statement -> jump_statement .)
    DEC_OP          reduce using rule 173 (statement -> jump_statement .)
    SIZEOF          reduce using rule 173 (statement -> jump_statement .)
    &               reduce using rule 173 (statement -> jump_statement .)
    *               reduce using rule 173 (statement -> jump_statement .)
    +               reduce using rule 173 (statement -> jump_statement .)
    -               reduce using rule 173 (statement -> jump_statement .)
    ~               reduce using rule 173 (statement -> jump_statement .)
    !               reduce using rule 173 (statement -> jump_statement .)
    CONSTANT        reduce using rule 173 (statement -> jump_statement .)
    STRING_LITERAL  reduce using rule 173 (statement -> jump_statement .)
    (               reduce using rule 173 (statement -> jump_statement .)
    ELSE            reduce using rule 173 (statement -> jump_statement .)



state 140

    (59) assignment_expr -> conditional_expr .

    ;               reduce using rule 59 (assignment_expr -> conditional_expr .)
    ,               reduce using rule 59 (assignment_expr -> conditional_expr .)
    )               reduce using rule 59 (assignment_expr -> conditional_expr .)
                    reduce using rule 59 (assignment_expr -> conditional_expr .)
    ]               reduce using rule 59 (assignment_expr -> conditional_expr .)
    }               reduce using rule 59 (assignment_expr -> conditional_expr .)



state 141

    (188) expression_statement -> expr . ;
    (73) expr -> expr . , assignment_expr

    ;               shift and go to state 237
    ,               shift and go to state 238



state 142

    (204) jump_statement -> BREAK . ;

    ;               shift and go to state 239



state 143

    (72) expr -> assignment_expr .

    ;               reduce using rule 72 (expr -> assignment_expr .)
    ,               reduce using rule 72 (expr -> assignment_expr .)
    )               reduce using rule 72 (expr -> assignment_expr .)
    ]               reduce using rule 72 (expr -> assignment_expr .)



state 144

    (193) iteration_statement -> DO . statement WHILE ( expr ) ;
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 240
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 145

    (171) statement -> selection_statement .

    }               reduce using rule 171 (statement -> selection_statement .)
    CASE            reduce using rule 171 (statement -> selection_statement .)
    DEFAULT         reduce using rule 171 (statement -> selection_statement .)
    ;               reduce using rule 171 (statement -> selection_statement .)
    IF              reduce using rule 171 (statement -> selection_statement .)
    SWITCH          reduce using rule 171 (statement -> selection_statement .)
    WHILE           reduce using rule 171 (statement -> selection_statement .)
    DO              reduce using rule 171 (statement -> selection_statement .)
    FOR             reduce using rule 171 (statement -> selection_statement .)
    GOTO            reduce using rule 171 (statement -> selection_statement .)
    CONTINUE        reduce using rule 171 (statement -> selection_statement .)
    BREAK           reduce using rule 171 (statement -> selection_statement .)
    RETURN          reduce using rule 171 (statement -> selection_statement .)
    IDENTIFIER      reduce using rule 171 (statement -> selection_statement .)
    {               reduce using rule 171 (statement -> selection_statement .)
    INC_OP          reduce using rule 171 (statement -> selection_statement .)
    DEC_OP          reduce using rule 171 (statement -> selection_statement .)
    SIZEOF          reduce using rule 171 (statement -> selection_statement .)
    &               reduce using rule 171 (statement -> selection_statement .)
    *               reduce using rule 171 (statement -> selection_statement .)
    +               reduce using rule 171 (statement -> selection_statement .)
    -               reduce using rule 171 (statement -> selection_statement .)
    ~               reduce using rule 171 (statement -> selection_statement .)
    !               reduce using rule 171 (statement -> selection_statement .)
    CONSTANT        reduce using rule 171 (statement -> selection_statement .)
    STRING_LITERAL  reduce using rule 171 (statement -> selection_statement .)
    (               reduce using rule 171 (statement -> selection_statement .)
    ELSE            reduce using rule 171 (statement -> selection_statement .)



state 146

    (189) selection_statement -> IF . ( expr ) statement
    (190) selection_statement -> IF . ( expr ) statement ELSE statement

    (               shift and go to state 241



state 147

    (178) right_bracket -> } .

    (               reduce using rule 178 (right_bracket -> } .)
    *               reduce using rule 178 (right_bracket -> } .)
    TYPEDEF         reduce using rule 178 (right_bracket -> } .)
    EXTERN          reduce using rule 178 (right_bracket -> } .)
    STATIC          reduce using rule 178 (right_bracket -> } .)
    AUTO            reduce using rule 178 (right_bracket -> } .)
    REGISTER        reduce using rule 178 (right_bracket -> } .)
    CHAR            reduce using rule 178 (right_bracket -> } .)
    SHORT           reduce using rule 178 (right_bracket -> } .)
    INT             reduce using rule 178 (right_bracket -> } .)
    LONG            reduce using rule 178 (right_bracket -> } .)
    SIGNED          reduce using rule 178 (right_bracket -> } .)
    UNSIGNED        reduce using rule 178 (right_bracket -> } .)
    FLOAT           reduce using rule 178 (right_bracket -> } .)
    DOUBLE          reduce using rule 178 (right_bracket -> } .)
    CONST           reduce using rule 178 (right_bracket -> } .)
    VOLATILE        reduce using rule 178 (right_bracket -> } .)
    VOID            reduce using rule 178 (right_bracket -> } .)
    TYPE_NAME       reduce using rule 178 (right_bracket -> } .)
    IDENTIFIER      reduce using rule 178 (right_bracket -> } .)
    ENUM            reduce using rule 178 (right_bracket -> } .)
    STRUCT          reduce using rule 178 (right_bracket -> } .)
    UNION           reduce using rule 178 (right_bracket -> } .)
    $end            reduce using rule 178 (right_bracket -> } .)
    }               reduce using rule 178 (right_bracket -> } .)
    CASE            reduce using rule 178 (right_bracket -> } .)
    DEFAULT         reduce using rule 178 (right_bracket -> } .)
    ;               reduce using rule 178 (right_bracket -> } .)
    IF              reduce using rule 178 (right_bracket -> } .)
    SWITCH          reduce using rule 178 (right_bracket -> } .)
    WHILE           reduce using rule 178 (right_bracket -> } .)
    DO              reduce using rule 178 (right_bracket -> } .)
    FOR             reduce using rule 178 (right_bracket -> } .)
    GOTO            reduce using rule 178 (right_bracket -> } .)
    CONTINUE        reduce using rule 178 (right_bracket -> } .)
    BREAK           reduce using rule 178 (right_bracket -> } .)
    RETURN          reduce using rule 178 (right_bracket -> } .)
    {               reduce using rule 178 (right_bracket -> } .)
    INC_OP          reduce using rule 178 (right_bracket -> } .)
    DEC_OP          reduce using rule 178 (right_bracket -> } .)
    SIZEOF          reduce using rule 178 (right_bracket -> } .)
    &               reduce using rule 178 (right_bracket -> } .)
    +               reduce using rule 178 (right_bracket -> } .)
    -               reduce using rule 178 (right_bracket -> } .)
    ~               reduce using rule 178 (right_bracket -> } .)
    !               reduce using rule 178 (right_bracket -> } .)
    CONSTANT        reduce using rule 178 (right_bracket -> } .)
    STRING_LITERAL  reduce using rule 178 (right_bracket -> } .)
    ELSE            reduce using rule 178 (right_bracket -> } .)



state 148

    (83) init_declarator -> declarator .
    (84) init_declarator -> declarator . = initializer

                    reduce using rule 83 (init_declarator -> declarator .)
    ,               reduce using rule 83 (init_declarator -> declarator .)
    =               shift and go to state 116



state 149

    (215) function_body -> declaration_list compound_statement .

    (               reduce using rule 215 (function_body -> declaration_list compound_statement .)
    *               reduce using rule 215 (function_body -> declaration_list compound_statement .)
    TYPEDEF         reduce using rule 215 (function_body -> declaration_list compound_statement .)
    EXTERN          reduce using rule 215 (function_body -> declaration_list compound_statement .)
    STATIC          reduce using rule 215 (function_body -> declaration_list compound_statement .)
    AUTO            reduce using rule 215 (function_body -> declaration_list compound_statement .)
    REGISTER        reduce using rule 215 (function_body -> declaration_list compound_statement .)
    CHAR            reduce using rule 215 (function_body -> declaration_list compound_statement .)
    SHORT           reduce using rule 215 (function_body -> declaration_list compound_statement .)
    INT             reduce using rule 215 (function_body -> declaration_list compound_statement .)
    LONG            reduce using rule 215 (function_body -> declaration_list compound_statement .)
    SIGNED          reduce using rule 215 (function_body -> declaration_list compound_statement .)
    UNSIGNED        reduce using rule 215 (function_body -> declaration_list compound_statement .)
    FLOAT           reduce using rule 215 (function_body -> declaration_list compound_statement .)
    DOUBLE          reduce using rule 215 (function_body -> declaration_list compound_statement .)
    CONST           reduce using rule 215 (function_body -> declaration_list compound_statement .)
    VOLATILE        reduce using rule 215 (function_body -> declaration_list compound_statement .)
    VOID            reduce using rule 215 (function_body -> declaration_list compound_statement .)
    TYPE_NAME       reduce using rule 215 (function_body -> declaration_list compound_statement .)
    IDENTIFIER      reduce using rule 215 (function_body -> declaration_list compound_statement .)
    ENUM            reduce using rule 215 (function_body -> declaration_list compound_statement .)
    STRUCT          reduce using rule 215 (function_body -> declaration_list compound_statement .)
    UNION           reduce using rule 215 (function_body -> declaration_list compound_statement .)
    $end            reduce using rule 215 (function_body -> declaration_list compound_statement .)



state 150

    (184) declaration_list -> declaration_list declaration .

    {               reduce using rule 184 (declaration_list -> declaration_list declaration .)
    TYPEDEF         reduce using rule 184 (declaration_list -> declaration_list declaration .)
    EXTERN          reduce using rule 184 (declaration_list -> declaration_list declaration .)
    STATIC          reduce using rule 184 (declaration_list -> declaration_list declaration .)
    AUTO            reduce using rule 184 (declaration_list -> declaration_list declaration .)
    REGISTER        reduce using rule 184 (declaration_list -> declaration_list declaration .)
    CHAR            reduce using rule 184 (declaration_list -> declaration_list declaration .)
    SHORT           reduce using rule 184 (declaration_list -> declaration_list declaration .)
    INT             reduce using rule 184 (declaration_list -> declaration_list declaration .)
    LONG            reduce using rule 184 (declaration_list -> declaration_list declaration .)
    SIGNED          reduce using rule 184 (declaration_list -> declaration_list declaration .)
    UNSIGNED        reduce using rule 184 (declaration_list -> declaration_list declaration .)
    FLOAT           reduce using rule 184 (declaration_list -> declaration_list declaration .)
    DOUBLE          reduce using rule 184 (declaration_list -> declaration_list declaration .)
    CONST           reduce using rule 184 (declaration_list -> declaration_list declaration .)
    VOLATILE        reduce using rule 184 (declaration_list -> declaration_list declaration .)
    VOID            reduce using rule 184 (declaration_list -> declaration_list declaration .)
    TYPE_NAME       reduce using rule 184 (declaration_list -> declaration_list declaration .)
    ENUM            reduce using rule 184 (declaration_list -> declaration_list declaration .)
    STRUCT          reduce using rule 184 (declaration_list -> declaration_list declaration .)
    UNION           reduce using rule 184 (declaration_list -> declaration_list declaration .)
    }               reduce using rule 184 (declaration_list -> declaration_list declaration .)
    CASE            reduce using rule 184 (declaration_list -> declaration_list declaration .)
    DEFAULT         reduce using rule 184 (declaration_list -> declaration_list declaration .)
    ;               reduce using rule 184 (declaration_list -> declaration_list declaration .)
    IF              reduce using rule 184 (declaration_list -> declaration_list declaration .)
    SWITCH          reduce using rule 184 (declaration_list -> declaration_list declaration .)
    WHILE           reduce using rule 184 (declaration_list -> declaration_list declaration .)
    DO              reduce using rule 184 (declaration_list -> declaration_list declaration .)
    FOR             reduce using rule 184 (declaration_list -> declaration_list declaration .)
    GOTO            reduce using rule 184 (declaration_list -> declaration_list declaration .)
    CONTINUE        reduce using rule 184 (declaration_list -> declaration_list declaration .)
    BREAK           reduce using rule 184 (declaration_list -> declaration_list declaration .)
    RETURN          reduce using rule 184 (declaration_list -> declaration_list declaration .)
    IDENTIFIER      reduce using rule 184 (declaration_list -> declaration_list declaration .)
    INC_OP          reduce using rule 184 (declaration_list -> declaration_list declaration .)
    DEC_OP          reduce using rule 184 (declaration_list -> declaration_list declaration .)
    SIZEOF          reduce using rule 184 (declaration_list -> declaration_list declaration .)
    &               reduce using rule 184 (declaration_list -> declaration_list declaration .)
    *               reduce using rule 184 (declaration_list -> declaration_list declaration .)
    +               reduce using rule 184 (declaration_list -> declaration_list declaration .)
    -               reduce using rule 184 (declaration_list -> declaration_list declaration .)
    ~               reduce using rule 184 (declaration_list -> declaration_list declaration .)
    !               reduce using rule 184 (declaration_list -> declaration_list declaration .)
    CONSTANT        reduce using rule 184 (declaration_list -> declaration_list declaration .)
    STRING_LITERAL  reduce using rule 184 (declaration_list -> declaration_list declaration .)
    (               reduce using rule 184 (declaration_list -> declaration_list declaration .)



state 151

    (104) struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list . }
    (110) struct_declaration_list -> struct_declaration_list . struct_declaration
    (111) struct_declaration -> . type_specifier_list struct_declarator_list 
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    }               shift and go to state 242
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 48
    struct_declaration             shift and go to state 152
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    type_specifier_list            shift and go to state 67

state 152

    (110) struct_declaration_list -> struct_declaration_list struct_declaration .

    }               reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    CHAR            reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    SHORT           reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    INT             reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    LONG            reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    SIGNED          reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    UNSIGNED        reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    FLOAT           reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    DOUBLE          reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    CONST           reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    VOLATILE        reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    VOID            reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    TYPE_NAME       reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    ENUM            reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    STRUCT          reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)
    UNION           reduce using rule 110 (struct_declaration_list -> struct_declaration_list struct_declaration .)



state 153

    (105) struct_or_union_specifier -> struct_or_union { struct_declaration_list } .

    CHAR            reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    SHORT           reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    INT             reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    LONG            reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    SIGNED          reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    UNSIGNED        reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    FLOAT           reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    DOUBLE          reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    CONST           reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    VOLATILE        reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    VOID            reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    TYPE_NAME       reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    (               reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    *               reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    ENUM            reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    [               reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    IDENTIFIER      reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    STRUCT          reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    UNION           reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    ,               reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    )               reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    TYPEDEF         reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    EXTERN          reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    STATIC          reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    AUTO            reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    REGISTER        reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
                    reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)
    :               reduce using rule 105 (struct_or_union_specifier -> struct_or_union { struct_declaration_list } .)



state 154

    (115) struct_declarator -> : . constant_expr
    (74) constant_expr -> . conditional_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    conditional_expr               shift and go to state 97
    logical_and_expr               shift and go to state 102
    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    exclusive_or_expr              shift and go to state 101
    relational_expr                shift and go to state 94
    postfix_expr                   shift and go to state 99
    constant_expr                  shift and go to state 243
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    logical_or_expr                shift and go to state 84
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    unary_operator                 shift and go to state 105
    equality_expr                  shift and go to state 90
    identifier                     shift and go to state 98
    additive_expr                  shift and go to state 77
    and_expr                       shift and go to state 93

state 155

    (111) struct_declaration -> type_specifier_list struct_declarator_list . 
    (113) struct_declarator_list -> struct_declarator_list . , struct_declarator

                    shift and go to state 244
    ,               shift and go to state 245



state 156

    (112) struct_declarator_list -> struct_declarator .

                    reduce using rule 112 (struct_declarator_list -> struct_declarator .)
    ,               reduce using rule 112 (struct_declarator_list -> struct_declarator .)



state 157

    (114) struct_declarator -> declarator .
    (116) struct_declarator -> declarator . : constant_expr

                    reduce using rule 114 (struct_declarator -> declarator .)
    ,               reduce using rule 114 (struct_declarator -> declarator .)
    :               shift and go to state 246



state 158

    (131) declarator2 -> declarator2 ( parameter_type_list ) .

    [               reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    (               reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    {               reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    TYPEDEF         reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    EXTERN          reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    STATIC          reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    AUTO            reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    REGISTER        reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    CHAR            reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    SHORT           reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    INT             reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    LONG            reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    SIGNED          reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    UNSIGNED        reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    FLOAT           reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    DOUBLE          reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    CONST           reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    VOLATILE        reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    VOID            reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    TYPE_NAME       reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    ENUM            reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    STRUCT          reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    UNION           reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    )               reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    =               reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
                    reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    ,               reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)
    :               reduce using rule 131 (declarator2 -> declarator2 ( parameter_type_list ) .)



state 159

    (132) declarator2 -> declarator2 ( parameter_identifier_list ) .

    [               reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    (               reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    {               reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    TYPEDEF         reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    EXTERN          reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    STATIC          reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    AUTO            reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    REGISTER        reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    CHAR            reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    SHORT           reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    INT             reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    LONG            reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    SIGNED          reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    UNSIGNED        reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    FLOAT           reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    DOUBLE          reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    CONST           reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    VOLATILE        reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    VOID            reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    TYPE_NAME       reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    ENUM            reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    STRUCT          reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    UNION           reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    )               reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    =               reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
                    reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    ,               reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)
    :               reduce using rule 132 (declarator2 -> declarator2 ( parameter_identifier_list ) .)



state 160

    (125) declarator -> pointer . declarator2
    (151) abstract_declarator -> pointer .
    (153) abstract_declarator -> pointer . abstract_declarator2
    (126) declarator2 -> . identifier
    (127) declarator2 -> . ( declarator )
    (128) declarator2 -> . declarator2 [ ]
    (129) declarator2 -> . declarator2 [ constant_expr ]
    (130) declarator2 -> . declarator2 ( )
    (131) declarator2 -> . declarator2 ( parameter_type_list )
    (132) declarator2 -> . declarator2 ( parameter_identifier_list )
    (154) abstract_declarator2 -> . ( abstract_declarator )
    (155) abstract_declarator2 -> . [ ]
    (156) abstract_declarator2 -> . [ constant_expr ]
    (157) abstract_declarator2 -> . abstract_declarator2 [ ]
    (158) abstract_declarator2 -> . abstract_declarator2 [ constant_expr ]
    (159) abstract_declarator2 -> . ( )
    (160) abstract_declarator2 -> . ( parameter_type_list )
    (161) abstract_declarator2 -> . abstract_declarator2 ( )
    (162) abstract_declarator2 -> . abstract_declarator2 ( parameter_type_list )
    (216) identifier -> . IDENTIFIER

    ,               reduce using rule 151 (abstract_declarator -> pointer .)
    )               reduce using rule 151 (abstract_declarator -> pointer .)
    (               shift and go to state 161
    [               shift and go to state 163
    IDENTIFIER      shift and go to state 21


    declarator2                    shift and go to state 44
    abstract_declarator2           shift and go to state 247
    identifier                     shift and go to state 37

state 161

    (127) declarator2 -> ( . declarator )
    (154) abstract_declarator2 -> ( . abstract_declarator )
    (159) abstract_declarator2 -> ( . )
    (160) abstract_declarator2 -> ( . parameter_type_list )
    (124) declarator -> . declarator2
    (125) declarator -> . pointer declarator2
    (151) abstract_declarator -> . pointer
    (152) abstract_declarator -> . abstract_declarator2
    (153) abstract_declarator -> . pointer abstract_declarator2
    (143) parameter_type_list -> . parameter_list
    (144) parameter_type_list -> . parameter_list , ELIPSIS
    (126) declarator2 -> . identifier
    (127) declarator2 -> . ( declarator )
    (128) declarator2 -> . declarator2 [ ]
    (129) declarator2 -> . declarator2 [ constant_expr ]
    (130) declarator2 -> . declarator2 ( )
    (131) declarator2 -> . declarator2 ( parameter_type_list )
    (132) declarator2 -> . declarator2 ( parameter_identifier_list )
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (154) abstract_declarator2 -> . ( abstract_declarator )
    (155) abstract_declarator2 -> . [ ]
    (156) abstract_declarator2 -> . [ constant_expr ]
    (157) abstract_declarator2 -> . abstract_declarator2 [ ]
    (158) abstract_declarator2 -> . abstract_declarator2 [ constant_expr ]
    (159) abstract_declarator2 -> . ( )
    (160) abstract_declarator2 -> . ( parameter_type_list )
    (161) abstract_declarator2 -> . abstract_declarator2 ( )
    (162) abstract_declarator2 -> . abstract_declarator2 ( parameter_type_list )
    (145) parameter_list -> . parameter_declaration
    (146) parameter_list -> . parameter_list , parameter_declaration
    (216) identifier -> . IDENTIFIER
    (147) parameter_declaration -> . type_specifier_list declarator
    (148) parameter_declaration -> . type_name
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (149) type_name -> . type_specifier_list
    (150) type_name -> . type_specifier_list abstract_declarator
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    )               shift and go to state 248
    (               shift and go to state 161
    *               shift and go to state 17
    [               shift and go to state 163
    IDENTIFIER      shift and go to state 21
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    type_name                      shift and go to state 69
    parameter_list                 shift and go to state 75
    parameter_type_list            shift and go to state 249
    parameter_declaration          shift and go to state 71
    declarator2                    shift and go to state 7
    abstract_declarator            shift and go to state 250
    enum_specifier                 shift and go to state 33
    abstract_declarator2           shift and go to state 162
    type_specifier_list            shift and go to state 73
    struct_or_union_specifier      shift and go to state 4
    type_specifier                 shift and go to state 48
    declarator                     shift and go to state 46
    identifier                     shift and go to state 37
    pointer                        shift and go to state 160

state 162

    (152) abstract_declarator -> abstract_declarator2 .
    (157) abstract_declarator2 -> abstract_declarator2 . [ ]
    (158) abstract_declarator2 -> abstract_declarator2 . [ constant_expr ]
    (161) abstract_declarator2 -> abstract_declarator2 . ( )
    (162) abstract_declarator2 -> abstract_declarator2 . ( parameter_type_list )

    )               reduce using rule 152 (abstract_declarator -> abstract_declarator2 .)
    ,               reduce using rule 152 (abstract_declarator -> abstract_declarator2 .)
    [               shift and go to state 252
    (               shift and go to state 251



state 163

    (155) abstract_declarator2 -> [ . ]
    (156) abstract_declarator2 -> [ . constant_expr ]
    (74) constant_expr -> . conditional_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    ]               shift and go to state 254
    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    conditional_expr               shift and go to state 97
    logical_and_expr               shift and go to state 102
    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    exclusive_or_expr              shift and go to state 101
    relational_expr                shift and go to state 94
    postfix_expr                   shift and go to state 99
    constant_expr                  shift and go to state 253
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    logical_or_expr                shift and go to state 84
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    unary_operator                 shift and go to state 105
    equality_expr                  shift and go to state 90
    identifier                     shift and go to state 98
    additive_expr                  shift and go to state 77
    and_expr                       shift and go to state 93

state 164

    (150) type_name -> type_specifier_list abstract_declarator .

    ,               reduce using rule 150 (type_name -> type_specifier_list abstract_declarator .)
    )               reduce using rule 150 (type_name -> type_specifier_list abstract_declarator .)



state 165

    (147) parameter_declaration -> type_specifier_list declarator .

    ,               reduce using rule 147 (parameter_declaration -> type_specifier_list declarator .)
    )               reduce using rule 147 (parameter_declaration -> type_specifier_list declarator .)



state 166

    (140) parameter_identifier_list -> identifier_list , . ELIPSIS
    (142) identifier_list -> identifier_list , . identifier
    (216) identifier -> . IDENTIFIER

    ELIPSIS         shift and go to state 255
    IDENTIFIER      shift and go to state 21


    identifier                     shift and go to state 256

state 167

    (144) parameter_type_list -> parameter_list , . ELIPSIS
    (146) parameter_list -> parameter_list , . parameter_declaration
    (147) parameter_declaration -> . type_specifier_list declarator
    (148) parameter_declaration -> . type_name
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (149) type_name -> . type_specifier_list
    (150) type_name -> . type_specifier_list abstract_declarator
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    ELIPSIS         shift and go to state 257
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 48
    enum_specifier                 shift and go to state 33
    parameter_declaration          shift and go to state 258
    type_name                      shift and go to state 69
    type_specifier_list            shift and go to state 73
    struct_or_union_specifier      shift and go to state 4

state 168

    (34) additive_expr -> additive_expr + . multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    postfix_expr                   shift and go to state 99
    multiplicative_expr            shift and go to state 259
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 169

    (35) additive_expr -> additive_expr - . multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    postfix_expr                   shift and go to state 99
    multiplicative_expr            shift and go to state 260
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 170

    (17) unary_expr -> DEC_OP unary_expr .

    =               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    MUL_ASSIGN      reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    DIV_ASSIGN      reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    MOD_ASSIGN      reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    ADD_ASSIGN      reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    SUB_ASSIGN      reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    LEFT_ASSIGN     reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    RIGHT_ASSIGN    reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    AND_ASSIGN      reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    XOR_ASSIGN      reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    OR_ASSIGN       reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    *               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    /               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    %               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    +               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    -               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    LEFT_OP         reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    RIGHT_OP        reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    <               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    >               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    LE_OP           reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    GE_OP           reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    EQ_OP           reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    NE_OP           reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    &               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    ^               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    |               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    AND_OP          reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    ?               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    OR_OP           reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    ;               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    ,               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    )               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
                    reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    :               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    ]               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)
    }               reduce using rule 17 (unary_expr -> DEC_OP unary_expr .)



state 171

    (4) primary_expr -> ( . expr )
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 179
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 172

    (129) declarator2 -> declarator2 [ constant_expr ] .

    [               reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    (               reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    {               reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    TYPEDEF         reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    EXTERN          reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    STATIC          reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    AUTO            reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    REGISTER        reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    CHAR            reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    SHORT           reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    INT             reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    LONG            reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    SIGNED          reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    UNSIGNED        reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    FLOAT           reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    DOUBLE          reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    CONST           reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    VOLATILE        reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    VOID            reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    TYPE_NAME       reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    ENUM            reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    STRUCT          reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    UNION           reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    )               reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    =               reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
                    reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    ,               reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)
    :               reduce using rule 129 (declarator2 -> declarator2 [ constant_expr ] .)



state 173

    (56) logical_or_expr -> logical_or_expr OR_OP . logical_and_expr
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    equality_expr                  shift and go to state 90
    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    exclusive_or_expr              shift and go to state 101
    relational_expr                shift and go to state 94
    postfix_expr                   shift and go to state 99
    logical_and_expr               shift and go to state 261
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    unary_operator                 shift and go to state 105
    identifier                     shift and go to state 98
    additive_expr                  shift and go to state 77
    and_expr                       shift and go to state 93

state 174

    (58) conditional_expr -> logical_or_expr ? . logical_or_expr : conditional_expr
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    equality_expr                  shift and go to state 90
    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    exclusive_or_expr              shift and go to state 101
    relational_expr                shift and go to state 94
    postfix_expr                   shift and go to state 99
    logical_and_expr               shift and go to state 102
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    logical_or_expr                shift and go to state 262
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    unary_operator                 shift and go to state 105
    identifier                     shift and go to state 98
    additive_expr                  shift and go to state 77
    and_expr                       shift and go to state 93

state 175

    (19) unary_expr -> SIZEOF unary_expr .

    =               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    MUL_ASSIGN      reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    DIV_ASSIGN      reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    MOD_ASSIGN      reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    ADD_ASSIGN      reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    SUB_ASSIGN      reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    LEFT_ASSIGN     reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    RIGHT_ASSIGN    reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    AND_ASSIGN      reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    XOR_ASSIGN      reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    OR_ASSIGN       reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    *               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    /               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    %               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    +               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    -               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    LEFT_OP         reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    RIGHT_OP        reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    <               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    >               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    LE_OP           reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    GE_OP           reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    EQ_OP           reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    NE_OP           reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    &               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    ^               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    |               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    AND_OP          reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    ?               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    OR_OP           reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    ;               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    ,               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    )               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
                    reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    :               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    ]               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)
    }               reduce using rule 19 (unary_expr -> SIZEOF unary_expr .)



state 176

    (20) unary_expr -> SIZEOF ( . type_name )
    (4) primary_expr -> ( . expr )
    (149) type_name -> . type_specifier_list
    (150) type_name -> . type_specifier_list abstract_declarator
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    ENUM            shift and go to state 24
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    equality_expr                  shift and go to state 90
    unary_expr                     shift and go to state 133
    struct_or_union_specifier      shift and go to state 4
    logical_or_expr                shift and go to state 84
    additive_expr                  shift and go to state 77
    type_specifier                 shift and go to state 48
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    type_name                      shift and go to state 263
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    struct_or_union                shift and go to state 6
    relational_expr                shift and go to state 94
    type_specifier_list            shift and go to state 178
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    enum_specifier                 shift and go to state 33
    expr                           shift and go to state 179
    logical_and_expr               shift and go to state 102
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 177

    (28) cast_expr -> ( type_name . ) cast_expr

    )               shift and go to state 264



state 178

    (149) type_name -> type_specifier_list .
    (150) type_name -> type_specifier_list . abstract_declarator
    (138) type_specifier_list -> type_specifier_list . type_specifier
    (151) abstract_declarator -> . pointer
    (152) abstract_declarator -> . abstract_declarator2
    (153) abstract_declarator -> . pointer abstract_declarator2
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (154) abstract_declarator2 -> . ( abstract_declarator )
    (155) abstract_declarator2 -> . [ ]
    (156) abstract_declarator2 -> . [ constant_expr ]
    (157) abstract_declarator2 -> . abstract_declarator2 [ ]
    (158) abstract_declarator2 -> . abstract_declarator2 [ constant_expr ]
    (159) abstract_declarator2 -> . ( )
    (160) abstract_declarator2 -> . ( parameter_type_list )
    (161) abstract_declarator2 -> . abstract_declarator2 ( )
    (162) abstract_declarator2 -> . abstract_declarator2 ( parameter_type_list )
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    )               reduce using rule 149 (type_name -> type_specifier_list .)
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    *               shift and go to state 17
    (               shift and go to state 266
    [               shift and go to state 163
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 110
    enum_specifier                 shift and go to state 33
    struct_or_union_specifier      shift and go to state 4
    abstract_declarator            shift and go to state 164
    abstract_declarator2           shift and go to state 162
    pointer                        shift and go to state 265

state 179

    (4) primary_expr -> ( expr . )
    (73) expr -> expr . , assignment_expr

    )               shift and go to state 267
    ,               shift and go to state 238



state 180

    (45) equality_expr -> equality_expr EQ_OP . relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    relational_expr                shift and go to state 268
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 181

    (46) equality_expr -> equality_expr NE_OP . relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    relational_expr                shift and go to state 269
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 182

    (37) shift_expr -> shift_expr LEFT_OP . additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    postfix_expr                   shift and go to state 99
    additive_expr                  shift and go to state 270
    multiplicative_expr            shift and go to state 92
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 183

    (38) shift_expr -> shift_expr RIGHT_OP . additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    postfix_expr                   shift and go to state 99
    additive_expr                  shift and go to state 271
    multiplicative_expr            shift and go to state 92
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 184

    (32) multiplicative_expr -> multiplicative_expr % . cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 272
    unary_expr                     shift and go to state 79
    postfix_expr                   shift and go to state 99
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 185

    (30) multiplicative_expr -> multiplicative_expr * . cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 273
    unary_expr                     shift and go to state 79
    postfix_expr                   shift and go to state 99
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 186

    (31) multiplicative_expr -> multiplicative_expr / . cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 274
    unary_expr                     shift and go to state 79
    postfix_expr                   shift and go to state 99
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 187

    (48) and_expr -> and_expr & . equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    relational_expr                shift and go to state 94
    postfix_expr                   shift and go to state 99
    equality_expr                  shift and go to state 275
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 188

    (42) relational_expr -> relational_expr LE_OP . shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    postfix_expr                   shift and go to state 99
    additive_expr                  shift and go to state 77
    shift_expr                     shift and go to state 276
    multiplicative_expr            shift and go to state 92
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 189

    (43) relational_expr -> relational_expr GE_OP . shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    postfix_expr                   shift and go to state 99
    additive_expr                  shift and go to state 77
    shift_expr                     shift and go to state 277
    multiplicative_expr            shift and go to state 92
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 190

    (40) relational_expr -> relational_expr < . shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    postfix_expr                   shift and go to state 99
    additive_expr                  shift and go to state 77
    shift_expr                     shift and go to state 278
    multiplicative_expr            shift and go to state 92
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 191

    (41) relational_expr -> relational_expr > . shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    postfix_expr                   shift and go to state 99
    additive_expr                  shift and go to state 77
    shift_expr                     shift and go to state 279
    multiplicative_expr            shift and go to state 92
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 192

    (12) postfix_expr -> postfix_expr DEC_OP .

    [               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    (               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    .               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    PTR_OP          reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    INC_OP          reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    DEC_OP          reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    =               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    MUL_ASSIGN      reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    DIV_ASSIGN      reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    MOD_ASSIGN      reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    ADD_ASSIGN      reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    SUB_ASSIGN      reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    LEFT_ASSIGN     reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    RIGHT_ASSIGN    reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    AND_ASSIGN      reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    XOR_ASSIGN      reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    OR_ASSIGN       reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    *               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    /               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    %               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    +               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    -               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    LEFT_OP         reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    RIGHT_OP        reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    <               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    >               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    LE_OP           reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    GE_OP           reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    EQ_OP           reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    NE_OP           reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    &               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    ^               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    |               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    AND_OP          reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    ?               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    OR_OP           reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    ;               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    ,               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    ]               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    )               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
                    reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    :               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)
    }               reduce using rule 12 (postfix_expr -> postfix_expr DEC_OP .)



state 193

    (9) postfix_expr -> postfix_expr . . identifier
    (216) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 21


    identifier                     shift and go to state 280

state 194

    (11) postfix_expr -> postfix_expr INC_OP .

    [               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    (               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    .               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    PTR_OP          reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    INC_OP          reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    DEC_OP          reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    =               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    MUL_ASSIGN      reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    DIV_ASSIGN      reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    MOD_ASSIGN      reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    ADD_ASSIGN      reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    SUB_ASSIGN      reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    LEFT_ASSIGN     reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    RIGHT_ASSIGN    reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    AND_ASSIGN      reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    XOR_ASSIGN      reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    OR_ASSIGN       reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    *               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    /               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    %               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    +               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    -               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    LEFT_OP         reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    RIGHT_OP        reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    <               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    >               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    LE_OP           reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    GE_OP           reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    EQ_OP           reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    NE_OP           reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    &               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    ^               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    |               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    AND_OP          reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    ?               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    OR_OP           reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    ;               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    ,               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    ]               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    )               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
                    reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    :               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)
    }               reduce using rule 11 (postfix_expr -> postfix_expr INC_OP .)



state 195

    (10) postfix_expr -> postfix_expr PTR_OP . identifier
    (216) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 21


    identifier                     shift and go to state 281

state 196

    (7) postfix_expr -> postfix_expr ( . )
    (8) postfix_expr -> postfix_expr ( . argument_expr_list )
    (13) argument_expr_list -> . assignment_expr
    (14) argument_expr_list -> . argument_expr_list , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    )               shift and go to state 283
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    argument_expr_list             shift and go to state 282
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 284
    identifier                     shift and go to state 98

state 197

    (6) postfix_expr -> postfix_expr [ . expr ]
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 285
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 198

    (50) exclusive_or_expr -> exclusive_or_expr ^ . and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    relational_expr                shift and go to state 94
    postfix_expr                   shift and go to state 99
    equality_expr                  shift and go to state 90
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_expr                     shift and go to state 79
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 286

state 199

    (54) logical_and_expr -> logical_and_expr AND_OP . inclusive_or_expr
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 95
    exclusive_or_expr              shift and go to state 101
    relational_expr                shift and go to state 94
    postfix_expr                   shift and go to state 99
    equality_expr                  shift and go to state 90
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_expr                     shift and go to state 79
    inclusive_or_expr              shift and go to state 287
    primary_expr                   shift and go to state 104
    unary_operator                 shift and go to state 105
    identifier                     shift and go to state 98
    additive_expr                  shift and go to state 77
    and_expr                       shift and go to state 93

state 200

    (52) inclusive_or_expr -> inclusive_or_expr | . exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    exclusive_or_expr              shift and go to state 288
    relational_expr                shift and go to state 94
    postfix_expr                   shift and go to state 99
    equality_expr                  shift and go to state 90
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_expr                     shift and go to state 79
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93

state 201

    (18) unary_expr -> unary_operator cast_expr .

    =               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    MUL_ASSIGN      reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    DIV_ASSIGN      reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    MOD_ASSIGN      reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    ADD_ASSIGN      reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    SUB_ASSIGN      reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    LEFT_ASSIGN     reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    RIGHT_ASSIGN    reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    AND_ASSIGN      reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    XOR_ASSIGN      reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    OR_ASSIGN       reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    *               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    /               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    %               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    +               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    -               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    LEFT_OP         reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    RIGHT_OP        reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    <               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    >               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    LE_OP           reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    GE_OP           reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    EQ_OP           reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    NE_OP           reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    &               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    ^               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    |               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    AND_OP          reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    ?               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    OR_OP           reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    ;               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    ,               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    )               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
                    reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    :               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    ]               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)
    }               reduce using rule 18 (unary_expr -> unary_operator cast_expr .)



state 202

    (16) unary_expr -> INC_OP unary_expr .

    =               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    MUL_ASSIGN      reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    DIV_ASSIGN      reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    MOD_ASSIGN      reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    ADD_ASSIGN      reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    SUB_ASSIGN      reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    LEFT_ASSIGN     reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    RIGHT_ASSIGN    reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    AND_ASSIGN      reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    XOR_ASSIGN      reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    OR_ASSIGN       reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    *               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    /               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    %               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    +               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    -               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    LEFT_OP         reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    RIGHT_OP        reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    <               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    >               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    LE_OP           reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    GE_OP           reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    EQ_OP           reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    NE_OP           reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    &               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    ^               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    |               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    AND_OP          reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    ?               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    OR_OP           reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    ;               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    ,               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    )               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
                    reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    :               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    ]               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)
    }               reduce using rule 16 (unary_expr -> INC_OP unary_expr .)



state 203

    (118) enum_specifier -> ENUM identifier { enumerator_list . }
    (121) enumerator_list -> enumerator_list . , enumerator

    }               shift and go to state 289
    ,               shift and go to state 204



state 204

    (121) enumerator_list -> enumerator_list , . enumerator
    (122) enumerator -> . identifier
    (123) enumerator -> . identifier = constant_expr
    (216) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 21


    identifier                     shift and go to state 114
    enumerator                     shift and go to state 290

state 205

    (117) enum_specifier -> ENUM { enumerator_list } .

    CHAR            reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    SHORT           reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    INT             reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    LONG            reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    SIGNED          reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    UNSIGNED        reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    FLOAT           reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    DOUBLE          reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    CONST           reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    VOLATILE        reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    VOID            reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    TYPE_NAME       reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    (               reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    *               reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    ENUM            reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    [               reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    IDENTIFIER      reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    STRUCT          reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    UNION           reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    ,               reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    )               reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    TYPEDEF         reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    EXTERN          reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    STATIC          reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    AUTO            reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    REGISTER        reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
                    reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)
    :               reduce using rule 117 (enum_specifier -> ENUM { enumerator_list } .)



state 206

    (123) enumerator -> identifier = . constant_expr
    (74) constant_expr -> . conditional_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    conditional_expr               shift and go to state 97
    logical_and_expr               shift and go to state 102
    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    exclusive_or_expr              shift and go to state 101
    relational_expr                shift and go to state 94
    postfix_expr                   shift and go to state 99
    constant_expr                  shift and go to state 291
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    logical_or_expr                shift and go to state 84
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    unary_operator                 shift and go to state 105
    equality_expr                  shift and go to state 90
    identifier                     shift and go to state 98
    additive_expr                  shift and go to state 77
    and_expr                       shift and go to state 93

state 207

    (84) init_declarator -> declarator = initializer .

                    reduce using rule 84 (init_declarator -> declarator = initializer .)
    ,               reduce using rule 84 (init_declarator -> declarator = initializer .)



state 208

    (163) initializer -> assignment_expr .

    }               reduce using rule 163 (initializer -> assignment_expr .)
    ,               reduce using rule 163 (initializer -> assignment_expr .)
                    reduce using rule 163 (initializer -> assignment_expr .)



state 209

    (164) initializer -> { . initializer_list }
    (165) initializer -> { . initializer_list , }
    (166) initializer_list -> . initializer
    (167) initializer_list -> . initializer_list , initializer
    (163) initializer -> . assignment_expr
    (164) initializer -> . { initializer_list }
    (165) initializer -> . { initializer_list , }
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    {               shift and go to state 209
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    equality_expr                  shift and go to state 90
    unary_expr                     shift and go to state 133
    initializer                    shift and go to state 292
    logical_or_expr                shift and go to state 84
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    logical_and_expr               shift and go to state 102
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    initializer_list               shift and go to state 293
    assignment_expr                shift and go to state 208
    identifier                     shift and go to state 98

state 210

    (82) init_declarator_list -> init_declarator_list , init_declarator .

                    reduce using rule 82 (init_declarator_list -> init_declarator_list , init_declarator .)
    ,               reduce using rule 82 (init_declarator_list -> init_declarator_list , init_declarator .)



state 211

    (202) jump_statement -> GOTO identifier . ;

    ;               shift and go to state 294



state 212

    (181) compound_statement -> left_bracket declaration_list right_bracket .

    }               reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    CASE            reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    DEFAULT         reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    ;               reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    IF              reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    SWITCH          reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    WHILE           reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    DO              reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    FOR             reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    GOTO            reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    CONTINUE        reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    BREAK           reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    RETURN          reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    IDENTIFIER      reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    {               reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    INC_OP          reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    DEC_OP          reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    SIZEOF          reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    &               reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    *               reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    +               reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    -               reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    ~               reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    !               reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    CONSTANT        reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    STRING_LITERAL  reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    (               reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    ELSE            reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    TYPEDEF         reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    EXTERN          reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    STATIC          reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    AUTO            reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    REGISTER        reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    CHAR            reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    SHORT           reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    INT             reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    LONG            reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    SIGNED          reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    UNSIGNED        reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    FLOAT           reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    DOUBLE          reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    CONST           reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    VOLATILE        reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    VOID            reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    TYPE_NAME       reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    ENUM            reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    STRUCT          reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    UNION           reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)
    $end            reduce using rule 181 (compound_statement -> left_bracket declaration_list right_bracket .)



state 213

    (182) compound_statement -> left_bracket declaration_list statement_list . right_bracket
    (186) statement_list -> statement_list . statement
    (178) right_bracket -> . }
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    }               shift and go to state 147
    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 219
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    right_bracket                  shift and go to state 295
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 214

    (174) labeled_statement -> identifier : . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 296
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 215

    (205) jump_statement -> RETURN ; .

    }               reduce using rule 205 (jump_statement -> RETURN ; .)
    CASE            reduce using rule 205 (jump_statement -> RETURN ; .)
    DEFAULT         reduce using rule 205 (jump_statement -> RETURN ; .)
    ;               reduce using rule 205 (jump_statement -> RETURN ; .)
    IF              reduce using rule 205 (jump_statement -> RETURN ; .)
    SWITCH          reduce using rule 205 (jump_statement -> RETURN ; .)
    WHILE           reduce using rule 205 (jump_statement -> RETURN ; .)
    DO              reduce using rule 205 (jump_statement -> RETURN ; .)
    FOR             reduce using rule 205 (jump_statement -> RETURN ; .)
    GOTO            reduce using rule 205 (jump_statement -> RETURN ; .)
    CONTINUE        reduce using rule 205 (jump_statement -> RETURN ; .)
    BREAK           reduce using rule 205 (jump_statement -> RETURN ; .)
    RETURN          reduce using rule 205 (jump_statement -> RETURN ; .)
    IDENTIFIER      reduce using rule 205 (jump_statement -> RETURN ; .)
    {               reduce using rule 205 (jump_statement -> RETURN ; .)
    INC_OP          reduce using rule 205 (jump_statement -> RETURN ; .)
    DEC_OP          reduce using rule 205 (jump_statement -> RETURN ; .)
    SIZEOF          reduce using rule 205 (jump_statement -> RETURN ; .)
    &               reduce using rule 205 (jump_statement -> RETURN ; .)
    *               reduce using rule 205 (jump_statement -> RETURN ; .)
    +               reduce using rule 205 (jump_statement -> RETURN ; .)
    -               reduce using rule 205 (jump_statement -> RETURN ; .)
    ~               reduce using rule 205 (jump_statement -> RETURN ; .)
    !               reduce using rule 205 (jump_statement -> RETURN ; .)
    CONSTANT        reduce using rule 205 (jump_statement -> RETURN ; .)
    STRING_LITERAL  reduce using rule 205 (jump_statement -> RETURN ; .)
    (               reduce using rule 205 (jump_statement -> RETURN ; .)
    ELSE            reduce using rule 205 (jump_statement -> RETURN ; .)



state 216

    (206) jump_statement -> RETURN expr . ;
    (73) expr -> expr . , assignment_expr

    ;               shift and go to state 297
    ,               shift and go to state 238



state 217

    (194) iteration_statement -> FOR ( . ; ; ) statement
    (195) iteration_statement -> FOR ( . ; ; expr ) statement
    (196) iteration_statement -> FOR ( . ; expr ; ) statement
    (197) iteration_statement -> FOR ( . ; expr ; expr ) statement
    (198) iteration_statement -> FOR ( . expr ; ; ) statement
    (199) iteration_statement -> FOR ( . expr ; ; expr ) statement
    (200) iteration_statement -> FOR ( . expr ; expr ; ) statement
    (201) iteration_statement -> FOR ( . expr ; expr ; expr ) statement
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    ;               shift and go to state 298
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 299
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 218

    (203) jump_statement -> CONTINUE ; .

    }               reduce using rule 203 (jump_statement -> CONTINUE ; .)
    CASE            reduce using rule 203 (jump_statement -> CONTINUE ; .)
    DEFAULT         reduce using rule 203 (jump_statement -> CONTINUE ; .)
    ;               reduce using rule 203 (jump_statement -> CONTINUE ; .)
    IF              reduce using rule 203 (jump_statement -> CONTINUE ; .)
    SWITCH          reduce using rule 203 (jump_statement -> CONTINUE ; .)
    WHILE           reduce using rule 203 (jump_statement -> CONTINUE ; .)
    DO              reduce using rule 203 (jump_statement -> CONTINUE ; .)
    FOR             reduce using rule 203 (jump_statement -> CONTINUE ; .)
    GOTO            reduce using rule 203 (jump_statement -> CONTINUE ; .)
    CONTINUE        reduce using rule 203 (jump_statement -> CONTINUE ; .)
    BREAK           reduce using rule 203 (jump_statement -> CONTINUE ; .)
    RETURN          reduce using rule 203 (jump_statement -> CONTINUE ; .)
    IDENTIFIER      reduce using rule 203 (jump_statement -> CONTINUE ; .)
    {               reduce using rule 203 (jump_statement -> CONTINUE ; .)
    INC_OP          reduce using rule 203 (jump_statement -> CONTINUE ; .)
    DEC_OP          reduce using rule 203 (jump_statement -> CONTINUE ; .)
    SIZEOF          reduce using rule 203 (jump_statement -> CONTINUE ; .)
    &               reduce using rule 203 (jump_statement -> CONTINUE ; .)
    *               reduce using rule 203 (jump_statement -> CONTINUE ; .)
    +               reduce using rule 203 (jump_statement -> CONTINUE ; .)
    -               reduce using rule 203 (jump_statement -> CONTINUE ; .)
    ~               reduce using rule 203 (jump_statement -> CONTINUE ; .)
    !               reduce using rule 203 (jump_statement -> CONTINUE ; .)
    CONSTANT        reduce using rule 203 (jump_statement -> CONTINUE ; .)
    STRING_LITERAL  reduce using rule 203 (jump_statement -> CONTINUE ; .)
    (               reduce using rule 203 (jump_statement -> CONTINUE ; .)
    ELSE            reduce using rule 203 (jump_statement -> CONTINUE ; .)



state 219

    (186) statement_list -> statement_list statement .

    }               reduce using rule 186 (statement_list -> statement_list statement .)
    CASE            reduce using rule 186 (statement_list -> statement_list statement .)
    DEFAULT         reduce using rule 186 (statement_list -> statement_list statement .)
    ;               reduce using rule 186 (statement_list -> statement_list statement .)
    IF              reduce using rule 186 (statement_list -> statement_list statement .)
    SWITCH          reduce using rule 186 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 186 (statement_list -> statement_list statement .)
    DO              reduce using rule 186 (statement_list -> statement_list statement .)
    FOR             reduce using rule 186 (statement_list -> statement_list statement .)
    GOTO            reduce using rule 186 (statement_list -> statement_list statement .)
    CONTINUE        reduce using rule 186 (statement_list -> statement_list statement .)
    BREAK           reduce using rule 186 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 186 (statement_list -> statement_list statement .)
    IDENTIFIER      reduce using rule 186 (statement_list -> statement_list statement .)
    {               reduce using rule 186 (statement_list -> statement_list statement .)
    INC_OP          reduce using rule 186 (statement_list -> statement_list statement .)
    DEC_OP          reduce using rule 186 (statement_list -> statement_list statement .)
    SIZEOF          reduce using rule 186 (statement_list -> statement_list statement .)
    &               reduce using rule 186 (statement_list -> statement_list statement .)
    *               reduce using rule 186 (statement_list -> statement_list statement .)
    +               reduce using rule 186 (statement_list -> statement_list statement .)
    -               reduce using rule 186 (statement_list -> statement_list statement .)
    ~               reduce using rule 186 (statement_list -> statement_list statement .)
    !               reduce using rule 186 (statement_list -> statement_list statement .)
    CONSTANT        reduce using rule 186 (statement_list -> statement_list statement .)
    STRING_LITERAL  reduce using rule 186 (statement_list -> statement_list statement .)
    (               reduce using rule 186 (statement_list -> statement_list statement .)



state 220

    (180) compound_statement -> left_bracket statement_list right_bracket .

    }               reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    CASE            reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    DEFAULT         reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    ;               reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    IF              reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    SWITCH          reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    WHILE           reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    DO              reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    FOR             reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    GOTO            reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    CONTINUE        reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    BREAK           reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    RETURN          reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    IDENTIFIER      reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    {               reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    INC_OP          reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    DEC_OP          reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    SIZEOF          reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    &               reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    *               reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    +               reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    -               reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    ~               reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    !               reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    CONSTANT        reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    STRING_LITERAL  reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    (               reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    ELSE            reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    TYPEDEF         reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    EXTERN          reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    STATIC          reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    AUTO            reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    REGISTER        reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    CHAR            reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    SHORT           reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    INT             reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    LONG            reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    SIGNED          reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    UNSIGNED        reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    FLOAT           reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    DOUBLE          reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    CONST           reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    VOLATILE        reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    VOID            reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    TYPE_NAME       reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    ENUM            reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    STRUCT          reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    UNION           reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)
    $end            reduce using rule 180 (compound_statement -> left_bracket statement_list right_bracket .)



state 221

    (66) assignment_operator -> SUB_ASSIGN .

    INC_OP          reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)
    DEC_OP          reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)
    SIZEOF          reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)
    &               reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)
    *               reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)
    +               reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)
    -               reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)
    ~               reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)
    !               reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)
    CONSTANT        reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)
    STRING_LITERAL  reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)
    (               reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)
    IDENTIFIER      reduce using rule 66 (assignment_operator -> SUB_ASSIGN .)



state 222

    (64) assignment_operator -> MOD_ASSIGN .

    INC_OP          reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)
    DEC_OP          reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)
    SIZEOF          reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)
    &               reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)
    *               reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)
    +               reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)
    -               reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)
    ~               reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)
    !               reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)
    CONSTANT        reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)
    STRING_LITERAL  reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)
    (               reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)
    IDENTIFIER      reduce using rule 64 (assignment_operator -> MOD_ASSIGN .)



state 223

    (68) assignment_operator -> RIGHT_ASSIGN .

    INC_OP          reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)
    DEC_OP          reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)
    SIZEOF          reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)
    &               reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)
    *               reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)
    +               reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)
    -               reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)
    ~               reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)
    !               reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)
    CONSTANT        reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)
    STRING_LITERAL  reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)
    (               reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)
    IDENTIFIER      reduce using rule 68 (assignment_operator -> RIGHT_ASSIGN .)



state 224

    (70) assignment_operator -> XOR_ASSIGN .

    INC_OP          reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)
    DEC_OP          reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)
    SIZEOF          reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)
    &               reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)
    *               reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)
    +               reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)
    -               reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)
    ~               reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)
    !               reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)
    CONSTANT        reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)
    STRING_LITERAL  reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)
    (               reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)
    IDENTIFIER      reduce using rule 70 (assignment_operator -> XOR_ASSIGN .)



state 225

    (71) assignment_operator -> OR_ASSIGN .

    INC_OP          reduce using rule 71 (assignment_operator -> OR_ASSIGN .)
    DEC_OP          reduce using rule 71 (assignment_operator -> OR_ASSIGN .)
    SIZEOF          reduce using rule 71 (assignment_operator -> OR_ASSIGN .)
    &               reduce using rule 71 (assignment_operator -> OR_ASSIGN .)
    *               reduce using rule 71 (assignment_operator -> OR_ASSIGN .)
    +               reduce using rule 71 (assignment_operator -> OR_ASSIGN .)
    -               reduce using rule 71 (assignment_operator -> OR_ASSIGN .)
    ~               reduce using rule 71 (assignment_operator -> OR_ASSIGN .)
    !               reduce using rule 71 (assignment_operator -> OR_ASSIGN .)
    CONSTANT        reduce using rule 71 (assignment_operator -> OR_ASSIGN .)
    STRING_LITERAL  reduce using rule 71 (assignment_operator -> OR_ASSIGN .)
    (               reduce using rule 71 (assignment_operator -> OR_ASSIGN .)
    IDENTIFIER      reduce using rule 71 (assignment_operator -> OR_ASSIGN .)



state 226

    (69) assignment_operator -> AND_ASSIGN .

    INC_OP          reduce using rule 69 (assignment_operator -> AND_ASSIGN .)
    DEC_OP          reduce using rule 69 (assignment_operator -> AND_ASSIGN .)
    SIZEOF          reduce using rule 69 (assignment_operator -> AND_ASSIGN .)
    &               reduce using rule 69 (assignment_operator -> AND_ASSIGN .)
    *               reduce using rule 69 (assignment_operator -> AND_ASSIGN .)
    +               reduce using rule 69 (assignment_operator -> AND_ASSIGN .)
    -               reduce using rule 69 (assignment_operator -> AND_ASSIGN .)
    ~               reduce using rule 69 (assignment_operator -> AND_ASSIGN .)
    !               reduce using rule 69 (assignment_operator -> AND_ASSIGN .)
    CONSTANT        reduce using rule 69 (assignment_operator -> AND_ASSIGN .)
    STRING_LITERAL  reduce using rule 69 (assignment_operator -> AND_ASSIGN .)
    (               reduce using rule 69 (assignment_operator -> AND_ASSIGN .)
    IDENTIFIER      reduce using rule 69 (assignment_operator -> AND_ASSIGN .)



state 227

    (62) assignment_operator -> MUL_ASSIGN .

    INC_OP          reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)
    DEC_OP          reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)
    SIZEOF          reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)
    &               reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)
    *               reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)
    +               reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)
    -               reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)
    ~               reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)
    !               reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)
    CONSTANT        reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)
    STRING_LITERAL  reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)
    (               reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)
    IDENTIFIER      reduce using rule 62 (assignment_operator -> MUL_ASSIGN .)



state 228

    (60) assignment_expr -> unary_expr assignment_operator . assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 300
    identifier                     shift and go to state 98

state 229

    (67) assignment_operator -> LEFT_ASSIGN .

    INC_OP          reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)
    DEC_OP          reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)
    SIZEOF          reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)
    &               reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)
    *               reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)
    +               reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)
    -               reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)
    ~               reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)
    !               reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)
    CONSTANT        reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)
    STRING_LITERAL  reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)
    (               reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)
    IDENTIFIER      reduce using rule 67 (assignment_operator -> LEFT_ASSIGN .)



state 230

    (61) assignment_operator -> = .

    INC_OP          reduce using rule 61 (assignment_operator -> = .)
    DEC_OP          reduce using rule 61 (assignment_operator -> = .)
    SIZEOF          reduce using rule 61 (assignment_operator -> = .)
    &               reduce using rule 61 (assignment_operator -> = .)
    *               reduce using rule 61 (assignment_operator -> = .)
    +               reduce using rule 61 (assignment_operator -> = .)
    -               reduce using rule 61 (assignment_operator -> = .)
    ~               reduce using rule 61 (assignment_operator -> = .)
    !               reduce using rule 61 (assignment_operator -> = .)
    CONSTANT        reduce using rule 61 (assignment_operator -> = .)
    STRING_LITERAL  reduce using rule 61 (assignment_operator -> = .)
    (               reduce using rule 61 (assignment_operator -> = .)
    IDENTIFIER      reduce using rule 61 (assignment_operator -> = .)



state 231

    (65) assignment_operator -> ADD_ASSIGN .

    INC_OP          reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)
    DEC_OP          reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)
    SIZEOF          reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)
    &               reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)
    *               reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)
    +               reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)
    -               reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)
    ~               reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)
    !               reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)
    CONSTANT        reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)
    STRING_LITERAL  reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)
    (               reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)
    IDENTIFIER      reduce using rule 65 (assignment_operator -> ADD_ASSIGN .)



state 232

    (63) assignment_operator -> DIV_ASSIGN .

    INC_OP          reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)
    DEC_OP          reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)
    SIZEOF          reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)
    &               reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)
    *               reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)
    +               reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)
    -               reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)
    ~               reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)
    !               reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)
    CONSTANT        reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)
    STRING_LITERAL  reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)
    (               reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)
    IDENTIFIER      reduce using rule 63 (assignment_operator -> DIV_ASSIGN .)



state 233

    (176) labeled_statement -> DEFAULT : . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 301
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 234

    (192) iteration_statement -> WHILE ( . expr ) statement
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 302
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 235

    (175) labeled_statement -> CASE constant_expr . : statement

    :               shift and go to state 303



state 236

    (191) selection_statement -> SWITCH ( . expr ) statement
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 304
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 237

    (188) expression_statement -> expr ; .

    }               reduce using rule 188 (expression_statement -> expr ; .)
    CASE            reduce using rule 188 (expression_statement -> expr ; .)
    DEFAULT         reduce using rule 188 (expression_statement -> expr ; .)
    ;               reduce using rule 188 (expression_statement -> expr ; .)
    IF              reduce using rule 188 (expression_statement -> expr ; .)
    SWITCH          reduce using rule 188 (expression_statement -> expr ; .)
    WHILE           reduce using rule 188 (expression_statement -> expr ; .)
    DO              reduce using rule 188 (expression_statement -> expr ; .)
    FOR             reduce using rule 188 (expression_statement -> expr ; .)
    GOTO            reduce using rule 188 (expression_statement -> expr ; .)
    CONTINUE        reduce using rule 188 (expression_statement -> expr ; .)
    BREAK           reduce using rule 188 (expression_statement -> expr ; .)
    RETURN          reduce using rule 188 (expression_statement -> expr ; .)
    IDENTIFIER      reduce using rule 188 (expression_statement -> expr ; .)
    {               reduce using rule 188 (expression_statement -> expr ; .)
    INC_OP          reduce using rule 188 (expression_statement -> expr ; .)
    DEC_OP          reduce using rule 188 (expression_statement -> expr ; .)
    SIZEOF          reduce using rule 188 (expression_statement -> expr ; .)
    &               reduce using rule 188 (expression_statement -> expr ; .)
    *               reduce using rule 188 (expression_statement -> expr ; .)
    +               reduce using rule 188 (expression_statement -> expr ; .)
    -               reduce using rule 188 (expression_statement -> expr ; .)
    ~               reduce using rule 188 (expression_statement -> expr ; .)
    !               reduce using rule 188 (expression_statement -> expr ; .)
    CONSTANT        reduce using rule 188 (expression_statement -> expr ; .)
    STRING_LITERAL  reduce using rule 188 (expression_statement -> expr ; .)
    (               reduce using rule 188 (expression_statement -> expr ; .)
    ELSE            reduce using rule 188 (expression_statement -> expr ; .)



state 238

    (73) expr -> expr , . assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 305
    identifier                     shift and go to state 98

state 239

    (204) jump_statement -> BREAK ; .

    }               reduce using rule 204 (jump_statement -> BREAK ; .)
    CASE            reduce using rule 204 (jump_statement -> BREAK ; .)
    DEFAULT         reduce using rule 204 (jump_statement -> BREAK ; .)
    ;               reduce using rule 204 (jump_statement -> BREAK ; .)
    IF              reduce using rule 204 (jump_statement -> BREAK ; .)
    SWITCH          reduce using rule 204 (jump_statement -> BREAK ; .)
    WHILE           reduce using rule 204 (jump_statement -> BREAK ; .)
    DO              reduce using rule 204 (jump_statement -> BREAK ; .)
    FOR             reduce using rule 204 (jump_statement -> BREAK ; .)
    GOTO            reduce using rule 204 (jump_statement -> BREAK ; .)
    CONTINUE        reduce using rule 204 (jump_statement -> BREAK ; .)
    BREAK           reduce using rule 204 (jump_statement -> BREAK ; .)
    RETURN          reduce using rule 204 (jump_statement -> BREAK ; .)
    IDENTIFIER      reduce using rule 204 (jump_statement -> BREAK ; .)
    {               reduce using rule 204 (jump_statement -> BREAK ; .)
    INC_OP          reduce using rule 204 (jump_statement -> BREAK ; .)
    DEC_OP          reduce using rule 204 (jump_statement -> BREAK ; .)
    SIZEOF          reduce using rule 204 (jump_statement -> BREAK ; .)
    &               reduce using rule 204 (jump_statement -> BREAK ; .)
    *               reduce using rule 204 (jump_statement -> BREAK ; .)
    +               reduce using rule 204 (jump_statement -> BREAK ; .)
    -               reduce using rule 204 (jump_statement -> BREAK ; .)
    ~               reduce using rule 204 (jump_statement -> BREAK ; .)
    !               reduce using rule 204 (jump_statement -> BREAK ; .)
    CONSTANT        reduce using rule 204 (jump_statement -> BREAK ; .)
    STRING_LITERAL  reduce using rule 204 (jump_statement -> BREAK ; .)
    (               reduce using rule 204 (jump_statement -> BREAK ; .)
    ELSE            reduce using rule 204 (jump_statement -> BREAK ; .)



state 240

    (193) iteration_statement -> DO statement . WHILE ( expr ) ;

    WHILE           shift and go to state 306



state 241

    (189) selection_statement -> IF ( . expr ) statement
    (190) selection_statement -> IF ( . expr ) statement ELSE statement
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 307
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 242

    (104) struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .

    CHAR            reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    SHORT           reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    INT             reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    LONG            reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    SIGNED          reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    UNSIGNED        reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    FLOAT           reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    DOUBLE          reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    CONST           reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    VOLATILE        reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    VOID            reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    TYPE_NAME       reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    (               reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    *               reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    ENUM            reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    [               reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    IDENTIFIER      reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    STRUCT          reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    UNION           reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    ,               reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    )               reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    TYPEDEF         reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    EXTERN          reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    STATIC          reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    AUTO            reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    REGISTER        reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
                    reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)
    :               reduce using rule 104 (struct_or_union_specifier -> struct_or_union identifier { struct_declaration_list } .)



state 243

    (115) struct_declarator -> : constant_expr .

                    reduce using rule 115 (struct_declarator -> : constant_expr .)
    ,               reduce using rule 115 (struct_declarator -> : constant_expr .)



state 244

    (111) struct_declaration -> type_specifier_list struct_declarator_list  .

    }               reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    CHAR            reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    SHORT           reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    INT             reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    LONG            reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    SIGNED          reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    UNSIGNED        reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    FLOAT           reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    DOUBLE          reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    CONST           reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    VOLATILE        reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    VOID            reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    TYPE_NAME       reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    ENUM            reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    STRUCT          reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)
    UNION           reduce using rule 111 (struct_declaration -> type_specifier_list struct_declarator_list  .)



state 245

    (113) struct_declarator_list -> struct_declarator_list , . struct_declarator
    (114) struct_declarator -> . declarator
    (115) struct_declarator -> . : constant_expr
    (116) struct_declarator -> . declarator : constant_expr
    (124) declarator -> . declarator2
    (125) declarator -> . pointer declarator2
    (126) declarator2 -> . identifier
    (127) declarator2 -> . ( declarator )
    (128) declarator2 -> . declarator2 [ ]
    (129) declarator2 -> . declarator2 [ constant_expr ]
    (130) declarator2 -> . declarator2 ( )
    (131) declarator2 -> . declarator2 ( parameter_type_list )
    (132) declarator2 -> . declarator2 ( parameter_identifier_list )
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (216) identifier -> . IDENTIFIER

    :               shift and go to state 154
    (               shift and go to state 16
    *               shift and go to state 17
    IDENTIFIER      shift and go to state 21


    struct_declarator              shift and go to state 308
    declarator2                    shift and go to state 7
    declarator                     shift and go to state 157
    identifier                     shift and go to state 37
    pointer                        shift and go to state 14

state 246

    (116) struct_declarator -> declarator : . constant_expr
    (74) constant_expr -> . conditional_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    equality_expr                  shift and go to state 90
    unary_expr                     shift and go to state 79
    constant_expr                  shift and go to state 309
    logical_or_expr                shift and go to state 84
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    conditional_expr               shift and go to state 97
    exclusive_or_expr              shift and go to state 101
    logical_and_expr               shift and go to state 102
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98

state 247

    (153) abstract_declarator -> pointer abstract_declarator2 .
    (157) abstract_declarator2 -> abstract_declarator2 . [ ]
    (158) abstract_declarator2 -> abstract_declarator2 . [ constant_expr ]
    (161) abstract_declarator2 -> abstract_declarator2 . ( )
    (162) abstract_declarator2 -> abstract_declarator2 . ( parameter_type_list )

    )               reduce using rule 153 (abstract_declarator -> pointer abstract_declarator2 .)
    ,               reduce using rule 153 (abstract_declarator -> pointer abstract_declarator2 .)
    [               shift and go to state 252
    (               shift and go to state 251



state 248

    (159) abstract_declarator2 -> ( ) .

    [               reduce using rule 159 (abstract_declarator2 -> ( ) .)
    (               reduce using rule 159 (abstract_declarator2 -> ( ) .)
    )               reduce using rule 159 (abstract_declarator2 -> ( ) .)
    ,               reduce using rule 159 (abstract_declarator2 -> ( ) .)



state 249

    (160) abstract_declarator2 -> ( parameter_type_list . )

    )               shift and go to state 310



state 250

    (154) abstract_declarator2 -> ( abstract_declarator . )

    )               shift and go to state 311



state 251

    (161) abstract_declarator2 -> abstract_declarator2 ( . )
    (162) abstract_declarator2 -> abstract_declarator2 ( . parameter_type_list )
    (143) parameter_type_list -> . parameter_list
    (144) parameter_type_list -> . parameter_list , ELIPSIS
    (145) parameter_list -> . parameter_declaration
    (146) parameter_list -> . parameter_list , parameter_declaration
    (147) parameter_declaration -> . type_specifier_list declarator
    (148) parameter_declaration -> . type_name
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (149) type_name -> . type_specifier_list
    (150) type_name -> . type_specifier_list abstract_declarator
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    )               shift and go to state 312
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    type_specifier                 shift and go to state 48
    parameter_list                 shift and go to state 75
    parameter_type_list            shift and go to state 313
    parameter_declaration          shift and go to state 71
    type_name                      shift and go to state 69
    enum_specifier                 shift and go to state 33
    type_specifier_list            shift and go to state 73
    struct_or_union_specifier      shift and go to state 4

state 252

    (157) abstract_declarator2 -> abstract_declarator2 [ . ]
    (158) abstract_declarator2 -> abstract_declarator2 [ . constant_expr ]
    (74) constant_expr -> . conditional_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    ]               shift and go to state 315
    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    equality_expr                  shift and go to state 90
    unary_expr                     shift and go to state 79
    constant_expr                  shift and go to state 314
    logical_or_expr                shift and go to state 84
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    conditional_expr               shift and go to state 97
    exclusive_or_expr              shift and go to state 101
    logical_and_expr               shift and go to state 102
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98

state 253

    (156) abstract_declarator2 -> [ constant_expr . ]

    ]               shift and go to state 316



state 254

    (155) abstract_declarator2 -> [ ] .

    [               reduce using rule 155 (abstract_declarator2 -> [ ] .)
    (               reduce using rule 155 (abstract_declarator2 -> [ ] .)
    )               reduce using rule 155 (abstract_declarator2 -> [ ] .)
    ,               reduce using rule 155 (abstract_declarator2 -> [ ] .)



state 255

    (140) parameter_identifier_list -> identifier_list , ELIPSIS .

    )               reduce using rule 140 (parameter_identifier_list -> identifier_list , ELIPSIS .)



state 256

    (142) identifier_list -> identifier_list , identifier .

    ,               reduce using rule 142 (identifier_list -> identifier_list , identifier .)
    )               reduce using rule 142 (identifier_list -> identifier_list , identifier .)



state 257

    (144) parameter_type_list -> parameter_list , ELIPSIS .

    )               reduce using rule 144 (parameter_type_list -> parameter_list , ELIPSIS .)



state 258

    (146) parameter_list -> parameter_list , parameter_declaration .

    ,               reduce using rule 146 (parameter_list -> parameter_list , parameter_declaration .)
    )               reduce using rule 146 (parameter_list -> parameter_list , parameter_declaration .)



state 259

    (34) additive_expr -> additive_expr + multiplicative_expr .
    (30) multiplicative_expr -> multiplicative_expr . * cast_expr
    (31) multiplicative_expr -> multiplicative_expr . / cast_expr
    (32) multiplicative_expr -> multiplicative_expr . % cast_expr

    +               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    -               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    LEFT_OP         reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    RIGHT_OP        reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    <               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    >               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    LE_OP           reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    GE_OP           reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    EQ_OP           reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    NE_OP           reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    &               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    ^               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    |               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    AND_OP          reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    ?               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    OR_OP           reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    ;               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    ,               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    }               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    ]               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    )               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
                    reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    :               reduce using rule 34 (additive_expr -> additive_expr + multiplicative_expr .)
    *               shift and go to state 185
    /               shift and go to state 186
    %               shift and go to state 184



state 260

    (35) additive_expr -> additive_expr - multiplicative_expr .
    (30) multiplicative_expr -> multiplicative_expr . * cast_expr
    (31) multiplicative_expr -> multiplicative_expr . / cast_expr
    (32) multiplicative_expr -> multiplicative_expr . % cast_expr

    +               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    -               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    LEFT_OP         reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    RIGHT_OP        reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    <               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    >               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    LE_OP           reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    GE_OP           reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    EQ_OP           reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    NE_OP           reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    &               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    ^               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    |               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    AND_OP          reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    ?               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    OR_OP           reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    ;               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    ,               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    }               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    ]               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    )               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
                    reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    :               reduce using rule 35 (additive_expr -> additive_expr - multiplicative_expr .)
    *               shift and go to state 185
    /               shift and go to state 186
    %               shift and go to state 184



state 261

    (56) logical_or_expr -> logical_or_expr OR_OP logical_and_expr .
    (54) logical_and_expr -> logical_and_expr . AND_OP inclusive_or_expr

    ?               reduce using rule 56 (logical_or_expr -> logical_or_expr OR_OP logical_and_expr .)
    OR_OP           reduce using rule 56 (logical_or_expr -> logical_or_expr OR_OP logical_and_expr .)
    ;               reduce using rule 56 (logical_or_expr -> logical_or_expr OR_OP logical_and_expr .)
    ,               reduce using rule 56 (logical_or_expr -> logical_or_expr OR_OP logical_and_expr .)
    )               reduce using rule 56 (logical_or_expr -> logical_or_expr OR_OP logical_and_expr .)
                    reduce using rule 56 (logical_or_expr -> logical_or_expr OR_OP logical_and_expr .)
    ]               reduce using rule 56 (logical_or_expr -> logical_or_expr OR_OP logical_and_expr .)
    }               reduce using rule 56 (logical_or_expr -> logical_or_expr OR_OP logical_and_expr .)
    :               reduce using rule 56 (logical_or_expr -> logical_or_expr OR_OP logical_and_expr .)
    AND_OP          shift and go to state 199



state 262

    (58) conditional_expr -> logical_or_expr ? logical_or_expr . : conditional_expr
    (56) logical_or_expr -> logical_or_expr . OR_OP logical_and_expr

    :               shift and go to state 317
    OR_OP           shift and go to state 173



state 263

    (20) unary_expr -> SIZEOF ( type_name . )

    )               shift and go to state 318



state 264

    (28) cast_expr -> ( type_name ) . cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    cast_expr                      shift and go to state 319
    postfix_expr                   shift and go to state 99
    unary_expr                     shift and go to state 79
    primary_expr                   shift and go to state 104
    identifier                     shift and go to state 98
    unary_operator                 shift and go to state 105

state 265

    (151) abstract_declarator -> pointer .
    (153) abstract_declarator -> pointer . abstract_declarator2
    (154) abstract_declarator2 -> . ( abstract_declarator )
    (155) abstract_declarator2 -> . [ ]
    (156) abstract_declarator2 -> . [ constant_expr ]
    (157) abstract_declarator2 -> . abstract_declarator2 [ ]
    (158) abstract_declarator2 -> . abstract_declarator2 [ constant_expr ]
    (159) abstract_declarator2 -> . ( )
    (160) abstract_declarator2 -> . ( parameter_type_list )
    (161) abstract_declarator2 -> . abstract_declarator2 ( )
    (162) abstract_declarator2 -> . abstract_declarator2 ( parameter_type_list )

    )               reduce using rule 151 (abstract_declarator -> pointer .)
    (               shift and go to state 266
    [               shift and go to state 163


    abstract_declarator2           shift and go to state 247

state 266

    (154) abstract_declarator2 -> ( . abstract_declarator )
    (159) abstract_declarator2 -> ( . )
    (160) abstract_declarator2 -> ( . parameter_type_list )
    (151) abstract_declarator -> . pointer
    (152) abstract_declarator -> . abstract_declarator2
    (153) abstract_declarator -> . pointer abstract_declarator2
    (143) parameter_type_list -> . parameter_list
    (144) parameter_type_list -> . parameter_list , ELIPSIS
    (133) pointer -> . *
    (134) pointer -> . * type_specifier_list
    (135) pointer -> . * pointer
    (136) pointer -> . * type_specifier_list pointer
    (154) abstract_declarator2 -> . ( abstract_declarator )
    (155) abstract_declarator2 -> . [ ]
    (156) abstract_declarator2 -> . [ constant_expr ]
    (157) abstract_declarator2 -> . abstract_declarator2 [ ]
    (158) abstract_declarator2 -> . abstract_declarator2 [ constant_expr ]
    (159) abstract_declarator2 -> . ( )
    (160) abstract_declarator2 -> . ( parameter_type_list )
    (161) abstract_declarator2 -> . abstract_declarator2 ( )
    (162) abstract_declarator2 -> . abstract_declarator2 ( parameter_type_list )
    (145) parameter_list -> . parameter_declaration
    (146) parameter_list -> . parameter_list , parameter_declaration
    (147) parameter_declaration -> . type_specifier_list declarator
    (148) parameter_declaration -> . type_name
    (137) type_specifier_list -> . type_specifier
    (138) type_specifier_list -> . type_specifier_list type_specifier
    (149) type_name -> . type_specifier_list
    (150) type_name -> . type_specifier_list abstract_declarator
    (90) type_specifier -> . CHAR
    (91) type_specifier -> . SHORT
    (92) type_specifier -> . INT
    (93) type_specifier -> . LONG
    (94) type_specifier -> . SIGNED
    (95) type_specifier -> . UNSIGNED
    (96) type_specifier -> . FLOAT
    (97) type_specifier -> . DOUBLE
    (98) type_specifier -> . CONST
    (99) type_specifier -> . VOLATILE
    (100) type_specifier -> . VOID
    (101) type_specifier -> . struct_or_union_specifier
    (102) type_specifier -> . enum_specifier
    (103) type_specifier -> . TYPE_NAME
    (104) struct_or_union_specifier -> . struct_or_union identifier { struct_declaration_list }
    (105) struct_or_union_specifier -> . struct_or_union { struct_declaration_list }
    (106) struct_or_union_specifier -> . struct_or_union identifier
    (117) enum_specifier -> . ENUM { enumerator_list }
    (118) enum_specifier -> . ENUM identifier { enumerator_list }
    (119) enum_specifier -> . ENUM identifier
    (107) struct_or_union -> . STRUCT
    (108) struct_or_union -> . UNION

    )               shift and go to state 248
    *               shift and go to state 17
    (               shift and go to state 266
    [               shift and go to state 163
    CHAR            shift and go to state 8
    SHORT           shift and go to state 9
    INT             shift and go to state 29
    LONG            shift and go to state 19
    SIGNED          shift and go to state 32
    UNSIGNED        shift and go to state 18
    FLOAT           shift and go to state 31
    DOUBLE          shift and go to state 30
    CONST           shift and go to state 3
    VOLATILE        shift and go to state 34
    VOID            shift and go to state 5
    TYPE_NAME       shift and go to state 13
    ENUM            shift and go to state 24
    STRUCT          shift and go to state 28
    UNION           shift and go to state 20


    struct_or_union                shift and go to state 6
    type_name                      shift and go to state 69
    parameter_list                 shift and go to state 75
    parameter_type_list            shift and go to state 249
    parameter_declaration          shift and go to state 71
    abstract_declarator            shift and go to state 250
    enum_specifier                 shift and go to state 33
    abstract_declarator2           shift and go to state 162
    type_specifier_list            shift and go to state 73
    struct_or_union_specifier      shift and go to state 4
    type_specifier                 shift and go to state 48
    pointer                        shift and go to state 265

state 267

    (4) primary_expr -> ( expr ) .

    [               reduce using rule 4 (primary_expr -> ( expr ) .)
    (               reduce using rule 4 (primary_expr -> ( expr ) .)
    .               reduce using rule 4 (primary_expr -> ( expr ) .)
    PTR_OP          reduce using rule 4 (primary_expr -> ( expr ) .)
    INC_OP          reduce using rule 4 (primary_expr -> ( expr ) .)
    DEC_OP          reduce using rule 4 (primary_expr -> ( expr ) .)
    *               reduce using rule 4 (primary_expr -> ( expr ) .)
    /               reduce using rule 4 (primary_expr -> ( expr ) .)
    %               reduce using rule 4 (primary_expr -> ( expr ) .)
    +               reduce using rule 4 (primary_expr -> ( expr ) .)
    -               reduce using rule 4 (primary_expr -> ( expr ) .)
    LEFT_OP         reduce using rule 4 (primary_expr -> ( expr ) .)
    RIGHT_OP        reduce using rule 4 (primary_expr -> ( expr ) .)
    <               reduce using rule 4 (primary_expr -> ( expr ) .)
    >               reduce using rule 4 (primary_expr -> ( expr ) .)
    LE_OP           reduce using rule 4 (primary_expr -> ( expr ) .)
    GE_OP           reduce using rule 4 (primary_expr -> ( expr ) .)
    EQ_OP           reduce using rule 4 (primary_expr -> ( expr ) .)
    NE_OP           reduce using rule 4 (primary_expr -> ( expr ) .)
    &               reduce using rule 4 (primary_expr -> ( expr ) .)
    ^               reduce using rule 4 (primary_expr -> ( expr ) .)
    |               reduce using rule 4 (primary_expr -> ( expr ) .)
    AND_OP          reduce using rule 4 (primary_expr -> ( expr ) .)
    ?               reduce using rule 4 (primary_expr -> ( expr ) .)
    OR_OP           reduce using rule 4 (primary_expr -> ( expr ) .)
    ]               reduce using rule 4 (primary_expr -> ( expr ) .)
    ;               reduce using rule 4 (primary_expr -> ( expr ) .)
    ,               reduce using rule 4 (primary_expr -> ( expr ) .)
    )               reduce using rule 4 (primary_expr -> ( expr ) .)
                    reduce using rule 4 (primary_expr -> ( expr ) .)
    :               reduce using rule 4 (primary_expr -> ( expr ) .)
    }               reduce using rule 4 (primary_expr -> ( expr ) .)
    =               reduce using rule 4 (primary_expr -> ( expr ) .)
    MUL_ASSIGN      reduce using rule 4 (primary_expr -> ( expr ) .)
    DIV_ASSIGN      reduce using rule 4 (primary_expr -> ( expr ) .)
    MOD_ASSIGN      reduce using rule 4 (primary_expr -> ( expr ) .)
    ADD_ASSIGN      reduce using rule 4 (primary_expr -> ( expr ) .)
    SUB_ASSIGN      reduce using rule 4 (primary_expr -> ( expr ) .)
    LEFT_ASSIGN     reduce using rule 4 (primary_expr -> ( expr ) .)
    RIGHT_ASSIGN    reduce using rule 4 (primary_expr -> ( expr ) .)
    AND_ASSIGN      reduce using rule 4 (primary_expr -> ( expr ) .)
    XOR_ASSIGN      reduce using rule 4 (primary_expr -> ( expr ) .)
    OR_ASSIGN       reduce using rule 4 (primary_expr -> ( expr ) .)



state 268

    (45) equality_expr -> equality_expr EQ_OP relational_expr .
    (40) relational_expr -> relational_expr . < shift_expr
    (41) relational_expr -> relational_expr . > shift_expr
    (42) relational_expr -> relational_expr . LE_OP shift_expr
    (43) relational_expr -> relational_expr . GE_OP shift_expr

    EQ_OP           reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    NE_OP           reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    &               reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    ^               reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    |               reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    AND_OP          reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    ?               reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    OR_OP           reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    ;               reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    ,               reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
                    reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    ]               reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    )               reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    :               reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    }               reduce using rule 45 (equality_expr -> equality_expr EQ_OP relational_expr .)
    <               shift and go to state 190
    >               shift and go to state 191
    LE_OP           shift and go to state 188
    GE_OP           shift and go to state 189



state 269

    (46) equality_expr -> equality_expr NE_OP relational_expr .
    (40) relational_expr -> relational_expr . < shift_expr
    (41) relational_expr -> relational_expr . > shift_expr
    (42) relational_expr -> relational_expr . LE_OP shift_expr
    (43) relational_expr -> relational_expr . GE_OP shift_expr

    EQ_OP           reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    NE_OP           reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    &               reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    ^               reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    |               reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    AND_OP          reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    ?               reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    OR_OP           reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    ;               reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    ,               reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
                    reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    ]               reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    )               reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    :               reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    }               reduce using rule 46 (equality_expr -> equality_expr NE_OP relational_expr .)
    <               shift and go to state 190
    >               shift and go to state 191
    LE_OP           shift and go to state 188
    GE_OP           shift and go to state 189



state 270

    (37) shift_expr -> shift_expr LEFT_OP additive_expr .
    (34) additive_expr -> additive_expr . + multiplicative_expr
    (35) additive_expr -> additive_expr . - multiplicative_expr

    LEFT_OP         reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    RIGHT_OP        reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    <               reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    >               reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    LE_OP           reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    GE_OP           reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    EQ_OP           reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    NE_OP           reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    &               reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    ^               reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    |               reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    AND_OP          reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    ?               reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    OR_OP           reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    ]               reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    ;               reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    ,               reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    )               reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
                    reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    :               reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    }               reduce using rule 37 (shift_expr -> shift_expr LEFT_OP additive_expr .)
    +               shift and go to state 168
    -               shift and go to state 169



state 271

    (38) shift_expr -> shift_expr RIGHT_OP additive_expr .
    (34) additive_expr -> additive_expr . + multiplicative_expr
    (35) additive_expr -> additive_expr . - multiplicative_expr

    LEFT_OP         reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    RIGHT_OP        reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    <               reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    >               reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    LE_OP           reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    GE_OP           reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    EQ_OP           reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    NE_OP           reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    &               reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    ^               reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    |               reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    AND_OP          reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    ?               reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    OR_OP           reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    ]               reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    ;               reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    ,               reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    )               reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
                    reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    :               reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    }               reduce using rule 38 (shift_expr -> shift_expr RIGHT_OP additive_expr .)
    +               shift and go to state 168
    -               shift and go to state 169



state 272

    (32) multiplicative_expr -> multiplicative_expr % cast_expr .

    *               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    /               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    %               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    +               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    -               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    LEFT_OP         reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    RIGHT_OP        reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    <               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    >               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    LE_OP           reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    GE_OP           reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    EQ_OP           reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    NE_OP           reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    &               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    ^               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    |               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    AND_OP          reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    ?               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    OR_OP           reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    }               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    ,               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    ]               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    ;               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    )               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
                    reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)
    :               reduce using rule 32 (multiplicative_expr -> multiplicative_expr % cast_expr .)



state 273

    (30) multiplicative_expr -> multiplicative_expr * cast_expr .

    *               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    /               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    %               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    +               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    -               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    LEFT_OP         reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    RIGHT_OP        reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    <               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    >               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    LE_OP           reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    GE_OP           reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    EQ_OP           reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    NE_OP           reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    &               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    ^               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    |               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    AND_OP          reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    ?               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    OR_OP           reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    }               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    ,               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    ]               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    ;               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    )               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
                    reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)
    :               reduce using rule 30 (multiplicative_expr -> multiplicative_expr * cast_expr .)



state 274

    (31) multiplicative_expr -> multiplicative_expr / cast_expr .

    *               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    /               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    %               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    +               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    -               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    LEFT_OP         reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    RIGHT_OP        reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    <               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    >               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    LE_OP           reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    GE_OP           reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    EQ_OP           reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    NE_OP           reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    &               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    ^               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    |               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    AND_OP          reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    ?               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    OR_OP           reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    }               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    ,               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    ]               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    ;               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    )               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
                    reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)
    :               reduce using rule 31 (multiplicative_expr -> multiplicative_expr / cast_expr .)



state 275

    (48) and_expr -> and_expr & equality_expr .
    (45) equality_expr -> equality_expr . EQ_OP relational_expr
    (46) equality_expr -> equality_expr . NE_OP relational_expr

    &               reduce using rule 48 (and_expr -> and_expr & equality_expr .)
    ^               reduce using rule 48 (and_expr -> and_expr & equality_expr .)
    |               reduce using rule 48 (and_expr -> and_expr & equality_expr .)
    AND_OP          reduce using rule 48 (and_expr -> and_expr & equality_expr .)
    ?               reduce using rule 48 (and_expr -> and_expr & equality_expr .)
    OR_OP           reduce using rule 48 (and_expr -> and_expr & equality_expr .)
    ;               reduce using rule 48 (and_expr -> and_expr & equality_expr .)
    ,               reduce using rule 48 (and_expr -> and_expr & equality_expr .)
    ]               reduce using rule 48 (and_expr -> and_expr & equality_expr .)
    )               reduce using rule 48 (and_expr -> and_expr & equality_expr .)
                    reduce using rule 48 (and_expr -> and_expr & equality_expr .)
    :               reduce using rule 48 (and_expr -> and_expr & equality_expr .)
    }               reduce using rule 48 (and_expr -> and_expr & equality_expr .)
    EQ_OP           shift and go to state 180
    NE_OP           shift and go to state 181



state 276

    (42) relational_expr -> relational_expr LE_OP shift_expr .
    (37) shift_expr -> shift_expr . LEFT_OP additive_expr
    (38) shift_expr -> shift_expr . RIGHT_OP additive_expr

    <               reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    >               reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    LE_OP           reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    GE_OP           reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    EQ_OP           reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    NE_OP           reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    &               reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    ^               reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    |               reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    AND_OP          reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    ?               reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    OR_OP           reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    ;               reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    ,               reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    )               reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    ]               reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
                    reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    :               reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    }               reduce using rule 42 (relational_expr -> relational_expr LE_OP shift_expr .)
    LEFT_OP         shift and go to state 182
    RIGHT_OP        shift and go to state 183



state 277

    (43) relational_expr -> relational_expr GE_OP shift_expr .
    (37) shift_expr -> shift_expr . LEFT_OP additive_expr
    (38) shift_expr -> shift_expr . RIGHT_OP additive_expr

    <               reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    >               reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    LE_OP           reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    GE_OP           reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    EQ_OP           reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    NE_OP           reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    &               reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    ^               reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    |               reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    AND_OP          reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    ?               reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    OR_OP           reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    ;               reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    ,               reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    )               reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    ]               reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
                    reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    :               reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    }               reduce using rule 43 (relational_expr -> relational_expr GE_OP shift_expr .)
    LEFT_OP         shift and go to state 182
    RIGHT_OP        shift and go to state 183



state 278

    (40) relational_expr -> relational_expr < shift_expr .
    (37) shift_expr -> shift_expr . LEFT_OP additive_expr
    (38) shift_expr -> shift_expr . RIGHT_OP additive_expr

    <               reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    >               reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    LE_OP           reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    GE_OP           reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    EQ_OP           reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    NE_OP           reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    &               reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    ^               reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    |               reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    AND_OP          reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    ?               reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    OR_OP           reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    ;               reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    ,               reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    )               reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    ]               reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
                    reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    :               reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    }               reduce using rule 40 (relational_expr -> relational_expr < shift_expr .)
    LEFT_OP         shift and go to state 182
    RIGHT_OP        shift and go to state 183



state 279

    (41) relational_expr -> relational_expr > shift_expr .
    (37) shift_expr -> shift_expr . LEFT_OP additive_expr
    (38) shift_expr -> shift_expr . RIGHT_OP additive_expr

    <               reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    >               reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    LE_OP           reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    GE_OP           reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    EQ_OP           reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    NE_OP           reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    &               reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    ^               reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    |               reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    AND_OP          reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    ?               reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    OR_OP           reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    ;               reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    ,               reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    )               reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    ]               reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
                    reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    :               reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    }               reduce using rule 41 (relational_expr -> relational_expr > shift_expr .)
    LEFT_OP         shift and go to state 182
    RIGHT_OP        shift and go to state 183



state 280

    (9) postfix_expr -> postfix_expr . identifier .

    [               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    (               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    .               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    PTR_OP          reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    INC_OP          reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    DEC_OP          reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    =               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    MUL_ASSIGN      reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    DIV_ASSIGN      reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    MOD_ASSIGN      reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    ADD_ASSIGN      reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    SUB_ASSIGN      reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    LEFT_ASSIGN     reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    RIGHT_ASSIGN    reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    AND_ASSIGN      reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    XOR_ASSIGN      reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    OR_ASSIGN       reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    *               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    /               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    %               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    +               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    -               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    LEFT_OP         reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    RIGHT_OP        reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    <               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    >               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    LE_OP           reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    GE_OP           reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    EQ_OP           reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    NE_OP           reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    &               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    ^               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    |               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    AND_OP          reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    ?               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    OR_OP           reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    ;               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    ,               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    ]               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    )               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
                    reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    :               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)
    }               reduce using rule 9 (postfix_expr -> postfix_expr . identifier .)



state 281

    (10) postfix_expr -> postfix_expr PTR_OP identifier .

    [               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    (               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    .               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    PTR_OP          reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    INC_OP          reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    DEC_OP          reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    =               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    MUL_ASSIGN      reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    DIV_ASSIGN      reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    MOD_ASSIGN      reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    ADD_ASSIGN      reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    SUB_ASSIGN      reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    LEFT_ASSIGN     reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    RIGHT_ASSIGN    reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    AND_ASSIGN      reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    XOR_ASSIGN      reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    OR_ASSIGN       reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    *               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    /               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    %               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    +               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    -               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    LEFT_OP         reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    RIGHT_OP        reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    <               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    >               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    LE_OP           reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    GE_OP           reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    EQ_OP           reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    NE_OP           reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    &               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    ^               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    |               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    AND_OP          reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    ?               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    OR_OP           reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    ;               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    ,               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    ]               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    )               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
                    reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    :               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)
    }               reduce using rule 10 (postfix_expr -> postfix_expr PTR_OP identifier .)



state 282

    (8) postfix_expr -> postfix_expr ( argument_expr_list . )
    (14) argument_expr_list -> argument_expr_list . , assignment_expr

    )               shift and go to state 320
    ,               shift and go to state 321



state 283

    (7) postfix_expr -> postfix_expr ( ) .

    [               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    (               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    .               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    PTR_OP          reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    INC_OP          reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    DEC_OP          reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    =               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    MUL_ASSIGN      reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    DIV_ASSIGN      reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    MOD_ASSIGN      reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    ADD_ASSIGN      reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    SUB_ASSIGN      reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    LEFT_ASSIGN     reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    RIGHT_ASSIGN    reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    AND_ASSIGN      reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    XOR_ASSIGN      reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    OR_ASSIGN       reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    *               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    /               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    %               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    +               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    -               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    LEFT_OP         reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    RIGHT_OP        reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    <               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    >               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    LE_OP           reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    GE_OP           reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    EQ_OP           reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    NE_OP           reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    &               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    ^               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    |               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    AND_OP          reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    ?               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    OR_OP           reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    ;               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    ,               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    ]               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    )               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
                    reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    :               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)
    }               reduce using rule 7 (postfix_expr -> postfix_expr ( ) .)



state 284

    (13) argument_expr_list -> assignment_expr .

    )               reduce using rule 13 (argument_expr_list -> assignment_expr .)
    ,               reduce using rule 13 (argument_expr_list -> assignment_expr .)



state 285

    (6) postfix_expr -> postfix_expr [ expr . ]
    (73) expr -> expr . , assignment_expr

    ]               shift and go to state 322
    ,               shift and go to state 238



state 286

    (50) exclusive_or_expr -> exclusive_or_expr ^ and_expr .
    (48) and_expr -> and_expr . & equality_expr

    ^               reduce using rule 50 (exclusive_or_expr -> exclusive_or_expr ^ and_expr .)
    |               reduce using rule 50 (exclusive_or_expr -> exclusive_or_expr ^ and_expr .)
    AND_OP          reduce using rule 50 (exclusive_or_expr -> exclusive_or_expr ^ and_expr .)
    ?               reduce using rule 50 (exclusive_or_expr -> exclusive_or_expr ^ and_expr .)
    OR_OP           reduce using rule 50 (exclusive_or_expr -> exclusive_or_expr ^ and_expr .)
    )               reduce using rule 50 (exclusive_or_expr -> exclusive_or_expr ^ and_expr .)
    ,               reduce using rule 50 (exclusive_or_expr -> exclusive_or_expr ^ and_expr .)
    ;               reduce using rule 50 (exclusive_or_expr -> exclusive_or_expr ^ and_expr .)
    }               reduce using rule 50 (exclusive_or_expr -> exclusive_or_expr ^ and_expr .)
    ]               reduce using rule 50 (exclusive_or_expr -> exclusive_or_expr ^ and_expr .)
                    reduce using rule 50 (exclusive_or_expr -> exclusive_or_expr ^ and_expr .)
    :               reduce using rule 50 (exclusive_or_expr -> exclusive_or_expr ^ and_expr .)
    &               shift and go to state 187



state 287

    (54) logical_and_expr -> logical_and_expr AND_OP inclusive_or_expr .
    (52) inclusive_or_expr -> inclusive_or_expr . | exclusive_or_expr

    AND_OP          reduce using rule 54 (logical_and_expr -> logical_and_expr AND_OP inclusive_or_expr .)
    ?               reduce using rule 54 (logical_and_expr -> logical_and_expr AND_OP inclusive_or_expr .)
    OR_OP           reduce using rule 54 (logical_and_expr -> logical_and_expr AND_OP inclusive_or_expr .)
    )               reduce using rule 54 (logical_and_expr -> logical_and_expr AND_OP inclusive_or_expr .)
    ,               reduce using rule 54 (logical_and_expr -> logical_and_expr AND_OP inclusive_or_expr .)
    ;               reduce using rule 54 (logical_and_expr -> logical_and_expr AND_OP inclusive_or_expr .)
                    reduce using rule 54 (logical_and_expr -> logical_and_expr AND_OP inclusive_or_expr .)
    :               reduce using rule 54 (logical_and_expr -> logical_and_expr AND_OP inclusive_or_expr .)
    ]               reduce using rule 54 (logical_and_expr -> logical_and_expr AND_OP inclusive_or_expr .)
    }               reduce using rule 54 (logical_and_expr -> logical_and_expr AND_OP inclusive_or_expr .)
    |               shift and go to state 200



state 288

    (52) inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr .
    (50) exclusive_or_expr -> exclusive_or_expr . ^ and_expr

    |               reduce using rule 52 (inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr .)
    AND_OP          reduce using rule 52 (inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr .)
    ?               reduce using rule 52 (inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr .)
    OR_OP           reduce using rule 52 (inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr .)
    ;               reduce using rule 52 (inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr .)
    ,               reduce using rule 52 (inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr .)
    }               reduce using rule 52 (inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr .)
    )               reduce using rule 52 (inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr .)
    ]               reduce using rule 52 (inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr .)
                    reduce using rule 52 (inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr .)
    :               reduce using rule 52 (inclusive_or_expr -> inclusive_or_expr | exclusive_or_expr .)
    ^               shift and go to state 198



state 289

    (118) enum_specifier -> ENUM identifier { enumerator_list } .

    CHAR            reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    SHORT           reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    INT             reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    LONG            reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    SIGNED          reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    UNSIGNED        reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    FLOAT           reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    DOUBLE          reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    CONST           reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    VOLATILE        reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    VOID            reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    TYPE_NAME       reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    (               reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    *               reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    ENUM            reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    [               reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    IDENTIFIER      reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    STRUCT          reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    UNION           reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    ,               reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    )               reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    TYPEDEF         reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    EXTERN          reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    STATIC          reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    AUTO            reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    REGISTER        reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
                    reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)
    :               reduce using rule 118 (enum_specifier -> ENUM identifier { enumerator_list } .)



state 290

    (121) enumerator_list -> enumerator_list , enumerator .

    }               reduce using rule 121 (enumerator_list -> enumerator_list , enumerator .)
    ,               reduce using rule 121 (enumerator_list -> enumerator_list , enumerator .)



state 291

    (123) enumerator -> identifier = constant_expr .

    }               reduce using rule 123 (enumerator -> identifier = constant_expr .)
    ,               reduce using rule 123 (enumerator -> identifier = constant_expr .)



state 292

    (166) initializer_list -> initializer .

    }               reduce using rule 166 (initializer_list -> initializer .)
    ,               reduce using rule 166 (initializer_list -> initializer .)



state 293

    (164) initializer -> { initializer_list . }
    (165) initializer -> { initializer_list . , }
    (167) initializer_list -> initializer_list . , initializer

    }               shift and go to state 323
    ,               shift and go to state 324



state 294

    (202) jump_statement -> GOTO identifier ; .

    }               reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    CASE            reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    DEFAULT         reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    ;               reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    IF              reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    SWITCH          reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    WHILE           reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    DO              reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    FOR             reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    GOTO            reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    CONTINUE        reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    BREAK           reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    RETURN          reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    IDENTIFIER      reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    {               reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    INC_OP          reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    DEC_OP          reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    SIZEOF          reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    &               reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    *               reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    +               reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    -               reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    ~               reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    !               reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    CONSTANT        reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    STRING_LITERAL  reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    (               reduce using rule 202 (jump_statement -> GOTO identifier ; .)
    ELSE            reduce using rule 202 (jump_statement -> GOTO identifier ; .)



state 295

    (182) compound_statement -> left_bracket declaration_list statement_list right_bracket .

    }               reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    CASE            reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    DEFAULT         reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    ;               reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    IF              reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    SWITCH          reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    WHILE           reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    DO              reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    FOR             reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    GOTO            reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    CONTINUE        reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    BREAK           reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    RETURN          reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    IDENTIFIER      reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    {               reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    INC_OP          reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    DEC_OP          reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    SIZEOF          reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    &               reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    *               reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    +               reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    -               reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    ~               reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    !               reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    CONSTANT        reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    STRING_LITERAL  reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    (               reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    ELSE            reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    TYPEDEF         reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    EXTERN          reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    STATIC          reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    AUTO            reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    REGISTER        reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    CHAR            reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    SHORT           reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    INT             reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    LONG            reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    SIGNED          reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    UNSIGNED        reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    FLOAT           reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    DOUBLE          reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    CONST           reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    VOLATILE        reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    VOID            reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    TYPE_NAME       reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    ENUM            reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    STRUCT          reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    UNION           reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)
    $end            reduce using rule 182 (compound_statement -> left_bracket declaration_list statement_list right_bracket .)



state 296

    (174) labeled_statement -> identifier : statement .

    }               reduce using rule 174 (labeled_statement -> identifier : statement .)
    CASE            reduce using rule 174 (labeled_statement -> identifier : statement .)
    DEFAULT         reduce using rule 174 (labeled_statement -> identifier : statement .)
    ;               reduce using rule 174 (labeled_statement -> identifier : statement .)
    IF              reduce using rule 174 (labeled_statement -> identifier : statement .)
    SWITCH          reduce using rule 174 (labeled_statement -> identifier : statement .)
    WHILE           reduce using rule 174 (labeled_statement -> identifier : statement .)
    DO              reduce using rule 174 (labeled_statement -> identifier : statement .)
    FOR             reduce using rule 174 (labeled_statement -> identifier : statement .)
    GOTO            reduce using rule 174 (labeled_statement -> identifier : statement .)
    CONTINUE        reduce using rule 174 (labeled_statement -> identifier : statement .)
    BREAK           reduce using rule 174 (labeled_statement -> identifier : statement .)
    RETURN          reduce using rule 174 (labeled_statement -> identifier : statement .)
    IDENTIFIER      reduce using rule 174 (labeled_statement -> identifier : statement .)
    {               reduce using rule 174 (labeled_statement -> identifier : statement .)
    INC_OP          reduce using rule 174 (labeled_statement -> identifier : statement .)
    DEC_OP          reduce using rule 174 (labeled_statement -> identifier : statement .)
    SIZEOF          reduce using rule 174 (labeled_statement -> identifier : statement .)
    &               reduce using rule 174 (labeled_statement -> identifier : statement .)
    *               reduce using rule 174 (labeled_statement -> identifier : statement .)
    +               reduce using rule 174 (labeled_statement -> identifier : statement .)
    -               reduce using rule 174 (labeled_statement -> identifier : statement .)
    ~               reduce using rule 174 (labeled_statement -> identifier : statement .)
    !               reduce using rule 174 (labeled_statement -> identifier : statement .)
    CONSTANT        reduce using rule 174 (labeled_statement -> identifier : statement .)
    STRING_LITERAL  reduce using rule 174 (labeled_statement -> identifier : statement .)
    (               reduce using rule 174 (labeled_statement -> identifier : statement .)
    ELSE            reduce using rule 174 (labeled_statement -> identifier : statement .)



state 297

    (206) jump_statement -> RETURN expr ; .

    }               reduce using rule 206 (jump_statement -> RETURN expr ; .)
    CASE            reduce using rule 206 (jump_statement -> RETURN expr ; .)
    DEFAULT         reduce using rule 206 (jump_statement -> RETURN expr ; .)
    ;               reduce using rule 206 (jump_statement -> RETURN expr ; .)
    IF              reduce using rule 206 (jump_statement -> RETURN expr ; .)
    SWITCH          reduce using rule 206 (jump_statement -> RETURN expr ; .)
    WHILE           reduce using rule 206 (jump_statement -> RETURN expr ; .)
    DO              reduce using rule 206 (jump_statement -> RETURN expr ; .)
    FOR             reduce using rule 206 (jump_statement -> RETURN expr ; .)
    GOTO            reduce using rule 206 (jump_statement -> RETURN expr ; .)
    CONTINUE        reduce using rule 206 (jump_statement -> RETURN expr ; .)
    BREAK           reduce using rule 206 (jump_statement -> RETURN expr ; .)
    RETURN          reduce using rule 206 (jump_statement -> RETURN expr ; .)
    IDENTIFIER      reduce using rule 206 (jump_statement -> RETURN expr ; .)
    {               reduce using rule 206 (jump_statement -> RETURN expr ; .)
    INC_OP          reduce using rule 206 (jump_statement -> RETURN expr ; .)
    DEC_OP          reduce using rule 206 (jump_statement -> RETURN expr ; .)
    SIZEOF          reduce using rule 206 (jump_statement -> RETURN expr ; .)
    &               reduce using rule 206 (jump_statement -> RETURN expr ; .)
    *               reduce using rule 206 (jump_statement -> RETURN expr ; .)
    +               reduce using rule 206 (jump_statement -> RETURN expr ; .)
    -               reduce using rule 206 (jump_statement -> RETURN expr ; .)
    ~               reduce using rule 206 (jump_statement -> RETURN expr ; .)
    !               reduce using rule 206 (jump_statement -> RETURN expr ; .)
    CONSTANT        reduce using rule 206 (jump_statement -> RETURN expr ; .)
    STRING_LITERAL  reduce using rule 206 (jump_statement -> RETURN expr ; .)
    (               reduce using rule 206 (jump_statement -> RETURN expr ; .)
    ELSE            reduce using rule 206 (jump_statement -> RETURN expr ; .)



state 298

    (194) iteration_statement -> FOR ( ; . ; ) statement
    (195) iteration_statement -> FOR ( ; . ; expr ) statement
    (196) iteration_statement -> FOR ( ; . expr ; ) statement
    (197) iteration_statement -> FOR ( ; . expr ; expr ) statement
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    ;               shift and go to state 325
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 326
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 299

    (198) iteration_statement -> FOR ( expr . ; ; ) statement
    (199) iteration_statement -> FOR ( expr . ; ; expr ) statement
    (200) iteration_statement -> FOR ( expr . ; expr ; ) statement
    (201) iteration_statement -> FOR ( expr . ; expr ; expr ) statement
    (73) expr -> expr . , assignment_expr

    ;               shift and go to state 327
    ,               shift and go to state 238



state 300

    (60) assignment_expr -> unary_expr assignment_operator assignment_expr .

    ;               reduce using rule 60 (assignment_expr -> unary_expr assignment_operator assignment_expr .)
    ,               reduce using rule 60 (assignment_expr -> unary_expr assignment_operator assignment_expr .)
    )               reduce using rule 60 (assignment_expr -> unary_expr assignment_operator assignment_expr .)
                    reduce using rule 60 (assignment_expr -> unary_expr assignment_operator assignment_expr .)
    ]               reduce using rule 60 (assignment_expr -> unary_expr assignment_operator assignment_expr .)
    }               reduce using rule 60 (assignment_expr -> unary_expr assignment_operator assignment_expr .)



state 301

    (176) labeled_statement -> DEFAULT : statement .

    }               reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    CASE            reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    DEFAULT         reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    ;               reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    IF              reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    SWITCH          reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    WHILE           reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    DO              reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    FOR             reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    GOTO            reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    CONTINUE        reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    BREAK           reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    RETURN          reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    IDENTIFIER      reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    {               reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    INC_OP          reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    DEC_OP          reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    SIZEOF          reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    &               reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    *               reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    +               reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    -               reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    ~               reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    !               reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    CONSTANT        reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    STRING_LITERAL  reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    (               reduce using rule 176 (labeled_statement -> DEFAULT : statement .)
    ELSE            reduce using rule 176 (labeled_statement -> DEFAULT : statement .)



state 302

    (192) iteration_statement -> WHILE ( expr . ) statement
    (73) expr -> expr . , assignment_expr

    )               shift and go to state 328
    ,               shift and go to state 238



state 303

    (175) labeled_statement -> CASE constant_expr : . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 329
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 304

    (191) selection_statement -> SWITCH ( expr . ) statement
    (73) expr -> expr . , assignment_expr

    )               shift and go to state 330
    ,               shift and go to state 238



state 305

    (73) expr -> expr , assignment_expr .

    ;               reduce using rule 73 (expr -> expr , assignment_expr .)
    ,               reduce using rule 73 (expr -> expr , assignment_expr .)
    )               reduce using rule 73 (expr -> expr , assignment_expr .)
    ]               reduce using rule 73 (expr -> expr , assignment_expr .)



state 306

    (193) iteration_statement -> DO statement WHILE . ( expr ) ;

    (               shift and go to state 331



state 307

    (189) selection_statement -> IF ( expr . ) statement
    (190) selection_statement -> IF ( expr . ) statement ELSE statement
    (73) expr -> expr . , assignment_expr

    )               shift and go to state 332
    ,               shift and go to state 238



state 308

    (113) struct_declarator_list -> struct_declarator_list , struct_declarator .

                    reduce using rule 113 (struct_declarator_list -> struct_declarator_list , struct_declarator .)
    ,               reduce using rule 113 (struct_declarator_list -> struct_declarator_list , struct_declarator .)



state 309

    (116) struct_declarator -> declarator : constant_expr .

                    reduce using rule 116 (struct_declarator -> declarator : constant_expr .)
    ,               reduce using rule 116 (struct_declarator -> declarator : constant_expr .)



state 310

    (160) abstract_declarator2 -> ( parameter_type_list ) .

    [               reduce using rule 160 (abstract_declarator2 -> ( parameter_type_list ) .)
    (               reduce using rule 160 (abstract_declarator2 -> ( parameter_type_list ) .)
    )               reduce using rule 160 (abstract_declarator2 -> ( parameter_type_list ) .)
    ,               reduce using rule 160 (abstract_declarator2 -> ( parameter_type_list ) .)



state 311

    (154) abstract_declarator2 -> ( abstract_declarator ) .

    [               reduce using rule 154 (abstract_declarator2 -> ( abstract_declarator ) .)
    (               reduce using rule 154 (abstract_declarator2 -> ( abstract_declarator ) .)
    )               reduce using rule 154 (abstract_declarator2 -> ( abstract_declarator ) .)
    ,               reduce using rule 154 (abstract_declarator2 -> ( abstract_declarator ) .)



state 312

    (161) abstract_declarator2 -> abstract_declarator2 ( ) .

    [               reduce using rule 161 (abstract_declarator2 -> abstract_declarator2 ( ) .)
    (               reduce using rule 161 (abstract_declarator2 -> abstract_declarator2 ( ) .)
    )               reduce using rule 161 (abstract_declarator2 -> abstract_declarator2 ( ) .)
    ,               reduce using rule 161 (abstract_declarator2 -> abstract_declarator2 ( ) .)



state 313

    (162) abstract_declarator2 -> abstract_declarator2 ( parameter_type_list . )

    )               shift and go to state 333



state 314

    (158) abstract_declarator2 -> abstract_declarator2 [ constant_expr . ]

    ]               shift and go to state 334



state 315

    (157) abstract_declarator2 -> abstract_declarator2 [ ] .

    [               reduce using rule 157 (abstract_declarator2 -> abstract_declarator2 [ ] .)
    (               reduce using rule 157 (abstract_declarator2 -> abstract_declarator2 [ ] .)
    )               reduce using rule 157 (abstract_declarator2 -> abstract_declarator2 [ ] .)
    ,               reduce using rule 157 (abstract_declarator2 -> abstract_declarator2 [ ] .)



state 316

    (156) abstract_declarator2 -> [ constant_expr ] .

    [               reduce using rule 156 (abstract_declarator2 -> [ constant_expr ] .)
    (               reduce using rule 156 (abstract_declarator2 -> [ constant_expr ] .)
    )               reduce using rule 156 (abstract_declarator2 -> [ constant_expr ] .)
    ,               reduce using rule 156 (abstract_declarator2 -> [ constant_expr ] .)



state 317

    (58) conditional_expr -> logical_or_expr ? logical_or_expr : . conditional_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (216) identifier -> . IDENTIFIER

    (               shift and go to state 88
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    IDENTIFIER      shift and go to state 21


    conditional_expr               shift and go to state 335
    equality_expr                  shift and go to state 90
    cast_expr                      shift and go to state 95
    unary_expr                     shift and go to state 79
    exclusive_or_expr              shift and go to state 101
    relational_expr                shift and go to state 94
    postfix_expr                   shift and go to state 99
    logical_and_expr               shift and go to state 102
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    logical_or_expr                shift and go to state 84
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    unary_operator                 shift and go to state 105
    identifier                     shift and go to state 98
    additive_expr                  shift and go to state 77
    and_expr                       shift and go to state 93

state 318

    (20) unary_expr -> SIZEOF ( type_name ) .

    =               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    MUL_ASSIGN      reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    DIV_ASSIGN      reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    MOD_ASSIGN      reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    ADD_ASSIGN      reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    SUB_ASSIGN      reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    LEFT_ASSIGN     reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    RIGHT_ASSIGN    reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    AND_ASSIGN      reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    XOR_ASSIGN      reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    OR_ASSIGN       reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    *               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    /               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    %               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    +               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    -               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    LEFT_OP         reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    RIGHT_OP        reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    <               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    >               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    LE_OP           reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    GE_OP           reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    EQ_OP           reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    NE_OP           reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    &               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    ^               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    |               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    AND_OP          reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    ?               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    OR_OP           reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    ;               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    ,               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    )               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
                    reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    :               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    ]               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)
    }               reduce using rule 20 (unary_expr -> SIZEOF ( type_name ) .)



state 319

    (28) cast_expr -> ( type_name ) cast_expr .

    *               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    /               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    %               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    +               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    -               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    LEFT_OP         reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    RIGHT_OP        reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    <               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    >               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    LE_OP           reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    GE_OP           reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    EQ_OP           reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    NE_OP           reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    &               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    ^               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    |               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    AND_OP          reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    ?               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    OR_OP           reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    ]               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    ;               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    ,               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    )               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
                    reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    :               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    }               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    =               reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    MUL_ASSIGN      reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    DIV_ASSIGN      reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    MOD_ASSIGN      reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    ADD_ASSIGN      reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    SUB_ASSIGN      reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    LEFT_ASSIGN     reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    RIGHT_ASSIGN    reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    AND_ASSIGN      reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    XOR_ASSIGN      reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)
    OR_ASSIGN       reduce using rule 28 (cast_expr -> ( type_name ) cast_expr .)



state 320

    (8) postfix_expr -> postfix_expr ( argument_expr_list ) .

    [               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    (               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    .               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    PTR_OP          reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    INC_OP          reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    DEC_OP          reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    =               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    MUL_ASSIGN      reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    DIV_ASSIGN      reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    MOD_ASSIGN      reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    ADD_ASSIGN      reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    SUB_ASSIGN      reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    LEFT_ASSIGN     reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    RIGHT_ASSIGN    reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    AND_ASSIGN      reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    XOR_ASSIGN      reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    OR_ASSIGN       reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    *               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    /               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    %               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    +               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    -               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    LEFT_OP         reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    RIGHT_OP        reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    <               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    >               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    LE_OP           reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    GE_OP           reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    EQ_OP           reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    NE_OP           reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    &               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    ^               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    |               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    AND_OP          reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    ?               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    OR_OP           reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    ;               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    ,               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    ]               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    )               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
                    reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    :               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)
    }               reduce using rule 8 (postfix_expr -> postfix_expr ( argument_expr_list ) .)



state 321

    (14) argument_expr_list -> argument_expr_list , . assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 336
    identifier                     shift and go to state 98

state 322

    (6) postfix_expr -> postfix_expr [ expr ] .

    [               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    (               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    .               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    PTR_OP          reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    INC_OP          reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    DEC_OP          reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    =               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    MUL_ASSIGN      reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    DIV_ASSIGN      reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    MOD_ASSIGN      reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    ADD_ASSIGN      reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    SUB_ASSIGN      reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    LEFT_ASSIGN     reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    RIGHT_ASSIGN    reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    AND_ASSIGN      reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    XOR_ASSIGN      reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    OR_ASSIGN       reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    *               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    /               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    %               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    +               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    -               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    LEFT_OP         reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    RIGHT_OP        reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    <               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    >               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    LE_OP           reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    GE_OP           reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    EQ_OP           reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    NE_OP           reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    &               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    ^               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    |               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    AND_OP          reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    ?               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    OR_OP           reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    ;               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    ,               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    ]               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    )               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
                    reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    :               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)
    }               reduce using rule 6 (postfix_expr -> postfix_expr [ expr ] .)



state 323

    (164) initializer -> { initializer_list } .

    }               reduce using rule 164 (initializer -> { initializer_list } .)
    ,               reduce using rule 164 (initializer -> { initializer_list } .)
                    reduce using rule 164 (initializer -> { initializer_list } .)



state 324

    (165) initializer -> { initializer_list , . }
    (167) initializer_list -> initializer_list , . initializer
    (163) initializer -> . assignment_expr
    (164) initializer -> . { initializer_list }
    (165) initializer -> . { initializer_list , }
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    }               shift and go to state 338
    {               shift and go to state 209
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    equality_expr                  shift and go to state 90
    unary_expr                     shift and go to state 133
    initializer                    shift and go to state 337
    logical_or_expr                shift and go to state 84
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    logical_and_expr               shift and go to state 102
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 208
    identifier                     shift and go to state 98

state 325

    (194) iteration_statement -> FOR ( ; ; . ) statement
    (195) iteration_statement -> FOR ( ; ; . expr ) statement
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    )               shift and go to state 339
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 340
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 326

    (196) iteration_statement -> FOR ( ; expr . ; ) statement
    (197) iteration_statement -> FOR ( ; expr . ; expr ) statement
    (73) expr -> expr . , assignment_expr

    ;               shift and go to state 341
    ,               shift and go to state 238



state 327

    (198) iteration_statement -> FOR ( expr ; . ; ) statement
    (199) iteration_statement -> FOR ( expr ; . ; expr ) statement
    (200) iteration_statement -> FOR ( expr ; . expr ; ) statement
    (201) iteration_statement -> FOR ( expr ; . expr ; expr ) statement
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    ;               shift and go to state 342
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 343
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 328

    (192) iteration_statement -> WHILE ( expr ) . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 344
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 329

    (175) labeled_statement -> CASE constant_expr : statement .

    }               reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    CASE            reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    DEFAULT         reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    ;               reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    IF              reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    SWITCH          reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    WHILE           reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    DO              reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    FOR             reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    GOTO            reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    CONTINUE        reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    BREAK           reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    RETURN          reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    IDENTIFIER      reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    {               reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    INC_OP          reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    DEC_OP          reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    SIZEOF          reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    &               reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    *               reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    +               reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    -               reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    ~               reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    !               reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    CONSTANT        reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    STRING_LITERAL  reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    (               reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)
    ELSE            reduce using rule 175 (labeled_statement -> CASE constant_expr : statement .)



state 330

    (191) selection_statement -> SWITCH ( expr ) . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 345
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 331

    (193) iteration_statement -> DO statement WHILE ( . expr ) ;
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 346
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 332

    (189) selection_statement -> IF ( expr ) . statement
    (190) selection_statement -> IF ( expr ) . statement ELSE statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 347
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 333

    (162) abstract_declarator2 -> abstract_declarator2 ( parameter_type_list ) .

    [               reduce using rule 162 (abstract_declarator2 -> abstract_declarator2 ( parameter_type_list ) .)
    (               reduce using rule 162 (abstract_declarator2 -> abstract_declarator2 ( parameter_type_list ) .)
    )               reduce using rule 162 (abstract_declarator2 -> abstract_declarator2 ( parameter_type_list ) .)
    ,               reduce using rule 162 (abstract_declarator2 -> abstract_declarator2 ( parameter_type_list ) .)



state 334

    (158) abstract_declarator2 -> abstract_declarator2 [ constant_expr ] .

    [               reduce using rule 158 (abstract_declarator2 -> abstract_declarator2 [ constant_expr ] .)
    (               reduce using rule 158 (abstract_declarator2 -> abstract_declarator2 [ constant_expr ] .)
    )               reduce using rule 158 (abstract_declarator2 -> abstract_declarator2 [ constant_expr ] .)
    ,               reduce using rule 158 (abstract_declarator2 -> abstract_declarator2 [ constant_expr ] .)



state 335

    (58) conditional_expr -> logical_or_expr ? logical_or_expr : conditional_expr .

                    reduce using rule 58 (conditional_expr -> logical_or_expr ? logical_or_expr : conditional_expr .)
    ,               reduce using rule 58 (conditional_expr -> logical_or_expr ? logical_or_expr : conditional_expr .)
    ]               reduce using rule 58 (conditional_expr -> logical_or_expr ? logical_or_expr : conditional_expr .)
    )               reduce using rule 58 (conditional_expr -> logical_or_expr ? logical_or_expr : conditional_expr .)
    ;               reduce using rule 58 (conditional_expr -> logical_or_expr ? logical_or_expr : conditional_expr .)
    }               reduce using rule 58 (conditional_expr -> logical_or_expr ? logical_or_expr : conditional_expr .)
    :               reduce using rule 58 (conditional_expr -> logical_or_expr ? logical_or_expr : conditional_expr .)



state 336

    (14) argument_expr_list -> argument_expr_list , assignment_expr .

    )               reduce using rule 14 (argument_expr_list -> argument_expr_list , assignment_expr .)
    ,               reduce using rule 14 (argument_expr_list -> argument_expr_list , assignment_expr .)



state 337

    (167) initializer_list -> initializer_list , initializer .

    }               reduce using rule 167 (initializer_list -> initializer_list , initializer .)
    ,               reduce using rule 167 (initializer_list -> initializer_list , initializer .)



state 338

    (165) initializer -> { initializer_list , } .

    }               reduce using rule 165 (initializer -> { initializer_list , } .)
    ,               reduce using rule 165 (initializer -> { initializer_list , } .)
                    reduce using rule 165 (initializer -> { initializer_list , } .)



state 339

    (194) iteration_statement -> FOR ( ; ; ) . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 348
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 340

    (195) iteration_statement -> FOR ( ; ; expr . ) statement
    (73) expr -> expr . , assignment_expr

    )               shift and go to state 349
    ,               shift and go to state 238



state 341

    (196) iteration_statement -> FOR ( ; expr ; . ) statement
    (197) iteration_statement -> FOR ( ; expr ; . expr ) statement
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    )               shift and go to state 350
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 351
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 342

    (198) iteration_statement -> FOR ( expr ; ; . ) statement
    (199) iteration_statement -> FOR ( expr ; ; . expr ) statement
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    )               shift and go to state 352
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 353
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 343

    (200) iteration_statement -> FOR ( expr ; expr . ; ) statement
    (201) iteration_statement -> FOR ( expr ; expr . ; expr ) statement
    (73) expr -> expr . , assignment_expr

    ;               shift and go to state 354
    ,               shift and go to state 238



state 344

    (192) iteration_statement -> WHILE ( expr ) statement .

    }               reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    CASE            reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    DEFAULT         reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    ;               reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    IF              reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    SWITCH          reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    WHILE           reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    DO              reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    FOR             reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    GOTO            reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    CONTINUE        reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    BREAK           reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    RETURN          reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    IDENTIFIER      reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    {               reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    INC_OP          reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    DEC_OP          reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    SIZEOF          reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    &               reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    *               reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    +               reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    -               reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    ~               reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    !               reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    CONSTANT        reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    STRING_LITERAL  reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    (               reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)
    ELSE            reduce using rule 192 (iteration_statement -> WHILE ( expr ) statement .)



state 345

    (191) selection_statement -> SWITCH ( expr ) statement .

    }               reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    CASE            reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    DEFAULT         reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    ;               reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    IF              reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    SWITCH          reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    WHILE           reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    DO              reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    FOR             reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    GOTO            reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    CONTINUE        reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    BREAK           reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    RETURN          reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    IDENTIFIER      reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    {               reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    INC_OP          reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    DEC_OP          reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    SIZEOF          reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    &               reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    *               reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    +               reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    -               reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    ~               reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    !               reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    CONSTANT        reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    STRING_LITERAL  reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    (               reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)
    ELSE            reduce using rule 191 (selection_statement -> SWITCH ( expr ) statement .)



state 346

    (193) iteration_statement -> DO statement WHILE ( expr . ) ;
    (73) expr -> expr . , assignment_expr

    )               shift and go to state 355
    ,               shift and go to state 238



state 347

    (189) selection_statement -> IF ( expr ) statement .
    (190) selection_statement -> IF ( expr ) statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift.
    }               reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    CASE            reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    DEFAULT         reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    ;               reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    IF              reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    SWITCH          reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    WHILE           reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    DO              reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    FOR             reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    GOTO            reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    CONTINUE        reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    BREAK           reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    RETURN          reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    IDENTIFIER      reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    {               reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    INC_OP          reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    DEC_OP          reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    SIZEOF          reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    &               reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    *               reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    +               reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    -               reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    ~               reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    !               reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    CONSTANT        reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    STRING_LITERAL  reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    (               reduce using rule 189 (selection_statement -> IF ( expr ) statement .)
    ELSE            shift and go to state 356

  ! ELSE            [ reduce using rule 189 (selection_statement -> IF ( expr ) statement .) ]


state 348

    (194) iteration_statement -> FOR ( ; ; ) statement .

    }               reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    CASE            reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    DEFAULT         reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    ;               reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    IF              reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    SWITCH          reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    WHILE           reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    DO              reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    FOR             reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    GOTO            reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    CONTINUE        reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    BREAK           reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    RETURN          reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    IDENTIFIER      reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    {               reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    INC_OP          reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    DEC_OP          reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    SIZEOF          reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    &               reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    *               reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    +               reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    -               reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    ~               reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    !               reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    CONSTANT        reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    STRING_LITERAL  reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    (               reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)
    ELSE            reduce using rule 194 (iteration_statement -> FOR ( ; ; ) statement .)



state 349

    (195) iteration_statement -> FOR ( ; ; expr ) . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 357
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 350

    (196) iteration_statement -> FOR ( ; expr ; ) . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 358
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 351

    (197) iteration_statement -> FOR ( ; expr ; expr . ) statement
    (73) expr -> expr . , assignment_expr

    )               shift and go to state 359
    ,               shift and go to state 238



state 352

    (198) iteration_statement -> FOR ( expr ; ; ) . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 360
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 353

    (199) iteration_statement -> FOR ( expr ; ; expr . ) statement
    (73) expr -> expr . , assignment_expr

    )               shift and go to state 361
    ,               shift and go to state 238



state 354

    (200) iteration_statement -> FOR ( expr ; expr ; . ) statement
    (201) iteration_statement -> FOR ( expr ; expr ; . expr ) statement
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (216) identifier -> . IDENTIFIER
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    )               shift and go to state 362
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121
    IDENTIFIER      shift and go to state 21


    logical_and_expr               shift and go to state 102
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 363
    additive_expr                  shift and go to state 77
    inclusive_or_expr              shift and go to state 103
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 98

state 355

    (193) iteration_statement -> DO statement WHILE ( expr ) . ;

    ;               shift and go to state 364



state 356

    (190) selection_statement -> IF ( expr ) statement ELSE . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 365
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 357

    (195) iteration_statement -> FOR ( ; ; expr ) statement .

    }               reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    CASE            reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    DEFAULT         reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    ;               reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    IF              reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    SWITCH          reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    WHILE           reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    DO              reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    FOR             reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    GOTO            reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    CONTINUE        reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    BREAK           reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    RETURN          reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    IDENTIFIER      reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    {               reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    INC_OP          reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    DEC_OP          reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    SIZEOF          reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    &               reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    *               reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    +               reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    -               reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    ~               reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    !               reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    CONSTANT        reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    STRING_LITERAL  reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    (               reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)
    ELSE            reduce using rule 195 (iteration_statement -> FOR ( ; ; expr ) statement .)



state 358

    (196) iteration_statement -> FOR ( ; expr ; ) statement .

    }               reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    CASE            reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    DEFAULT         reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    ;               reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    IF              reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    SWITCH          reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    WHILE           reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    DO              reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    FOR             reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    GOTO            reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    CONTINUE        reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    BREAK           reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    RETURN          reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    IDENTIFIER      reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    {               reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    INC_OP          reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    DEC_OP          reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    SIZEOF          reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    &               reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    *               reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    +               reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    -               reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    ~               reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    !               reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    CONSTANT        reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    STRING_LITERAL  reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    (               reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)
    ELSE            reduce using rule 196 (iteration_statement -> FOR ( ; expr ; ) statement .)



state 359

    (197) iteration_statement -> FOR ( ; expr ; expr ) . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 366
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 360

    (198) iteration_statement -> FOR ( expr ; ; ) statement .

    }               reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    CASE            reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    DEFAULT         reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    ;               reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    IF              reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    SWITCH          reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    WHILE           reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    DO              reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    FOR             reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    GOTO            reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    CONTINUE        reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    BREAK           reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    RETURN          reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    IDENTIFIER      reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    {               reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    INC_OP          reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    DEC_OP          reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    SIZEOF          reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    &               reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    *               reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    +               reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    -               reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    ~               reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    !               reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    CONSTANT        reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    STRING_LITERAL  reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    (               reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)
    ELSE            reduce using rule 198 (iteration_statement -> FOR ( expr ; ; ) statement .)



state 361

    (199) iteration_statement -> FOR ( expr ; ; expr ) . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 367
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 362

    (200) iteration_statement -> FOR ( expr ; expr ; ) . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 368
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 363

    (201) iteration_statement -> FOR ( expr ; expr ; expr . ) statement
    (73) expr -> expr . , assignment_expr

    )               shift and go to state 369
    ,               shift and go to state 238



state 364

    (193) iteration_statement -> DO statement WHILE ( expr ) ; .

    }               reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    CASE            reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    DEFAULT         reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    ;               reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    IF              reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    SWITCH          reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    WHILE           reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    DO              reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    FOR             reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    GOTO            reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    CONTINUE        reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    BREAK           reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    RETURN          reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    IDENTIFIER      reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    {               reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    INC_OP          reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    DEC_OP          reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    SIZEOF          reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    &               reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    *               reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    +               reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    -               reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    ~               reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    !               reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    CONSTANT        reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    STRING_LITERAL  reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    (               reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)
    ELSE            reduce using rule 193 (iteration_statement -> DO statement WHILE ( expr ) ; .)



state 365

    (190) selection_statement -> IF ( expr ) statement ELSE statement .

    }               reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    CASE            reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    DEFAULT         reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    ;               reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    IF              reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    SWITCH          reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    WHILE           reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    DO              reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    FOR             reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    GOTO            reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    CONTINUE        reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    BREAK           reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    RETURN          reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    IDENTIFIER      reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    {               reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    INC_OP          reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    DEC_OP          reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    SIZEOF          reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    &               reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    *               reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    +               reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    -               reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    ~               reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    !               reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    CONSTANT        reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    STRING_LITERAL  reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    (               reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)
    ELSE            reduce using rule 190 (selection_statement -> IF ( expr ) statement ELSE statement .)



state 366

    (197) iteration_statement -> FOR ( ; expr ; expr ) statement .

    }               reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    CASE            reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    DEFAULT         reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    ;               reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    IF              reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    SWITCH          reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    WHILE           reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    DO              reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    FOR             reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    GOTO            reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    CONTINUE        reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    BREAK           reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    RETURN          reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    IDENTIFIER      reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    {               reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    INC_OP          reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    DEC_OP          reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    SIZEOF          reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    &               reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    *               reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    +               reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    -               reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    ~               reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    !               reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    CONSTANT        reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    STRING_LITERAL  reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    (               reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)
    ELSE            reduce using rule 197 (iteration_statement -> FOR ( ; expr ; expr ) statement .)



state 367

    (199) iteration_statement -> FOR ( expr ; ; expr ) statement .

    }               reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    CASE            reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    DEFAULT         reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    ;               reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    IF              reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    SWITCH          reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    WHILE           reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    DO              reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    FOR             reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    GOTO            reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    CONTINUE        reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    BREAK           reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    RETURN          reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    IDENTIFIER      reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    {               reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    INC_OP          reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    DEC_OP          reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    SIZEOF          reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    &               reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    *               reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    +               reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    -               reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    ~               reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    !               reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    CONSTANT        reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    STRING_LITERAL  reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    (               reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)
    ELSE            reduce using rule 199 (iteration_statement -> FOR ( expr ; ; expr ) statement .)



state 368

    (200) iteration_statement -> FOR ( expr ; expr ; ) statement .

    }               reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    CASE            reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    DEFAULT         reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    ;               reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    IF              reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    SWITCH          reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    WHILE           reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    DO              reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    FOR             reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    GOTO            reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    CONTINUE        reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    BREAK           reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    RETURN          reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    IDENTIFIER      reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    {               reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    INC_OP          reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    DEC_OP          reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    SIZEOF          reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    &               reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    *               reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    +               reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    -               reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    ~               reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    !               reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    CONSTANT        reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    STRING_LITERAL  reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    (               reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)
    ELSE            reduce using rule 200 (iteration_statement -> FOR ( expr ; expr ; ) statement .)



state 369

    (201) iteration_statement -> FOR ( expr ; expr ; expr ) . statement
    (168) statement -> . labeled_statement
    (169) statement -> . compound_statement
    (170) statement -> . expression_statement
    (171) statement -> . selection_statement
    (172) statement -> . iteration_statement
    (173) statement -> . jump_statement
    (174) labeled_statement -> . identifier : statement
    (175) labeled_statement -> . CASE constant_expr : statement
    (176) labeled_statement -> . DEFAULT : statement
    (179) compound_statement -> . left_bracket right_bracket
    (180) compound_statement -> . left_bracket statement_list right_bracket
    (181) compound_statement -> . left_bracket declaration_list right_bracket
    (182) compound_statement -> . left_bracket declaration_list statement_list right_bracket
    (187) expression_statement -> . ;
    (188) expression_statement -> . expr ;
    (189) selection_statement -> . IF ( expr ) statement
    (190) selection_statement -> . IF ( expr ) statement ELSE statement
    (191) selection_statement -> . SWITCH ( expr ) statement
    (192) iteration_statement -> . WHILE ( expr ) statement
    (193) iteration_statement -> . DO statement WHILE ( expr ) ;
    (194) iteration_statement -> . FOR ( ; ; ) statement
    (195) iteration_statement -> . FOR ( ; ; expr ) statement
    (196) iteration_statement -> . FOR ( ; expr ; ) statement
    (197) iteration_statement -> . FOR ( ; expr ; expr ) statement
    (198) iteration_statement -> . FOR ( expr ; ; ) statement
    (199) iteration_statement -> . FOR ( expr ; ; expr ) statement
    (200) iteration_statement -> . FOR ( expr ; expr ; ) statement
    (201) iteration_statement -> . FOR ( expr ; expr ; expr ) statement
    (202) jump_statement -> . GOTO identifier ;
    (203) jump_statement -> . CONTINUE ;
    (204) jump_statement -> . BREAK ;
    (205) jump_statement -> . RETURN ;
    (206) jump_statement -> . RETURN expr ;
    (216) identifier -> . IDENTIFIER
    (177) left_bracket -> . {
    (72) expr -> . assignment_expr
    (73) expr -> . expr , assignment_expr
    (59) assignment_expr -> . conditional_expr
    (60) assignment_expr -> . unary_expr assignment_operator assignment_expr
    (57) conditional_expr -> . logical_or_expr
    (58) conditional_expr -> . logical_or_expr ? logical_or_expr : conditional_expr
    (15) unary_expr -> . postfix_expr
    (16) unary_expr -> . INC_OP unary_expr
    (17) unary_expr -> . DEC_OP unary_expr
    (18) unary_expr -> . unary_operator cast_expr
    (19) unary_expr -> . SIZEOF unary_expr
    (20) unary_expr -> . SIZEOF ( type_name )
    (55) logical_or_expr -> . logical_and_expr
    (56) logical_or_expr -> . logical_or_expr OR_OP logical_and_expr
    (5) postfix_expr -> . primary_expr
    (6) postfix_expr -> . postfix_expr [ expr ]
    (7) postfix_expr -> . postfix_expr ( )
    (8) postfix_expr -> . postfix_expr ( argument_expr_list )
    (9) postfix_expr -> . postfix_expr . identifier
    (10) postfix_expr -> . postfix_expr PTR_OP identifier
    (11) postfix_expr -> . postfix_expr INC_OP
    (12) postfix_expr -> . postfix_expr DEC_OP
    (21) unary_operator -> . &
    (22) unary_operator -> . *
    (23) unary_operator -> . +
    (24) unary_operator -> . -
    (25) unary_operator -> . ~
    (26) unary_operator -> . !
    (53) logical_and_expr -> . inclusive_or_expr
    (54) logical_and_expr -> . logical_and_expr AND_OP inclusive_or_expr
    (1) primary_expr -> . identifier
    (2) primary_expr -> . CONSTANT
    (3) primary_expr -> . STRING_LITERAL
    (4) primary_expr -> . ( expr )
    (51) inclusive_or_expr -> . exclusive_or_expr
    (52) inclusive_or_expr -> . inclusive_or_expr | exclusive_or_expr
    (49) exclusive_or_expr -> . and_expr
    (50) exclusive_or_expr -> . exclusive_or_expr ^ and_expr
    (47) and_expr -> . equality_expr
    (48) and_expr -> . and_expr & equality_expr
    (44) equality_expr -> . relational_expr
    (45) equality_expr -> . equality_expr EQ_OP relational_expr
    (46) equality_expr -> . equality_expr NE_OP relational_expr
    (39) relational_expr -> . shift_expr
    (40) relational_expr -> . relational_expr < shift_expr
    (41) relational_expr -> . relational_expr > shift_expr
    (42) relational_expr -> . relational_expr LE_OP shift_expr
    (43) relational_expr -> . relational_expr GE_OP shift_expr
    (36) shift_expr -> . additive_expr
    (37) shift_expr -> . shift_expr LEFT_OP additive_expr
    (38) shift_expr -> . shift_expr RIGHT_OP additive_expr
    (33) additive_expr -> . multiplicative_expr
    (34) additive_expr -> . additive_expr + multiplicative_expr
    (35) additive_expr -> . additive_expr - multiplicative_expr
    (29) multiplicative_expr -> . cast_expr
    (30) multiplicative_expr -> . multiplicative_expr * cast_expr
    (31) multiplicative_expr -> . multiplicative_expr / cast_expr
    (32) multiplicative_expr -> . multiplicative_expr % cast_expr
    (27) cast_expr -> . unary_expr
    (28) cast_expr -> . ( type_name ) cast_expr

    CASE            shift and go to state 136
    DEFAULT         shift and go to state 134
    ;               shift and go to state 128
    IF              shift and go to state 146
    SWITCH          shift and go to state 137
    WHILE           shift and go to state 135
    DO              shift and go to state 144
    FOR             shift and go to state 129
    GOTO            shift and go to state 122
    CONTINUE        shift and go to state 131
    BREAK           shift and go to state 142
    RETURN          shift and go to state 126
    IDENTIFIER      shift and go to state 21
    {               shift and go to state 62
    INC_OP          shift and go to state 106
    DEC_OP          shift and go to state 80
    SIZEOF          shift and go to state 85
    &               shift and go to state 87
    *               shift and go to state 83
    +               shift and go to state 89
    -               shift and go to state 81
    ~               shift and go to state 107
    !               shift and go to state 86
    CONSTANT        shift and go to state 78
    STRING_LITERAL  shift and go to state 100
    (               shift and go to state 121


    expression_statement           shift and go to state 119
    unary_expr                     shift and go to state 133
    logical_or_expr                shift and go to state 84
    left_bracket                   shift and go to state 57
    iteration_statement            shift and go to state 120
    additive_expr                  shift and go to state 77
    cast_expr                      shift and go to state 95
    postfix_expr                   shift and go to state 99
    selection_statement            shift and go to state 145
    shift_expr                     shift and go to state 91
    multiplicative_expr            shift and go to state 92
    statement                      shift and go to state 370
    unary_operator                 shift and go to state 105
    and_expr                       shift and go to state 93
    relational_expr                shift and go to state 94
    equality_expr                  shift and go to state 90
    jump_statement                 shift and go to state 139
    conditional_expr               shift and go to state 140
    exclusive_or_expr              shift and go to state 101
    expr                           shift and go to state 141
    compound_statement             shift and go to state 127
    labeled_statement              shift and go to state 123
    inclusive_or_expr              shift and go to state 103
    logical_and_expr               shift and go to state 102
    primary_expr                   shift and go to state 104
    assignment_expr                shift and go to state 143
    identifier                     shift and go to state 125

state 370

    (201) iteration_statement -> FOR ( expr ; expr ; expr ) statement .

    }               reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    CASE            reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    DEFAULT         reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    ;               reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    IF              reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    SWITCH          reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    WHILE           reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    DO              reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    FOR             reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    GOTO            reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    CONTINUE        reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    BREAK           reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    RETURN          reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    IDENTIFIER      reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    {               reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    INC_OP          reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    DEC_OP          reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    SIZEOF          reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    &               reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    *               reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    +               reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    -               reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    ~               reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    !               reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    CONSTANT        reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    STRING_LITERAL  reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    (               reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)
    ELSE            reduce using rule 201 (iteration_statement -> FOR ( expr ; expr ; expr ) statement .)


